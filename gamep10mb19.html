<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>å¤§å¯Œç¿éŠæˆ²</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 1rem; display: flex; }
	#left-panel { flex: 1; }
    #right-panel { width: 750px; margin-left: 10px; }
    #game-board {
      display: grid;
      grid-template-columns: repeat(8,90px);
      grid-template-rows: repeat(8, 90px);
      gap: 2px;
    }
    .cell {
      width: 90px; height: 90px; border: 1px solid #aaa;
      position: relative; background: white;
    }
    .cell img {
      width: 100%; height: 100%; object-fit: contain;
      position: absolute; top: 0; left: 0;
    }
    .order-number {
      position: absolute; bottom: 2px; right: 4px;
      font-size: 10px; background: rgba(255,255,255,0.7);
      padding: 1px 3px; border-radius: 4px;
    }
    .player {
      width: 40px; height: 40px; position: absolute;
      z-index: 5;
    }
    .player1 { top: 4px; left: 4px; }
    .player2 { top: 4px; right: 4px; }
	.player3 { bottom: 4px; left: 4px; }
.player4 { bottom: 4px; right: 4px; }
    .player img { width: 100%; height: 100%; }
    #log {     
	  
	  white-space: pre-line; font-size: 14px;
      background: #f5f5f5; border: 1px solid #ccc; padding: 6px;
      max-height: 600px; overflow-y: auto;  
	  
    }
	 #configInfo {
      background: #e8f4ff;
      padding: 10px;
      border: 1px solid #89b;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 14px;
	  width: 720px;;
    }
	#event-card-display {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 280px; height: 380px;
      background: white;
      border: 2px solid #444;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 9999;
      padding: 20px;
      animation: fadeIn 0.4s ease;
    }
    #event-card-display.show {
      display: flex;
    }
	
	.game-map-wrapper {
  position: relative;
  width: 100%; height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}




.game-map-tooltip {
  visibility: hidden;
  opacity: 0;
  width: max-content;
  max-width: 140px;
  background: #333;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 2px 2px;
  z-index: 10;
  bottom: 100%; left: 50%;
  
  font-size: 12px;
  pointer-events: none;
  white-space: pre-line;
  transition: opacity 0.3s;
}
.game-map-wrapper:hover .game-map-tooltip {
  visibility: visible;
  opacity: 1;
}

#game-over {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%) scale(0);
  background: linear-gradient(135deg, #ff5f6d, #ffc371);
  color: white;
  border: 4px solid #fff;
  border-radius: 15px;
  padding: 30px;
  text-align: center;
  box-shadow: 0 0 30px rgba(0,0,0,0.5);
  z-index: 10000;
  transition: transform 0.5s ease, opacity 0.5s ease;
  opacity: 0;
}

#game-over.show {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

#game-over h1 {
  font-size: 2.5em;
  margin-bottom: 20px;
}

#game-over button {
  background: white;
  color: #ff5f6d;
  border: none;
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.3s, transform 0.3s;
}

#game-over button:hover {
  background: #ffe0e6;
  transform: scale(1.1);
}
	#quiz-history {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%) scale(0);
  background: #fff;
  color: #333;
  border: 3px solid #ccc;
  border-radius: 10px;
  padding: 20px;
  text-align: left;
  box-shadow: 0 0 20px rgba(0,0,0,0.4);
  z-index: 10001;
  width: 400px;
  max-height: 70%;
  overflow-y: auto;
  opacity: 0;
  transition: transform 0.4s, opacity 0.4s;
}

#quiz-history.show {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

#quiz-history h2 {
  text-align: center;
}

#roll-dice-btn {
  background: linear-gradient(135deg, #ff7e5f, #feb47b);
  border: none;
  color: white;
  padding: 2px 2px;
  font-size: 20px;
  font-weight: bold;
  border-radius: 50px;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  transition: all 0.3s ease;
  letter-spacing: 1px;
}

#roll-dice-btn:hover {
  background: linear-gradient(135deg, #feb47b, #ff7e5f);
  transform: translateY(-3px) scale(1.05);
  box-shadow: 0 6px 12px rgba(0,0,0,0.4);
}

#roll-dice-btn:active {
  transform: translateY(0) scale(0.98);
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

/* ==== Scoreboard (ç¾åŒ–) ==== */
#status { margin: 12px 0; }
.score-grid{
   display:grid;
   grid-auto-flow: column;     /* å–®åˆ—æ’åˆ— */
   grid-auto-columns: 1fr;     /* æ¯å¼µå¡ç‰‡ç­‰åˆ†å®¹å™¨å¯¬åº¦ */
   gap:12px; padding:6px 4px;
   overflow:hidden;            /* ä¸è¦æ²è»¸ */
}
.score-card{
  --accent:#e0e0e0;height: 80px;    
  --bg:rgba(0,0,0,.03);
  background: #fff;
  border:2px solid var(--accent);
  border-radius:14px;
  padding:2px 12px;
  display:flex;
  align-items:center;
  justify-content:flex-start;   /* ä¸å†æŠŠå·¦å³æ‹‰åˆ°å…©ç«¯ */
  position:relative;
  gap:12px;  
  box-shadow: 0 3px 10px rgba(0,0,0,.06);
  grid-template-columns: 120px 1fr auto;
}
@media (max-width: 900px){
  .score-card{ grid-template-columns: 100px 1fr auto; }
}
.player-avatar{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:6px;
}
.player-avatar .token{ width:36px; height:36px; object-fit:contain }
.player-avatar .name{ font-weight:800; letter-spacing:.4px; line-height:1.1 }
.score-card .left{display:flex;align-items:center;gap:10px}

.score-card .right{  display:flex;  flex-direction:column;      align-items:flex-start;     gap:6px;    flex:1;                 }
.score{font-size:22px;font-weight:800}
.badges{display:flex;gap:6px}
.badge.pause{ border-style: dashed; opacity:.9 }
.badge{font-size:12px;border:1px solid var(--accent);padding:2px 8px;border-radius:999px;background:var(--bg)}
.score-card.active{
  box-shadow:
    0 0 0 6px rgba(var(--accent-rgb,0,0,0), .45),
    0 10px 24px rgba(0,0,0,.18);
  transform: translateY(-1px);
}
/* Colors: P1ç´… / P2è— / P3ç¶  / P4ç´… */
.score-card.p1{ --accent:#e74c3c; --accent-rgb:231,76,60;  }
.score-card.p2{ --accent:#3498db; --accent-rgb:52,152,219;  }
.score-card.p3{ --accent:#2ecc71; --accent-rgb:46,204,113; }
.score-card.p4{ --accent:#f1c40f; --accent-rgb:241,196,15;  } 

.skill-cards{ display:flex; align-items:center; gap:6px; flex-wrap:wrap; min-height:28px; }
.skill-cards .scard{
  width:22px; height:22px; padding:1px;
  border:1px solid var(--accent); border-radius:4px; background:#fff;
  box-shadow:0 1px 2px rgba(0,0,0,.15);
  display:inline-flex; align-items:center; justify-content:center;
}
.skill-cards .scard img{ width:100%; height:100%; object-fit:contain; display:block; }
.goal{
  width:60px;              /* â† é€²åº¦æ¢åº•é•·åº¦å›ºå®š */
  height:8px;
  border-radius:999px;
  background:#eef1f6;       /* åº•è‰² */
  overflow:hidden;
  position:relative;
}
.goal .bar{
  height:100%;
  width:0%;                 /* ç”± JS ä»¥ç™¾åˆ†æ¯”è¨­å®š */
  background:linear-gradient(90deg,var(--accent,#888), rgba(0,0,0,.15));
  transition: width .35s ease;
}
.goal{
  width:80px; height:8px; border-radius:999px;
  background:#eef1f6; overflow:hidden; position:relative;
}
.goal .bar{
  height:100%;
  width:0%;
  background: linear-gradient(90deg, var(--accent,#888), rgba(0,0,0,.15));
  transition: width .35s ease;
}
/* ç›®æ¨™é”æˆæ™‚ç”¨å¯¦è‰²ï¼Œå³ç·£çœ‹èµ·ä¾†æ‰æœƒã€ŒçœŸçš„æ»¿ã€ */
.goal .bar.full{ background: var(--accent,#888); }
.score-card.winner::after{
  content:"ğŸ‘‘";
  position:absolute;
  top:-12px; right:-12px;
  font-size:32px;
  filter: drop-shadow(0 2px 2px rgba(0,0,0,.25));
}
  </style>
</head>
<body>
<div id="left-panel">
  <div id="configInfo"></div>
   <div id="status" style="margin: 10px 0;"></div>
  <div>
    <button id="roll-dice-btn" onclick="rollDice()">ğŸ² ç©å®¶ <span id="currentPlayer">1</span></button>
	
    å‰›å‰›ç©å®¶<span id="people">-</span> æ“²å‡º <span id="diceResult">-</span>
	
	
	
	
	
  </div>
  <fieldset style="margin-top: 10px; border: 1px solid #ccc; padding: 10px;width: 720px">
  
  <legend>ğŸ¯ æŒ‡å®šéª°å­é»æ•¸ï¼ˆä½œå¼Šç”¨ï¼‰</legend>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="0" checked> ä¸æŒ‡å®š</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="1"> 1</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="2"> 2</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="3"> 3</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="4"> 4</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="5"> 5</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="6"> 6</label>
</fieldset>
  <div id="game-board"></div>
  
  
</div>
<div id="right-panel">
    <h2>ğŸ²ç´€éŒ„</h2>
  <div id="log"></div>
  <div id="event-card-display"></div>
  </div>
  <div id="game-over" class="hidden">
  <h1>ğŸ† éŠæˆ²çµæŸ ğŸ†</h1>
  <p id="winner-text"></p>
  <button onclick="restartGame()">é‡æ–°é–‹å§‹</button>
  <button onclick="showQuizHistory()">æª¢è¦–ç­”é¡Œç´€éŒ„</button>
  <button onclick="closeGameOver()">âŒ é—œé–‰</button>
</div>
  <!-- é¡¯ç¤ºç­”é¡Œè¨˜éŒ„çš„å€å¡Š -->
<div id="quiz-history" class="hidden">
  <h2>ğŸ“š ç­”é¡Œç´€éŒ„</h2>
  <div id="quiz-list"></div>
  <button onclick="closeQuizHistory()">é—œé–‰</button>
</div>
  
<audio id="diceSound" src="dice-sound.mp3" preload="auto"></audio>
<script>


let config = {};
try { config = JSON.parse(localStorage.getItem("gameConfig") || '{}'); } catch (e) { config = {}; }

// ---- é è¨­åœ°åœ–ï¼ˆç•¶æœªè¼‰å…¥ä»»ä½•åœ°åœ–è¨­å®šæ™‚å•Ÿç”¨ï¼‰----

function __buildDefaultMap() {
  // å¤–åœˆè·¯å¾‘ï¼ˆ8x8ï¼‰ï¼šä¸Šâ†’å³â†’ä¸‹â†’å·¦ï¼ˆå…± 28 æ ¼ï¼‰
  const ring = [];
  for (let c = 0; c < 8; c++) ring.push(0 * 8 + c);     // top row 0..7
  for (let r = 1; r < 8; r++) ring.push(r * 8 + 7);     // right col
  for (let c = 6; c >= 0; c--) ring.push(7 * 8 + c);    // bottom row
  for (let r = 6; r >= 1; r--) ring.push(r * 8 + 0);    // left col

  // ä½¿ç”¨ä½ æä¾›çš„ map1 é™£åˆ—èªæ³•ï¼ˆåªæ”¾ç½®æœ‰å…§å®¹çš„æ ¼å­ï¼‰
  const map1 = [
 { index: 0, img: 'start.png' },
      { index: 1, img: 'fire_station_0.png' },
      { index: 2, img: 'event1.png' },
      { index: 3, img: 'bag1.png' },
      { index: 4, img: 'museum921_0.png' },
      { index: 5, img: 'event1.png' },
      { index: 6, img: 'dice.png' },
      { index: 7, img: 'event1.png' },
      { index: 15, img: 'underdesk.png' },
	  { index: 23, img: 'water_bureau_0.png' },
      { index: 31, img: 'event1.png' },
      { index: 39, img: 'rain1.png' },
      { index: 38, img: 'ok3.png' },
      { index: 37, img: 'dice.png' },
	  { index: 36, img: 'event1.png' },
      { index: 28, img: 'quiz_earthquake.png' },
      { index: 20, img: 'ok2.png' },     
	  { index: 19, img: 'event1.png' },
      { index: 27, img: 'fire2.png' },
      { index: 35, img: 'event2.png' },
      { index: 34, img: 'rain1.png' },
	  { index: 33, img: 'ok1.png' },
	  { index: 32, img: 'event1.png' },
      { index: 24, img: 'earthquake3.png' },
      { index: 16, img: 'event2.png' },
      { index: 17, img: 'rain1.png' },
	  { index: 9, img: 'quiz_water.png' },
      { index: 8, img: 'quiz_fire.png' },
  ];

  // è½‰æˆéŠæˆ²ç”¨çš„ mapData çµæ§‹ï¼ˆindex -> imgï¼‰
  const map = {};
  for (const {index, img} of map1) {
    if (Number.isInteger(index) && typeof img === 'string') {
      map[index] = img;
    }
  }
  return { ring, map };
}


// è‹¥æ²’æœ‰åœ°åœ–ï¼ˆpathIndices æˆ– mapData çš†å¯ä½œç‚ºåˆ¤æ–·ï¼‰â†’ å¥—ç”¨é è¨­
(function __ensureDefaults(){
  const needPath = !Array.isArray(config.pathIndices) || config.pathIndices.length === 0;
  const needMap  = !config.mapData || Object.keys(config.mapData).length === 0;

  if (needPath || needMap) {
    const { ring, map } = __buildDefaultMap();
    if (needPath) config.pathIndices = ring;
    if (needMap)  config.mapData     = map;
    if (!config.mode)         config.mode = "score";
    if (!config.scoreTarget)  config.scoreTarget = 20;
    if (!config.timeLimit)    config.timeLimit = 120;
    if (!config.playerCount)  config.playerCount = 2;
  }
})();


const { mode, timeLimit, scoreTarget,playerCount, mapData, pathIndices } = config;
const nPlayers = config.playerCount || 2; 
document.getElementById("configInfo").innerText = 
  mode === "time"
    ? `ğŸ¯ æ¨¡å¼ï¼šé™æ™‚åˆ¶ï¼ˆ${timeLimit} ç§’ï¼‰`
    : `ğŸ¯ æ¨¡å¼ï¼šç©åˆ†åˆ¶ï¼ˆ${scoreTarget} åˆ†ï¼‰`;
const gameBoard = document.getElementById("game-board");
const logEl = document.getElementById("log");
document.getElementById("configInfo").innerText = "é˜²ç½å¤§å¯Œç¿" + document.getElementById("configInfo").innerText ;
console.log(config);

let playerSteps = new Array(nPlayers).fill(0);
let playerScores = new Array(nPlayers).fill(8);
let playerSkills = new Array(nPlayers).fill(1); // æ¯äººåˆå§‹1æŠ€èƒ½å¡
let skipTurn = new Array(nPlayers).fill(false);
let lastDiceRoll = new Array(nPlayers).fill(0);
let playerTokens = new Array(nPlayers).fill(null);
let currentPlayer = 0;

let gameEnded = false;
let winnerIndex = null;
let timer = null;
let timeLeft = timeLimit;

let quizHistory = []; 
let isAskingQuiz = false; // âœ… é˜²å‘†ï¼šé¿å…åŒä¸€å›åˆé‡è¤‡å½ˆå‡ºå•ç­”

function isQuizTileName(name) {
  if (!name) return false;
  return name.includes("quiz_earthquake.png") || name.includes("quiz_fire.png") || name.includes("quiz_water.png");
}

function closeGameOver() {
  document.getElementById('game-over').classList.remove('show');
}
let quizQuestions = [];
let passedStart = false;

const QUIZ = {
  fire: [
    { category:'fire', question:'é‡åˆ°æ¿ƒç…™æ™‚æ‡‰è©²æ€éº¼åšï¼Ÿ',
      options:['ä½å§¿å‹¢æ©ä½å£é¼»å‰é€²','æŠ¬é ­å¿«è·‘','æ­é›»æ¢¯é›¢é–‹'], answer:0 },
    { category:'fire', question:'ä½¿ç”¨æ»…ç«å™¨æ­¥é©Ÿï¼ˆPASSï¼‰å“ªå€‹æ˜¯éŒ¯çš„ï¼Ÿ',
      options:['æ‹‰é–‹æ’æ¢¢','å°æº–æ ¹éƒ¨','å°æ¿ƒç…™é ‚éƒ¨'], answer:2 },
    { category:'fire', question:'ç™¼ç¾ç«ç½æ™‚ï¼Œå…ˆåšä»€éº¼æœ€å®‰å…¨ï¼Ÿ',
      options:['ç«‹å³è¿”å›æ‹¿è²´é‡ç‰©','å¤§å–Šè‘—ç«ä¸¦é€šå ±','å¾€æ¨“ä¸Šè·‘'], answer:1 }
  ],
  water: [
    { category:'water', question:'æ·¹æ°´ä¾†è¥²å‰å®¶ä¸­æ‡‰å…ˆï¼Ÿ',
      options:['å…ˆæ–·é›»','å…ˆæ²–é¦¬æ¡¶','æ‰“é–‹ç“¦æ–¯'], answer:0 },
    { category:'water', question:'æ¶‰æ°´é€šè¡Œçš„å±éšªåœ¨æ–¼ï¼Ÿ',
      options:['æ°´æµæ¹æ€¥ã€æ©è“‹å‘æ´','é‹æœƒæ¿•','çœ‹èµ·ä¾†å¾ˆé«’'], answer:0 },
    { category:'water', question:'è±ªé›¨ç‰¹å ±æ™‚æ‡‰è©²ï¼Ÿ',
      options:['å¾…åœ¨ä½çªªè™•','é—œæ³¨æ°£è±¡ä¸¦é¿å…é è¿‘æ²³å·','ç›´æ¥å»çœ‹æµ·'], answer:1 }
  ],
  earthquake: [
    { category:'earthquake', question:'åœ°éœ‡ä¾†æ™‚æœ€å®‰å…¨çš„èº²é¿ä½ç½®æ˜¯ï¼Ÿ',
      options:['é›»æ¢¯è£¡','æ¡Œå­ä¸‹','é™½å°'], answer:1 },
    { category:'earthquake', question:'åœ°éœ‡æ™‚ï¼Œæ‡‰è©²ç«‹åˆ»åšä»€éº¼ï¼Ÿ',
      options:['è·‘å‡ºæ•™å®¤','æ‰¾å …å›ºç‰©å“èº²é¿','æ‹¿æ‰‹æ©Ÿæ‹ç…§'], answer:1 },
    { category:'earthquake', question:'å“ªä¸€é …æ˜¯åœ°éœ‡æ™‚ã€Œä¸æ‡‰è©²ã€åšçš„äº‹ï¼Ÿ',
      options:['èº²åœ¨ç‰†è§’','å¾€çª—æˆ¶é è¿‘','ä¿æŒå†·éœ'], answer:0 }
  ]
};
//fetch("quiz_all.json")
//  .then(res => res.json())
 // .then(data => quizQuestions = data);
 // const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
 
  
// é¡Œåº«æ ¼å¼å»ºè­°ï¼š[{ category: "earthquake"|"fire"|"water", question, options:[], answer }]
// answer å¯æ˜¯æ•¸å­—ç´¢å¼•(0-based) æˆ– èˆŠæ ¼å¼çš„ã€Œé¸é …å­—é¦–ã€(ä¾‹å¦‚ "A." / "B.")
function getRandomQuiz(category){
  let pool = [];
  if (category === 'fire') pool = QUIZ.fire;
  else if (category === 'water') pool = QUIZ.water;
  else if (category === 'earthquake') pool = QUIZ.earthquake;
  else pool = [...QUIZ.fire, ...QUIZ.water, ...QUIZ.earthquake];
  if (!pool.length) return null;
  return pool[Math.floor(Math.random() * pool.length)];
}

// å…¼å®¹ä½ åŸæœ¬çš„ç­”é¡Œåˆ¤å®šï¼šæ”¯æ´ã€Œç´¢å¼•ã€æˆ–ã€Œå­—é¦–ã€
function isCorrectAnswer(quizObj, optionText, optionIndex) {
  if (typeof quizObj.answer === 'number') {
    return optionIndex === quizObj.answer; // 0-based ç´¢å¼•
  }
  if (typeof quizObj.answer === 'string') {
    // èˆŠæ ¼å¼ï¼šoption ä»¥ "A. xxx"ï¼›quiz.answer = "A"
    const prefix = optionText.trim().slice(0, quizObj.answer.length);
    return prefix === quizObj.answer;
  }
  return false;
}

const PROPERTY_DEFS = {
  fire_station: { price: 5, display: 'æ¶ˆé˜²å±€' },
  water_bureau: { price: 5, display: 'æ°´åˆ©å±€' },
  school: { price: 5, display: 'å­¸æ ¡' },
  museum921: { price: 5, display: '921 åšç‰©é¤¨' }
};  
const propertyOwners = {};   // { [cellIndex]: 1|2|3|4|null }
const propertyKeys   = {};   // { [cellIndex]: 'fire_station'|'water_bureau'|... } å¿«å–åŠ é€Ÿç”¨

function getPropertyKey(src) {
  if (!src) return null;
  const name = src.split('/').pop().toLowerCase();

  // å…ˆèµ°ã€Œæ¨™æº–æª”åã€è¦å‰‡ï¼š<key>_<owner>.png
  for (const key of Object.keys(PROPERTY_DEFS)) {
    if (name.startsWith(key + '_')) return key;
  }

  // å…¼å®¹ä½ ç”¨ç”Ÿæˆå™¨ç”¢å‡ºçš„é•·æª”åï¼šç”¨é—œéµå­—/åˆ¥åæ¨æ–·
  const patterns = [
    { key: 'fire_station',  re: /(fire[\s_\-]?station|æ¶ˆé˜²)/ },
    { key: 'water_bureau',  re: /(water[\s_\-]?(bureau|dept|department)|æ°´åˆ©)/ },
    { key: 'school',        re: /(school|å­¸æ ¡)/ },
    { key: 'museum921',     re: /(921|museum)/ }
  ];
  for (const {key, re} of patterns) {
    if (re.test(name)) return key;
  }
  return null;
}

function getOwnerFromImg(src) {
  if (!src) return null;
  const name = src.split('/').pop().toLowerCase();
  const m = name.match(/_(\d)\.(png|webp|jpg)$/);
  return m ? parseInt(m[1], 10) : null;
}

function imageForOwner(key, owner) {
  return `${key}_${owner || 0}.png`;
}

function setTileImage(index, newImg) {
  mapData[index] = newImg;
  const cell = gameBoard.children[index];
  const imgEl = cell && cell.querySelector('img');
  if (imgEl) imgEl.src = newImg;
}

const eventList = [
  { desc: "E01ï¼šåœ°éœ‡ç™¼ç”Ÿæ™‚ï¼Œä½ ç«‹åˆ»èº²åˆ°å …å›ºæ¡Œå­ä¸‹ã€‚å¹¸é‹é€ƒéä¸€åŠ«ï¼", effect: "é€€å›1æ ¼" },
  { desc: "E02ï¼šåœ°éœ‡æ™‚ä½ è·‘å‘æ¨“æ¢¯é€ƒç”Ÿï¼Œè¢«è­¦è¡›åˆ¶æ­¢ã€‚åœä¸€å›åˆåæ€ã€‚", effect: "é€€å›2æ ¼" },
  { desc: "E03ï¼šä½ å¿˜äº†å›ºå®šæ›¸æ«ƒï¼Œåœ°éœ‡æ™‚æ±è¥¿æ‰ä¸‹ä¾†ï¼Œè«‹é€€å›1æ ¼ã€‚", effect: "åœä¸€å›åˆ" },
  { desc: "E04ï¼šåœ°éœ‡å¾Œé¦¬ä¸Šé–‹ç“¦æ–¯ç…®æ³¡éºµï¼Œç™¼ç”Ÿç«è­¦ï¼", effect: "å›åˆ°èµ·é»" },
  { desc: "E05ï¼šä½ ç†Ÿè¨˜ç–æ•£è·¯ç·šï¼Œè¿…é€Ÿå¸¶åŒå­¸æ’¤é›¢ï¼Œç²å¾—å¾—2åˆ†ã€‚", effect: "å¾—1åˆ†" },
  { desc: "E06ï¼šä½ ç”¨é˜²ç½åŒ…ä¸­çš„å“¨å­å‘¼æ•‘ï¼ŒæˆåŠŸç²æ•‘ï¼", effect: "å‰é€²2æ ¼" },
  { desc: "E07ï¼šä½ å†·éœèº²é¿ä¸¦å¹«åŠ©åŒå­¸é€ƒé›¢ï¼Œè¡¨ç¾å„ªç§€ï¼", effect: "é€€å›2æ ¼" },
  { desc: "E08ï¼šåœ°éœ‡å¾Œæ‰“é›»è©±å ±å¹³å®‰ï¼Œé›»è©±æ“å¡ä¸­ã€‚", effect: "å‰é€²1æ ¼" },
  { desc: "E09ï¼šåœ°éœ‡æ™‚çª—æˆ¶ç ´è£‚ä½ è¢«ç¢ç»ç’ƒåŠƒå‚·ã€‚", effect: "å›åˆ°èµ·é»" },
  { desc: "E10ï¼šä½ åƒåŠ é˜²éœ‡æ¼”ç·´ï¼Œç†Ÿæ‚‰é¿é›£è·¯ç·šï¼", effect: "é€€å›1æ ¼" },
  { desc: "E11ï¼šä½ èº²åœ¨æ›¸æ«ƒæ—é‚Šï¼Œè¢«æ›¸å£“å€’ã€‚", effect: "å›åˆ°èµ·é»" },
  { desc: "E12ï¼šåœ°éœ‡æ™‚ä½ å¤§å–Šã€Œä¸è¦å‹•ã€è®“å¤§å®¶é©šæ…Œã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E13ï¼šä½ èº²åœ¨å»æ‰€è£¡ï¼Œè¢«å¡ä½äº†ï¼", effect: "é€€å›2æ ¼" },
  { desc: "E14ï¼šä½ è·Ÿæœ‹å‹é–‹ç©ç¬‘èªªã€Œåœ°éœ‡å¿«ä¾†ã€ï¼ŒçµæœçœŸçš„æ–äº†ï¼", effect: "é€€å›1æ ¼" },
  { desc: "E15ï¼šåœ°éœ‡æ™‚ï¼Œä½ æ‹å½±ç‰‡ä¸Šå‚³ï¼Œåè€Œçµ†å€’è¢«å›°ä½ã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E16ï¼šä½ å¹«è€å¸«æ¬é˜²ç½ç‰©è³‡ï¼Œæœ‰å‚™ç„¡æ‚£ã€‚", effect: "é€€å›2æ ¼" },
  { desc: "E17ï¼šåœ°éœ‡åŒ…è£¡æœ‰æ°´å’Œå“¨å­ï¼Œä½ å†·éœç­‰å¾…æ•‘æ´ï¼", effect: "å›åˆ°èµ·é»" },
  { desc: "E18ï¼šä½ è½å¾å»£æ’­æŒ‡ç¤ºå‰å¾€ç©ºåœ°é¿é›£ã€‚", effect: "å¾—1åˆ†" }
];

buildBoard();
updateStatus();


  if (mode === "score") {
    // ç§¯åˆ†åˆ¶ï¼šè¨­å®šç›®æ¨™åˆ†æ•¸
	
    //scoreGoal = parseInt(document.getElementById("scoreTarget").value);
  } else if (mode === "time") {
    // é™æ™‚åˆ¶ï¼šå•Ÿå‹•å€’æ•¸è¨ˆæ™‚
    timeLeft = config.timeLimit;
    const configInfo = document.getElementById("configInfo");
    configInfo.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ `;

    timer = setInterval(() => {
      timeLeft--;
      configInfo.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ `;

      if (timeLeft <= 0) {
        clearInterval(timer);
        gameEnded = true;

        // æ¯”è¼ƒé›™æ–¹åˆ†æ•¸
        const maxScore = Math.max(...playerScores);
		// æ‰¾å‡ºæ‰€æœ‰æœ€é«˜åˆ†çš„ç©å®¶ï¼ˆæ”¯æ´å¤šäººå¹³æ‰‹ï¼‰
		const winners = [];
		for (let i = 0; i < playerScores.length; i++) {
		  if (playerScores[i] === maxScore) {
			winners.push(i + 1); // ç©å®¶ç·¨è™Ÿå¾1é–‹å§‹
		  }
		}
		if (winners.length === 1) {
		  alert(`âŒ› æ™‚é–“åˆ°ï¼ ç©å®¶ ${winners[0]} ä»¥ ${maxScore} åˆ†ç²å‹`);
		  winnerIndex = winners[0]-1; 
		  updateStatus();  // â† 0-based
		  showGameOverScreen(`âŒ› æ™‚é–“åˆ°ï¼ ç©å®¶ ${winners[0]} ä»¥ ${maxScore} åˆ†ç²å‹`);
		} else {
		  alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ¤ å¹³æ‰‹ï¼ç©å®¶ ${winners.join("ã€")} å„å¾— ${maxScore} åˆ†`);
		  showGameOverScreen(`âŒ› æ™‚é–“åˆ°ï¼ğŸ¤ å¹³æ‰‹ï¼ç©å®¶ ${winners.join("ã€")} å„å¾— ${maxScore} åˆ†`);
		}
		
		
		
      }
    }, 1000);
  }

function getDescription(filename) {
  const name = filename.split('/').pop().trim();
  const descriptions = {
    "start.png": "èµ·é»ï¼šç©å®¶å¾é€™è£¡é–‹å§‹",    
    "quiz.png": "ç­”é¡Œæ ¼ï¼šç­”å°å¯å¾—åˆ†",
	"quiz_fire.png": "ç«ç½ç›¸é—œå•é¡Œç­”é¡Œæ ¼ï¼šç­”å°å¯å¾—åˆ†",
    "quiz_water.png": "æ°´ç½ç›¸é—œå•é¡Œç­”é¡Œæ ¼ï¼šç­”å°å¯å¾—åˆ†",
    "quiz_earthquake.png": "åœ°éœ‡ç›¸é—œå•é¡Œç­”é¡Œæ ¼ï¼šç­”å°å¯å¾—åˆ†",
    "event1.png": "äº‹ä»¶å¡1ï¼šéš¨æ©Ÿäº‹ä»¶",
    "event2.png": "äº‹ä»¶å¡2ï¼šéš¨æ©Ÿäº‹ä»¶",
	"fire1.png": "ç™¼ç”Ÿç«ç½",
    "fire2.png": "ç™¼ç”Ÿç«ç½", 
	"light.png": "ç‡ˆå…‰",
    "bag1.png": "æ€¥æ•‘åŒ…ï¼Œå¯åŠ åˆ†", 
	"bag2.png": "æ€¥æ•‘åŒ…ï¼Œå¯åŠ åˆ†",
    "card1.png": "ç©ºç™½å¡ç‰‡",
	"card2.png": "ç‰¹æ®ŠæŠ€èƒ½å¡",
	"earthquake1.png": "ç™¼ç”Ÿåœ°éœ‡äº†", 
	"earthquake2.png": "ç™¼ç”Ÿåœ°éœ‡äº†",
    "earthquake3.png": "ç™¼ç”Ÿåœ°éœ‡äº†",
	"ok1.png": "ç„¡ç‰¹æ®Šäº‹ä»¶",
	"ok2.png": "ç„¡ç‰¹æ®Šäº‹ä»¶",
	"ok3.png": "ç„¡ç‰¹æ®Šäº‹ä»¶",
	"rain1.png": "ç™¼ç”Ÿæ°´ç½",
	"rain2.png": "ç™¼ç”Ÿæ°´ç½",
	"rain3.png": "ç™¼ç”Ÿæ°´ç½",
	"safe.png": "å®‰å…¨å€",
	"safezone.png": "å®‰å…¨å€",
	"warning1.png": "è­¦å‘Š",
	"warning2.png": "è­¦å‘Š",	
    "underdesk.png": "ç™¼ç”Ÿåœ°éœ‡ï¼Œèº²åˆ°æ¡Œä¸‹ï¼Œé€€å›èµ·é»",
    "dice.png": "éª°å­æ ¼ï¼šå¯ä»¥å†æ“²ä¸€æ¬¡",
	"fire_station_0.png":"æ¶ˆé˜²å±€",
	  "water_bureau_0.png": "æ°´åˆ©å±€",
	  "museum921_0.png": "åœ°éœ‡åšç‰©é¤¨",
    // ...å¯ä»¥åŠ æ›´å¤š
  };
  return descriptions[name] ||  "";
}


function buildBoard() {
  for (let i = 0; i < 64; i++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    if (mapData[i]) {
      const wrapper = document.createElement("div");
	  wrapper.className = "game-map-wrapper";
	  // åŠ åœ–ç‰‡
	  const img = new Image();
	  img.src = mapData[i];
      const pKey = getPropertyKey(mapData[i]);
if (pKey) {
  propertyKeys[i] = pKey;
  propertyOwners[i] = getOwnerFromImg(mapData[i]) ?? 0;// 0 æˆ– null ä»£è¡¨ç„¡äºº
}
	  wrapper.appendChild(img);
	  // åŠ  tooltip
	  const tooltip = document.createElement("div");
	  tooltip.className = "game-map-tooltip";
	  tooltip.textContent = getDescription(img.src);
	  wrapper.appendChild(tooltip);

	  cell.appendChild(wrapper);
    }
    if (pathIndices.includes(i)) {
      const label = document.createElement("div");
      label.className = "order-number";
      label.textContent = pathIndices.indexOf(i) + 1;
      cell.appendChild(label);
    }
    gameBoard.appendChild(cell);
  }
  renderPlayers();
  if (!pathIndices || pathIndices.length === 0) {
  alert("âš ï¸ è«‹å…ˆå¾ editor.html è¨­å®šç§»å‹•é †åºä¸¦é–‹å§‹éŠæˆ²ï¼");
}
}
function askQuiz(playerIndex, onCorrect, onWrong, quizOverride /* å¯é¸ï¼šæŒ‡å®šé¡Œç›® */) {
  const synth = window.speechSynthesis;
  const quiz = quizOverride || getRandomQuiz(null);
  if (!quiz) { alert("ç›®å‰æ²’æœ‰é¡Œç›®å¯ç”¨"); (onWrong||(()=>{}))(); return; }

  const modal = document.createElement("div");
  modal.style.position = "fixed";
  modal.style.top = "0";
  modal.style.left = "0";
  modal.style.width = "100%";
  modal.style.height = "100%";
  modal.style.backgroundColor = "rgba(0,0,0,0.7)";
  modal.style.display = "flex";
  modal.style.justifyContent = "center";
  modal.style.alignItems = "center";
  modal.style.zIndex = "9999";

  const box = document.createElement("div");
  box.style.background = "white";
  box.style.padding = "20px";
  box.style.borderRadius = "8px";
  box.style.width = "300px";
  box.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
  box.style.textAlign = "center";
  box.style.animation = "slideIn 0.4s ease-out";

  const q = document.createElement("h3");
  q.textContent = quiz.question;
  box.appendChild(q);

  quiz.options.forEach((opt, idx) => {
    const btn = document.createElement("button");
    btn.textContent = opt;
    btn.style.display = "block";
    btn.style.margin = "8px auto";
    btn.style.padding = "8px 16px";
    btn.style.fontSize = "16px";
    btn.style.cursor = "pointer";
    btn.onclick = () => {
      document.body.removeChild(modal);

      const dt = Date.now() - t0;
      const correct = isCorrectAnswer(quiz, opt, idx);

      // ç”¢ç”Ÿã€Œæ­£ç¢ºç­”æ¡ˆé¡¯ç¤ºæ–‡å­—ã€
      let correctLabel = "";
      if (typeof quiz.answer === 'number') {
        correctLabel = quiz.options[quiz.answer];
      } else if (typeof quiz.answer === 'string') {
        const match = quiz.options.find(o => o.trim().startsWith(quiz.answer));
        correctLabel = `${quiz.answer}${match ? ` (${match})` : ""}`;
      }

      // å¯«å…¥æ­·å²
      quizHistory.push({
player: playerIndex + 1,
        question: quiz.question,
        selected: opt,
        correctAnswer: correctLabel || "",
        result: correct ? "âœ”ï¸ æ­£ç¢º" : "âŒ éŒ¯èª¤",
        category: quiz.category || "-",
        ms: dt,
        correct: correct
      });
// çµæœè™•ç†ï¼ˆä¿ç•™ä½ åŸæœ¬åŠ åˆ†/ä¸åŠ åˆ†ç”±å‘¼å«ç«¯æ±ºå®šï¼‰
      if (correct) {
        alert("ç­”å°äº†ï¼");
        onCorrect && onCorrect();
      } else {
        alert("ç­”éŒ¯äº†ï¼");
        onWrong && onWrong();
      }
    };
    box.appendChild(btn);
  });

  modal.appendChild(box);

  // èªéŸ³æœ—è®€
  //try {
   // const utterance = new SpeechSynthesisUtterance(`${quiz.question} é¸é …æ˜¯ï¼š${quiz.options.join('ã€')}`);
   // utterance.lang = 'zh-TW';
  //  synth.speak(utterance);
  //} catch(_) {}

  document.body.appendChild(modal);
}


function showQuizHistory() {
  const historyEl = document.getElementById('quiz-list');
  // æ˜ç´°åˆ—è¡¨
  const detailHTML = quizHistory.map(h =>
    `<div>ç©å®¶${h.player}ï¼š${h.question}<br>
      â¡ï¸ ä½ ç­”ï¼š${h.selected}ï¼Œ${h.result}
      ${typeof h.ms === 'number' ? `ï¼ˆ${h.ms} msï¼‰` : ``}<br>
      âœ… æ­£è§£: ${h.correctAnswer} ${h.category ? `ï½œ é¡åˆ¥ï¼š${h.category}` : ``}
     </div><hr>`
  ).join('');

  // æ•´ç†æ¯ä½ç©å®¶çµ±è¨ˆ
  const players = typeof nPlayers !== 'undefined' ? nPlayers : Math.max(1, ...quizHistory.map(h=>h.player||1));
  const stats = [];
  for (let p = 1; p <= players; p++) {
    const items = quizHistory.filter(h => h.player === p);
    const n = items.length;
    const right = items.filter(h => h.correct === true || /æ­£ç¢º/.test(h.result||'')).length;
    const acc = n ? (right / n * 100) : 0;
    const avgMs = n ? Math.round(items.reduce((s,h)=> s + (Number(h.ms)||0), 0) / n) : 0;
    const by = { fire:{n:0,c:0}, water:{n:0,c:0}, earthquake:{n:0,c:0} };
    items.forEach(h => {
      const t = (h.category||'').toLowerCase();
      if (by[t]) {
        by[t].n += 1;
        by[t].c += (h.correct === true || /æ­£ç¢º/.test(h.result||'')) ? 1 : 0;
      }
    });
    const pct = (c,n) => n ? (Math.round((c/n*100)*10)/10) : 0;
    stats.push({
      player:p,
      count:n,
      acc: +(Math.round(acc*10)/10),
      avgMs,
      fireAcc: pct(by.fire.c, by.fire.n),
      waterAcc: pct(by.water.c, by.water.n),
      eqAcc: pct(by.earthquake.c, by.earthquake.n)
    });
  }

  // ç”¢ç”Ÿè¡¨æ ¼
  const table = `
    <style>
      .stats-table{border-collapse:collapse;width:100%;font-size:14px;margin-top:8px}
      .stats-table th,.stats-table td{border:1px solid #ddd;padding:6px 8px;text-align:center}
      .stats-table th{background:#f7f7f7}
    </style>
    <h3>ğŸ‘¥ æ¯ä½ç©å®¶å·®ç•°</h3>
    <table class="stats-table" aria-label="æ¯ä½ç©å®¶ç­”é¡Œçµ±è¨ˆ">
      <thead>
        <tr>
          <th>ç©å®¶</th><th>ç­”é¡Œæ•¸</th><th>ç­”å°ç‡(%)</th><th>å¹³å‡ç­”é¡Œæ™‚é–“(ms)</th>
          <th>ç«ç½æ­£ç¢ºç‡(%)</th><th>æ°´ç½æ­£ç¢ºç‡(%)</th><th>åœ°éœ‡æ­£ç¢ºç‡(%)</th>
        </tr>
      </thead>
      <tbody>
        ${stats.map(s=>`
          <tr>
            <td>ç©å®¶${s.player}</td>
            <td>${s.count}</td>
            <td>${s.acc}</td>
            <td>${s.avgMs}</td>
            <td>${s.fireAcc}</td>
            <td>${s.waterAcc}</td>
            <td>${s.eqAcc}</td>
          </tr>`).join('')}
      </tbody>
    </table>`;

  historyEl.innerHTML = detailHTML + table;
  document.getElementById('quiz-history').classList.add('show');
}
ï¼š${h.question}<br> â¡ï¸ ä½ ç­”ï¼š${h.selected}ï¼Œ${h.result}<br> âœ… æ­£è§£: ${h.correctAnswer}</div><hr>`
  ).join('');
  document.getElementById('quiz-history').classList.add('show');
}

function closeQuizHistory() {
  document.getElementById('quiz-history').classList.remove('show');
}



function renderPlayers() {
console.log("renderPlayers");
  document.querySelectorAll(".player").forEach(p => p.remove());
  for (let idx = 0; idx < nPlayers; idx++) {
    const cellIndex = pathIndices[playerSteps[idx]];
    const cell = gameBoard.children[cellIndex];
    const token = document.createElement("div");
    token.className = `player player${idx+1}`;
    const carImgs = ["car_red.png", "car_blue.png", "car_green.png", "car_yellow.png"];
    const car = new Image();
    car.src = carImgs[idx] || "car_red.png";
    token.appendChild(car);
    cell.appendChild(token);
    playerTokens[idx] = token;
  }
}
function rollDice() {
    
  if (gameEnded) return;
  
  console.log("rollDice");
if (skipTurn[currentPlayer]) {
    console.log(`ç©å®¶ ${currentPlayer + 1} åœä¸€å›åˆ`);
	alert(`ğŸ›‘ ç©å®¶ ${currentPlayer + 1} åœä¸€å›åˆ`);
	const log = document.getElementById("log");
	log.innerText += `\nğŸ¯ç©å®¶ ${currentPlayer + 1} åœä¸€å›åˆ`;
    skipTurn[currentPlayer] = false;
    currentPlayer = (currentPlayer + 1) % nPlayers;
	document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    updateStatus();
    return;
  }
updateStatus();            // â† è®“æ­£åœ¨æ“²éª°çš„ç©å®¶ç«‹åˆ»é«˜äº®
  const selected = document.querySelector('input[name="diceOverride"]:checked');
  let dice = selected && selected.value !== "0" ? parseInt(selected.value) : Math.floor(Math.random() * 6) + 1;

  playDiceAnimation(dice, () => {
    finalizeRoll(dice);
  });
}

function playDiceAnimation(finalDice, callback) {
  const diceOverlay = document.createElement("div");
  diceOverlay.id = "diceOverlay";
  diceOverlay.style.position = "fixed";
  diceOverlay.style.top = "50%";
  diceOverlay.style.left = "50%";
  diceOverlay.style.transform = "translate(-50%, -50%)";
  diceOverlay.style.zIndex = "1000";
  diceOverlay.style.backgroundColor = "rgba(255,255,255,0.8)";
  diceOverlay.style.padding = "20px";
  diceOverlay.style.borderRadius = "10px";

  const diceImage = document.createElement("img");
  diceImage.id = "diceImage";
  diceImage.style.width = "100px";
  diceImage.style.height = "100px";
  diceOverlay.appendChild(diceImage);
  document.body.appendChild(diceOverlay);

  const diceSound = document.getElementById("diceSound");
  if (diceSound) {
    diceSound.currentTime = 0;
    diceSound.play();
  }

  let rollCount = 12, currentRoll = 0;
  const interval = setInterval(() => {
    let tempFace = Math.floor(Math.random() * 6) + 1;
    diceImage.src = `dice${tempFace}.png`;
    currentRoll++;
    if (currentRoll >= rollCount) {
      clearInterval(interval);
      diceImage.src = `dice${finalDice}.png`;
      setTimeout(() => {
        document.body.removeChild(diceOverlay);
        if (callback) callback();
      }, 500);
    }
  }, 80);
}

function finalizeRoll(dice) {
  console.log("finalizeRoll dice:", dice);
  const log = document.getElementById("log");

  

  log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} æ“²å‡º${dice}`;
  lastDiceRoll[currentPlayer] = dice;
  document.getElementById("diceResult").textContent = dice;
  document.getElementById("people").textContent = currentPlayer + 1;

  continueMoveLogic(dice);
}

function continueMoveLogic(dice) {
  const prevStep = playerSteps[currentPlayer];
  let step = playerSteps[currentPlayer] + dice;
  const pathLen = pathIndices.length;

  if ((prevStep < pathLen) && (step >= pathLen)) {
    passedStart = true;
  }
  step = step % pathLen;

  const fromIndex = pathIndices[prevStep % pathLen];
  const toIndex = pathIndices[step];
  const cellImg = mapData[toIndex] || "";

  if (fromIndex === undefined || toIndex === undefined) {
    alert("âš ï¸ æ‰¾ä¸åˆ°å°æ‡‰çš„æ ¼å­ï¼Œå¯èƒ½æ˜¯åœ°åœ–å°šæœªæ­£ç¢ºè¨­å®šã€‚");
    return;
  }



 
  function proceed() {
    const prev = playerSteps[currentPlayer];
    if (passedStart) {
      playerScores[currentPlayer] += 1;
      alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†ï¼");
      log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†`;
      checkScoreWin();
      passedStart = false;
    }

    playerSteps[currentPlayer] = step;
    animateMove(currentPlayer, fromIndex, toIndex, () => {
      updateStatus();
      if (checkScoreWin()) return;
      logAction(currentPlayer, dice, toIndex);
	  
  
  const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");
  
  if (isQuizTileName(imgNow)) {
  if (isAskingQuiz) return; // already asking, avoid double
  isAskingQuiz = true; // set guard

  let cat = null;
  if (imgNow.includes("quiz_earthquake.png")) cat = "earthquake";
  else if (imgNow.includes("quiz_fire.png")) cat = "fire";
  else if (imgNow.includes("quiz_water.png")) cat = "water";

  const q = getRandomQuiz(cat);

  askQuiz(
    currentPlayer,
    () => { // âœ… ç­”å°ï¼š+3 åˆ†ï¼ŒçµæŸå›åˆ
      playerScores[currentPlayer] += 3;
      logEl.innerText += `
âœ… ç©å®¶${currentPlayer + 1} åœ¨ ${cat || "general"} é¡Œç›®ç­”å°ï¼ŒåŠ  3 åˆ†`;
      logEl.scrollTop = logEl.scrollHeight;
      updateStatus();
      checkScoreWin();
      isAskingQuiz = false; // release guard
      nextTurn(); // çµæŸæœ¬å›åˆ
    },
    () => { // âŒ ç­”éŒ¯ï¼šä¸åŠ åˆ†ï¼Œç›´æ¥æ›äºº
      logEl.innerText += `
âŒ ç©å®¶${currentPlayer + 1} åœ¨ ${cat || "general"} é¡Œç›®ç­”éŒ¯`;
      logEl.scrollTop = logEl.scrollHeight;
      isAskingQuiz = false; // release guard
      nextTurn();
    },
    q
  );
  return; // å‡ºé¡Œå®Œå°±æ”¶å·¥ï¼Œä¸è¦å†å¾€ä¸‹è·‘å…¶ä»–æ ¼å­æ•ˆæœ
}
  if (imgNow.includes("underdesk.png")) {
  alert("ğŸ“¢ ç™¼ç”Ÿåœ°éœ‡ï¼Œèº²åˆ°æ¡Œä¸‹ï¼Œé€€å›èµ·é»ï¼");
  logEl.innerText += `\nğŸ“¢ ç©å®¶${currentPlayer + 1} ç™¼ç”Ÿåœ°éœ‡ï¼Œèº²åˆ°æ¡Œä¸‹ï¼Œé€€å›èµ·é»`;
  playerSteps[currentPlayer] = 0;
  renderPlayers();
  updateStatus();
  nextTurn();
  return;
  }
  // ğŸ² éª°å­æ ¼ï¼šå†æ“²ä¸€æ¬¡ï¼ˆè½åœ°å¾Œåˆ¤æ–·ï¼‰
if (imgNow.includes("dice.png")) {
  alert("ğŸ² è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼");
  playerSteps[currentPlayer] = step;
  logEl.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼`;
  logEl.scrollTop = logEl.scrollHeight;
  setTimeout(() => rollDice(), 300);
  return;
}
 
  if (imgNow.includes("bag1.png")) {
  playerScores[currentPlayer] += 5;
  updateStatus();
  logEl.innerText += `\nğŸ’ ç©å®¶ ${currentPlayer + 1} æ’¿åˆ°æ€¥æ•‘åŒ…ï¼ŒåŠ  5 åˆ†`;
  logEl.scrollTop = logEl.scrollHeight;
  alert(`ğŸ´ æ­å–œï¼ç©å®¶ ${currentPlayer + 1} æ’¿åˆ°æ€¥æ•‘åŒ…ï¼ŒåŠ  5 åˆ†`);  
  checkScoreWin();

  // æ›ä¸‹ä¸€ä½
  nextTurn(); 
  return;
}
  if (imgNow.includes("card2.png")) {
  playerSkills[currentPlayer]++;
  updateStatus();
  alert(`ğŸ´ æ­å–œï¼ç©å®¶${currentPlayer+1} ç²å¾—ä¸€å¼µæŠ€èƒ½å¡ï¼Œç›®å‰æŠ€èƒ½å¡ï¼š${playerSkills[currentPlayer]} å¼µ`);
  logEl.innerText += `\nğŸ´ ç©å®¶${currentPlayer+1} ç²å¾—1å¼µæŠ€èƒ½å¡`;
  logEl.scrollTop = logEl.scrollHeight;
  nextTurn();   // çµæŸæœ¬å›åˆ
  return;       // ä¸è¦å†å¾€ä¸‹åšåœ°ç”¢/æ‹†åœ°
}


// ğŸ§¯ fire2.pngï¼šå…ˆå‡ºé¡Œï¼›ç­”éŒ¯å°±æ¸…ç©ºæ‰€æœ‰æ¶ˆé˜²å±€
// fire2ï¼šæ¶ˆé˜²å±€ï¼ˆç”¨ askfireQuestionï¼‰
if (imgNow.includes("fire2.png")) {
  handleOwnershipQuiz("fire2.png", "fire_station", "æ¶ˆé˜²å±€", toIndex, askfireQuestion, () => {
    handleProperty(toIndex, () => nextTurn());
  });
  return;
}
// rain1ï¼šæ°´åˆ©å±€ï¼ˆç”¨ askWaterBureauQuestionï¼‰
if (imgNow.includes("rain1.png")) {
  handleOwnershipQuiz("rain1.png", "water_bureau", "æ°´åˆ©å±€", toIndex, askWaterBureauQuestion, () => {
    handleProperty(toIndex, () => nextTurn());
  });
  return;
}

// earthquake3ï¼š921 åšç‰©é¤¨ï¼ˆç”¨ askMuseumQuestionï¼‰
if (imgNow.includes("earthquake3.png")) {
  handleOwnershipQuiz("earthquake3.png", "museum921", "921åšç‰©é¤¨", toIndex, askMuseumQuestion, () => {
    handleProperty(toIndex, () => nextTurn());
  });
  return;
}



  // åŸæœ¬æµç¨‹end
	  
	  
      handleProperty(toIndex, () => {
    nextTurn();
    });
    });
  }

  
  


  if (cellImg.includes("event1.png") || cellImg.includes("event2.png")) {
    const randomEvent = eventList[Math.floor(Math.random() * eventList.length)];
    playerSteps[currentPlayer] = step;
    animateMove(currentPlayer, fromIndex, toIndex, () => {
      handleEventEffect(randomEvent, step);
    });
    return;
  }








  proceed();
}

function nextTurn() {
  currentPlayer = (currentPlayer + 1) % nPlayers;
  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
  updateStatus();   
}



  function animateMove(playerIdx, fromCellIndex, toCellIndex, callback, direction = 1) {
  const token = playerTokens[playerIdx];
  if (!token) { callback && callback(); return; }

  const pathLen = pathIndices.length;

  // å–å¾—ã€Œæ­¥æ•¸ä½ç½®ã€ï¼šæŠŠ cellIndex è½‰ç‚º path ä¸Šçš„åºè™Ÿ
  let curStep = pathIndices.indexOf(fromCellIndex);
  const targetStep = pathIndices.indexOf(toCellIndex);
  if (curStep === -1 || targetStep === -1) { // å®‰å…¨é˜²å‘†
    // æ‰¾ä¸åˆ°å°±ç›´æ¥ç¬ç§»
    gameBoard.children[toCellIndex].appendChild(token);
    callback && callback();
    return;
  }

  // æ¯æ ¼åœç•™æ™‚é–“ï¼ˆå¯è‡ªè¡Œèª¿æ•´é€Ÿåº¦ï¼‰
  const STEP_DELAY = 180; // æ¯«ç§’
const stepDir = (direction === -1 ? -1 : 1); 
  // é€æ ¼å‰é€²ç›´åˆ° targetStep
  function stepOnce() {
    if (curStep === targetStep) {
      // èµ°å®Œ
      callback && callback();
      return;
    }
    // ä¾æ–¹å‘èµ°ä¸€æ ¼ï¼ˆå¯å‰é€²/å¾Œé€€ï¼Œå«ç’°ç¹ï¼‰
    curStep = (curStep + stepDir + pathLen) % pathLen;
    const nextCellIndex = pathIndices[curStep];

    // å°‡æ£‹å­æ”¾åˆ°ä¸‹ä¸€æ ¼ï¼ˆä¸è¤‡è£½ã€ä¸é¡¯ç¤ºåˆ†èº« â†’ ä¸æœƒæ®˜å½±ï¼‰
    gameBoard.children[nextCellIndex].appendChild(token);

    // ç¹¼çºŒä¸‹ä¸€æ ¼
    setTimeout(stepOnce, STEP_DELAY);
  }

  // å¾ç•¶å‰æ ¼é–‹å§‹èµ°
  setTimeout(stepOnce, STEP_DELAY);
}
function checkScoreWin() {
  if (mode === "score") {
    for (let i = 0; i < nPlayers; i++) {
      if (playerScores[i] >= scoreTarget) {
        gameEnded = true;
		winnerIndex = i; // â† æ¨™è¨˜è´å®¶ï¼Œè®“è¨˜åˆ†æ¿åŠ ä¸Š .winner
		updateStatus();// â† æ¨™è¨˜è´å®¶ï¼Œè®“è¨˜åˆ†æ¿åŠ ä¸Š .winner
        alert(`ğŸ‰ ç©å®¶ ${i + 1} é”åˆ° ${scoreTarget} åˆ†ï¼Œç²å‹ï¼`);
		showGameOverScreen(`ğŸ‰ ç©å®¶ ${i + 1} é”åˆ° ${scoreTarget} åˆ†ï¼Œç²å‹ï¼`);
        clearInterval(timer);
        return true;
      }
    }
  }
  return false;
}


function updateStatus() {
  // å½©è‰²å¡ç‰‡å¼è¨˜åˆ†æ¿ï¼šé¡¯ç¤ºåˆ†æ•¸èˆ‡æŠ€èƒ½å¡æ•¸
  const carImgs = ["car_red.png","car_blue.png","car_green.png","car_yellow.png"];
  const status = document.getElementById("status");
  const rawGoal = (document.getElementById('scoreTarget')?.value ?? (typeof config !== 'undefined' ? config.scoreTarget : 20));
let goalScore = (() => {
  const n = parseInt(String(rawGoal).replace(/[^\d.-]/g, ''), 10);
  return Number.isFinite(n) && n > 0 ? n : 20;
})();
if (typeof config !== 'undefined' && config.mode === 'time') {
  goalScore = 50;   // OKï¼šå› ç‚ºä¸Šé¢ç”¨ let
}
  



  if (!status) return;

  let cards = "";
  for (let i = 0; i < nPlayers; i++) {
    const isActive = (i === currentPlayer);
    
	const isWinner = (winnerIndex === i);
	const cls = `score-card p${i+1}${isActive ? " active" : ""}${isWinner ? " winner" : ""}`;
    const car = carImgs[i] || "car_red.png";
    const score = (Array.isArray(playerScores) && typeof playerScores[i] !== "undefined") ? playerScores[i] : 0;
    const skills = (Array.isArray(playerSkills) && typeof playerSkills[i] !== "undefined") ? playerSkills[i] : 0;
const pausedBadge = (Array.isArray(skipTurn) && skipTurn[i]) ? `<span class="badge pause">æš«åœ</span>` : ``;
const skillIcons = Array.from({ length: skills },
  () => `<span class="scard"><img src="card2.png" alt="å¡"></span>`
).join("");

const pct = goalScore ? (playerScores[i] / goalScore) * 100 : 0;
const isFull = playerScores[i] >= goalScore;
const pctStr = isFull ? '100%' : `${Math.max(0, Math.min(100, pct)).toFixed(2)}%`;


    cards += `
      <div class="${cls}">
        <div class="left">
          <div class="player-avatar">
            <img class="token" src="${car}" alt="P${i+1}">
            <div class="name">ç©å®¶${i+1}</div>
          </div>
        </div>
        <div class="right">
          <div class="score">${score}åˆ†</div>
		  <div   class="goal"   title="ç›®æ¨™ ${goalScore} åˆ†"   role="progressbar"   aria-valuemin="0"   aria-valuemax="${goalScore}"   aria-valuenow="${score}" >
			<div class="bar${isFull ? ' full' : ''}" style="width:${pctStr}"></div>
		</div>
          <div class="badges">            
            <div class="skill-cards" aria-label="æŠ€èƒ½å¡ ${skills} å¼µ">${skillIcons}</div>${pausedBadge}
          </div>  
        </div>
      </div>`;
  }
  status.innerHTML = `<div class="score-grid">${cards}</div>`;
}


function showGameOverScreen(winnerText) {
  const over = document.getElementById('game-over');
  document.getElementById('winner-text').textContent = winnerText;
  over.classList.add('show');
}

function restartGame() {
  location.reload();  // ç›´æ¥é‡æ•´é é¢
}


function log(msg) {
  logEl.innerText += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function logAction(player, dice, pos) {
      const log = document.getElementById("log");
      const stepNum = pathIndices.indexOf(pos) + 1;
      const imgSrc = mapData[pos] || "";
      const imgName = imgSrc.split('/').pop();
      //log.innerText += `ç©å®¶${player + 1} æ“²å‡º ${dice}ï¼Œç§»å‹•åˆ°ç¬¬ ${stepNum} æ ¼ï¼ˆ${imgName}ï¼‰`;
	  log.innerText += ` ç§»å‹•åˆ°ç¬¬ ${stepNum} æ ¼ï¼ˆ${imgName}ï¼‰`;
      log.scrollTop = log.scrollHeight;
	  //alert("ğŸ“¢ğŸ“¢ğŸ“¢ ï¼");
    }

function didCompleteLap(prevStep, newStep, pathLength) {
  return prevStep > newStep; // ä»£è¡¨ç¹éé ­å›åˆ°èµ·é»
}


  

function showEventCard(event, callback) {
  const card = document.getElementById("event-card-display");
  let skillBtnHtml = "";
  if (playerSkills[currentPlayer] > 0) {
    skillBtnHtml = `<button id="event-skill-btn">ä½¿ç”¨ç‰¹æ®ŠæŠ€èƒ½</button>`;
  }
  card.innerHTML = `
    <h3>ğŸ´ ç©å®¶${currentPlayer + 1}æŠ½åˆ°äº‹ä»¶å¡</h3>
    <p>${event.desc}</p>
    <strong>â¡ ${event.effect}</strong>
    <button id="event-ok-btn">ç¢ºèª</button>
    ${skillBtnHtml}
  `;
  card.classList.add("show");

  // åŸæœ¬ç¢ºèª
  card.querySelector("#event-ok-btn").onclick = () => {
    hideEventCard();
    if (callback) callback();
  };
  // æœ‰æŠ€èƒ½æ‰æœ‰æŒ‰éˆ•
  if (playerSkills[currentPlayer] > 0) {
    card.querySelector("#event-skill-btn").onclick = () => {
      alert("ğŸ® ä½ ä½¿ç”¨äº†ç‰¹æ®ŠæŠ€èƒ½ï¼Œæœ¬æ¬¡äº‹ä»¶ç„¡æ•ˆï¼");
	  if (passedStart) {
        playerScores[currentPlayer] += 1;
		
        //alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†(é€™é‚Šæ˜¯å¥—åœˆå¾Œ  èµ°åˆ°eventçš„åŠ åˆ† ç„¶å¾Œç”¨æŠ€èƒ½å¡çš„)ï¼");
		  alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†ï¼");
		
        log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†`;
        passedStart = false;
        updateStatus();
		    checkScoreWin();
      }
      playerSkills[currentPlayer]--;
      updateStatus();
      hideEventCard();
      // è·³éäº‹ä»¶ã€æ›äºº
	  
	    logEl.innerText += ` è§¸ç™¼äº‹ä»¶ï¼šã€Œ${event.desc} ${event.effect}ã€ï¼Œä½¿ç”¨æŠ€èƒ½å¡  äº‹ä»¶ç„¡æ•ˆ`;
      logEl.scrollTop = logEl.scrollHeight;
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
	
      
      updateStatus();
    };
  }
}

function hideEventCard() {
  document.getElementById("event-card-display").classList.remove("show");
}

function getPropertyIndexesByKey(propKey, ownerFilter /* (ownerId)=>bool */ = null) {
  const arr = [];
  for (let i = 0; i < mapData.length; i++) {
    const key = propertyKeys[i] || getPropertyKey(mapData[i] || "");
    if (key === propKey) {
      const owner = (propertyOwners[i] ?? 0);
      if (!ownerFilter || ownerFilter(owner)) arr.push(i);
    }
  }
  return arr;
}

// æ¸…ç©ºæŒ‡å®š ownerId æ“æœ‰çš„ã€ŒæŸä¸€ç¨®åœ°ç”¢ã€(propKey) â†’ è®Šå› *_0.png
function clearPropertiesByOwner(propKey, ownerId) {
  if (ownerId == null) return;
  const targets = getPropertyIndexesByKey(propKey, o => (o === ownerId));
  targets.forEach(i => {
    propertyOwners[i] = 0;
    setTileImage(i, imageForOwner(propKey, 0)); // e.g. water_bureau_0.png
  });
  updateStatus();
}

// å…±ç”¨ï¼šåœ¨æŒ‡å®šè§¸ç™¼åœ–(tileName) è¢«è¸©åˆ°æ™‚ï¼Œé€²è¡Œå›ºå®šå•ç­” & ä¾è¦å‰‡æ¸…ç©º
// è¦å‰‡ï¼š
//   è‹¥è‡ªå·±æ“æœ‰è©²é¡åœ°ï¼š  ç­”éŒ¯ â†’ æ¸…è‡ªå·±ï¼›ç­”å° â†’ ä¿ç•™
//   è‹¥åˆ¥äººæ“æœ‰è©²é¡åœ°ï¼šç­”å° â†’ æ¸…åˆ¥äººï¼›ç­”éŒ¯ â†’ ä¿ç•™
// ç„¡äººæ“æœ‰å‰‡åªæç¤ºã€‚
function handleOwnershipQuiz(tileName, propKey, propDisplayName, toIndex, askFunc, afterResolve) {
  const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");
  if (!imgNow.includes(tileName)) { afterResolve && afterResolve(); return; }

  // ç”¨å‚³é€²ä¾†çš„é¡Œç›®å‡½å¼ï¼Œä¸è¦å¯«æ­»
  askFunc(correct => {
    const me = currentPlayer + 1;
    const mine   = getPropertyIndexesByKey(propKey, o => (o === me));
    const others = getPropertyIndexesByKey(propKey, o => (o > 0 && o !== me));

    if (mine.length > 0) {
      // è‡ªå·±æœ‰
      if (correct) {
        alert(`ä½ ç­”å°äº†ï¼Œä¿ç•™${propDisplayName}`);
      } else {
        clearPropertiesByOwner(propKey, me);
        alert(`ä½ ç­”éŒ¯äº†ï¼Œ${propDisplayName}æ¸…ç©º`);
        logEl.innerText += `\nğŸš¨ ä½ ç­”éŒ¯äº†ï¼Œä½ çš„${propDisplayName}å·²è¢«æ¸…ç©º`;
        logEl.scrollTop = logEl.scrollHeight;
      }
    } else if (others.length > 0) {
      // åˆ¥äººæœ‰ï¼ˆå¯èƒ½å¤šäººï¼‰
      if (correct) {
        const ownerSet = new Set(others.map(i => propertyOwners[i]));
        ownerSet.forEach(oid => clearPropertiesByOwner(propKey, oid));
        alert(`ä½ ç­”å°äº†ï¼Œæ¸…ç©º${propDisplayName}`);
        logEl.innerText += `\nğŸš¨ ä½ ç­”å°äº†ï¼Œå…¶ä»–ç©å®¶çš„${propDisplayName}å·²è¢«æ¸…ç©º`;
        logEl.scrollTop = logEl.scrollHeight;
      } else {
        alert(`ä½ ç­”éŒ¯äº†ï¼Œä¿ç•™${propDisplayName}`);
      }
    } else {
      // ç„¡äººæ“æœ‰
      alert(correct ? `ä½ ç­”å°äº†ï¼Œä½†ç›®å‰æ²’æœ‰ç©å®¶æ“æœ‰${propDisplayName}`
                    : `ä½ ç­”éŒ¯äº†ï¼Œä½†ç›®å‰æ²’æœ‰ç©å®¶æ“æœ‰${propDisplayName}`);
    }

    afterResolve && afterResolve();
  });
}

function askWaterBureauQuestion(callback) {
  const q = "æ°´çš„åŒ–å­¸å¼æ˜¯ä»€éº¼ï¼Ÿ";
  const options = ["H2O2", "H2O", "CO2"];
  const correctIndex = 1; // H2O
  let optStr = options.map((opt, idx) => `${idx + 1}. ${opt}`).join("\n");
  let ans = prompt(`${q}\n${optStr}`);
  callback && callback((parseInt(ans) - 1) === correctIndex);
}

// 921 åšç‰©é¤¨é¡Œç›®
function askMuseumQuestion(callback) {
  const q = "å°ç£921å¤§åœ°éœ‡ç™¼ç”Ÿæ–¼å“ªä¸€å¹´ï¼Ÿ";
  const options = ["1998", "1999", "2000"];
  const correctIndex = 1; // 1999
  let optStr = options.map((opt, idx) => `${idx + 1}. ${opt}`).join("\n");
  let ans = prompt(`${q}\n${optStr}`);
  callback && callback((parseInt(ans) - 1) === correctIndex);
}



function askfireQuestion(onDone) {
  // onDone(true/false)
  const modal = document.createElement("div");
  Object.assign(modal.style, {
    position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
    display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
  });
  const box = document.createElement("div");
  Object.assign(box.style, {
    background: "#fff", padding: "20px", borderRadius: "10px",
    width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
  });
  const h3 = document.createElement("h3");
  h3.textContent = "ä»Šå¤©æ˜ŸæœŸå¹¾ï¼Ÿ";
  const opts = [
    { key: "1", text: "é¸é …1 æ˜ŸæœŸ1" },
    { key: "2", text: "é¸é …2 æ˜ŸæœŸ2" },
    { key: "3", text: "é¸é …3 æ˜ŸæœŸ3" } // âœ… æ­£è§£
  ];
  box.appendChild(h3);
  opts.forEach(o => {
    const btn = document.createElement("button");
    btn.textContent = o.text;
    Object.assign(btn.style, { display:"block", margin:"8px auto", padding:"8px 16px", cursor:"pointer" });
    btn.onclick = () => {
      const correct = (o.key === "3");
      document.body.removeChild(modal);
      onDone && onDone(correct);
    };
    box.appendChild(btn);
  });
  modal.appendChild(box);
  document.body.appendChild(modal);
}
// å›å‚³æ‰€æœ‰æ¶ˆé˜²å±€æ ¼çš„ indexï¼ˆå¯é¸æ“æœ‰è€…éæ¿¾ï¼‰
function getFireStationIndexes(ownerFilter /*(ownerId)=>bool*/ = null) {
  const arr = [];
  for (let i = 0; i < mapData.length; i++) {
    const key = propertyKeys[i] || getPropertyKey(mapData[i] || "");
    if (key === 'fire_station') {
      if (!ownerFilter || ownerFilter(propertyOwners[i] ?? 0)) {
        arr.push(i);
      }
    }
  }
  return arr;
}

// æ¸…ç©ºæŒ‡å®š owner çš„æ¶ˆé˜²å±€ï¼ˆownerId: 1..4ï¼›è‹¥å‚³ null ä»£è¡¨ä¸æ¸…ç©ºä»»ä½•ï¼‰
// æœƒæŠŠè©² owner æ“æœ‰çš„æ‰€æœ‰æ¶ˆé˜²å±€è®Šå› fire_station_0.png
function clearFireStationsByOwner(ownerId) {
  if (ownerId == null) return;
  const targets = getFireStationIndexes(o => (o === ownerId));
  targets.forEach(i => {
    propertyOwners[i] = 0;
    setTileImage(i, imageForOwner('fire_station', 0)); // fire_station_0.png
  });
  updateStatus();
}

function getCellImageSrc(index) {
  const cell = gameBoard.children[index];
  const imgEl = cell ? cell.querySelector('img') : null;
  return imgEl ? imgEl.src : (mapData[index] || "");
}
// === å…¨åŸŸï¼šåœ°ç”¢è™•ç†ï¼ˆè³¼è²·ï¼éè·¯è²»ï¼‰===
function handleProperty(index, afterDone) {
  const imgSrc = getCellImageSrc(index);            // ç”¨ DOM è®€åœ–
  const pKey   = propertyKeys[index] || getPropertyKey(imgSrc);
  if (!pKey) {
    console.log('[PROP] not a property:', { index, imgSrc });
    afterDone && afterDone();
    return;
  }

  propertyKeys[index] = pKey;

  // owner æ­£è¦åŒ–ï¼šç„¡äºº â†’ 0
  if (propertyOwners[index] == null) {
    const parsed = getOwnerFromImg(imgSrc);         // 0..4 æˆ– null
    propertyOwners[index] = (parsed == null ? 0 : parsed);
  }

  const owner = propertyOwners[index];              // 0 | 1..4
  const me    = currentPlayer + 1;
  const def   = PROPERTY_DEFS[pKey];
  const price = def.price;
  const name  = def.display;

  console.log('[PROP] enter', { index, pKey, name, imgSrc, owner, me, price, myScore: playerScores[currentPlayer] });

  // ç„¡äººæŒæœ‰ â†’ è©¢å•æ˜¯å¦è³¼è²·
  if (owner === 0) {
    if (playerScores[currentPlayer] >= price) {
      console.log('[PROP] ask to buy', { name, price, me });
      const yes = window.confirm(`${name} åƒ¹æ ¼ ${price} åˆ†ã€‚ç©å®¶ ${me} è¦è³¼è²·å—ï¼Ÿ`);
      if (yes) {
        playerScores[currentPlayer] -= price;
        propertyOwners[index] = me;
        setTileImage(index, imageForOwner(pKey, me)); // åŒæ­¥ mapData + DOM
        updateStatus(); // å…ˆåˆ·æ–°è¨ˆåˆ†æ¿

        setTimeout(() => {
          logEl.innerText += ` ä»¥ ${price} åˆ†è³¼è²·äº†ã€Œ${name}ã€`;
          logEl.scrollTop = logEl.scrollHeight;
          afterDone && afterDone();
        }, 0);
        return;
      }
    } else {
      alert(`ç©å®¶${me} åˆ†æ•¸ä¸è¶³ ç„¡æ³•è³¼è²·ã€Œ${name}ã€ï¼ˆéœ€ ${price} åˆ†ï¼‰`);
	  logEl.innerText += `åˆ†æ•¸ä¸è¶³ ç„¡æ³•è³¼è²·ã€Œ${name}ã€ï¼ˆéœ€ ${price} åˆ†ï¼‰`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    afterDone && afterDone();
    return;
  }

  // === å·²æœ‰äººæŒæœ‰ â†’ ä»˜éè·¯è²»æˆ–è‡ªå·±çš„åœ° ===
  if (owner !== me) {
    if (playerScores[currentPlayer] >= price) {
      // å¤ éŒ¢ï¼Œæ­£å¸¸ä»˜è²»
      playerScores[currentPlayer] -= price;
      playerScores[owner - 1]     += price;
      updateStatus(); // å…ˆåˆ·æ–°è¨ˆåˆ†æ¿
	  
      setTimeout(() => {
        alert(`ç©å®¶${me} åœ¨ã€Œ${name}ã€æ”¯ä»˜ ${price} åˆ†éè·¯è²»çµ¦ç©å®¶${owner}`);
        logEl.innerText += `\nğŸ’° ç©å®¶${me} åœ¨ã€Œ${name}ã€æ”¯ä»˜ ${price} åˆ†éè·¯è²»çµ¦ç©å®¶${owner}`;
        logEl.scrollTop = logEl.scrollHeight;
		checkScoreWin();
        afterDone && afterDone();
      }, 0);
      return;
    } else {
      // ä¸å¤ ï¼šæŠŠå…¨éƒ¨çµ¦å°æ–¹ï¼ˆå¯ä¾è¦å‰‡æ”¹ï¼‰
      const all = playerScores[currentPlayer];
      playerScores[owner - 1] += all;
      playerScores[currentPlayer] = 0;
      updateStatus();
	
      setTimeout(() => {
        alert(`ç©å®¶${me} åˆ†æ•¸ä¸è¶³ï¼Œå·²æŠŠå…¨éƒ¨ ${all} åˆ†çµ¦ç©å®¶${owner}ï¼ˆè‡ªå·±è®Š 0 åˆ†ï¼‰`);
        logEl.innerText += `\nâš ï¸ ç©å®¶${me} åˆ†æ•¸ä¸è¶³ï¼Œå·²æŠŠå…¨éƒ¨ ${all} åˆ†çµ¦ç©å®¶${owner}ï¼ˆè‡ªå·±è®Š 0 åˆ†ï¼‰`;
        logEl.scrollTop = logEl.scrollHeight;
		checkScoreWin();
        afterDone && afterDone();
      }, 0);
      return;
    }
  }

  // è‡ªå·±çš„åœ° â†’ æ²’äº‹
  afterDone && afterDone();
}



function handleEventEffect(event, fromStep) {
console.log("handleEventEffect");
  showEventCard(event, () => {
    const moveEffects = ["å‰é€²1æ ¼", "å‰é€²2æ ¼", "é€€å›1æ ¼", "é€€å›2æ ¼", "å›åˆ°èµ·é»"];
    const log = document.getElementById("log");
    const lastRoll = lastDiceRoll[currentPlayer];
    log.innerText += `  è§¸ç™¼äº‹ä»¶ï¼šã€Œ${event.desc} ${event.effect}ã€`;
    log.scrollTop = log.scrollHeight;
	

    let newStep = playerSteps[currentPlayer];

    if (event.effect === "å‰é€²1æ ¼") {
      newStep = (newStep + 1) % pathIndices.length;
    } else if (event.effect === "å‰é€²2æ ¼") {
      newStep = (newStep + 2) % pathIndices.length;
    } else if (event.effect === "é€€å›1æ ¼") {
      newStep = (newStep - 1 + pathIndices.length) % pathIndices.length;
    } else if (event.effect === "é€€å›2æ ¼") {
      newStep = (newStep - 2 + pathIndices.length) % pathIndices.length;
    } else if (event.effect === "å›åˆ°èµ·é»") {
      newStep = 0;
    }
	//logAction(currentPlayer, dice, newStep);
    if (event.effect === "å¾—2åˆ†") {
      playerScores[currentPlayer] += 2;
      updateStatus();
	  checkScoreWin();
	  
    } else if (event.effect === "å¾—1åˆ†") {
      playerScores[currentPlayer] += 1;
      updateStatus();
	   checkScoreWin();
    } else if (event.effect === "åœä¸€å›åˆ") {
      skipTurn[currentPlayer] = true;
	  // ç›´æ¥æ›ä¸‹ä¸€ä½ç©å®¶
	  currentPlayer = (currentPlayer + 1) % nPlayers;
	  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
	  updateStatus();
	  return; // é˜²æ­¢ç¹¼çºŒåŸ·è¡Œå¾ŒçºŒç¨‹å¼
    }
// äº‹ä»¶ï¼šå›åˆ°èµ·é» â†’ ç›´æ¥ç¬ç§»ï¼ˆä¸æ’­æ”¾å‹•ç•«ï¼‰
    if (event.effect === "å›åˆ°èµ·é»") {
      playerSteps[currentPlayer] = 0;
      renderPlayers();
      updateStatus();
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      return;
    }
	
    const fromIndex = pathIndices[fromStep];
    const toIndex = pathIndices[newStep];
	 // æ±ºå®šå‹•ç•«æ–¹å‘ï¼šé€€å› â†’ å¾Œé€€ï¼›å…¶ä»– â†’ å‰é€²
    let animDir = (event.effect === "é€€å›1æ ¼" || event.effect === "é€€å›2æ ¼") ? -1 : 1;

	
	 const imgNow = getCellImageSrc(toIndex);
    playerSteps[currentPlayer] = newStep;

    animateMove(currentPlayer, fromIndex, toIndex, () => {
	console.log("handleEventEffect_animateMove");
      updateStatus();
      const img = mapData[toIndex] || "";

      if (passedStart) {
        playerScores[currentPlayer] += 1;
		
        //alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†(é€™é‚Šæ˜¯å¥—åœˆå¾Œ  èµ°åˆ°eventçš„åŠ åˆ†  ä½†å¦‚æœæ˜¯eventé€£é–å‰é€²æ˜¯ä¸åŠ åˆ†çš„)ï¼");
		
        log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†`;
        passedStart = false;
        updateStatus();
		alert("âš å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†");
		checkScoreWin();
      }
// === äº‹ä»¶å¾Œçš„ç›®çš„åœ°ç‰¹æ€§åˆ¤æ–· ===
      // 1) éª°å­æ ¼ï¼šå†æ“²ä¸€æ¬¡ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
      if (img.includes("dice.png")) {
        alert("ğŸ² æ­å–œï¼ä½ è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼");
        log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼ï¼ˆäº‹ä»¶å¾Œï¼‰`;
        setTimeout(() => {
          rollDice();
        }, 300);
        return;
      }
//add
// 2) æŠ€èƒ½å¡ï¼šæ‹¿å¡ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
if (img.includes("card2.png")) {
  playerSkills[currentPlayer]++;
  updateStatus();
  // proceed();
  alert(`ğŸ´ æ­å–œï¼ç©å®¶${currentPlayer+1} ç²å¾—ä¸€å¼µæŠ€èƒ½å¡ï¼Œç›®å‰æŠ€èƒ½å¡ï¼š${playerSkills[currentPlayer]} å¼µ`);
  logEl.innerText += ` ç²å¾—1å¼µæŠ€èƒ½å¡`;
  logEl.scrollTop = logEl.scrollHeight;
  currentPlayer = (currentPlayer + 1) % nPlayers;
  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
  return;
}

if (img.includes("bag1.png")) {
  playerScores[currentPlayer] += 5;
  updateStatus();
  // proceed();
  alert(`ğŸ´ æ­å–œï¼ç©å®¶${currentPlayer+1} åŠ 5åˆ†`);
  logEl.innerText += ` åŠ 5åˆ†`;
  logEl.scrollTop = logEl.scrollHeight;
  checkScoreWin();
  currentPlayer = (currentPlayer + 1) % nPlayers;
  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
  return;
}

// 3) underdeskï¼šé€€å›èµ·é»ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
      if (img.includes("underdesk.png")) {
        alert("ğŸ“¢ ç™¼ç”Ÿåœ°éœ‡ï¼Œèº²åˆ°æ¡Œä¸‹ï¼Œé€€å›èµ·é»");        
		log.innerText += ` ç™¼ç”Ÿåœ°éœ‡ï¼Œèº²åˆ°æ¡Œä¸‹ï¼Œç©å®¶${currentPlayer + 1}ï¼Œé€€å›èµ·é»`;
        playerSteps[currentPlayer] = 0;
		renderPlayers();                  // ç«‹å³é‡ç¹ªæ£‹å­ä½ç½®
		updateStatus();
        currentPlayer = (currentPlayer + 1) % nPlayers;
		document.getElementById("currentPlayer").textContent = currentPlayer + 1;
		return;
      }
//console.log(img, "quizåˆ¤æ–·");
// 4) quizï¼šå•ç­”ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
      
if (isQuizTileName(img)) {
  if (isAskingQuiz) return; // already asking, avoid double
  isAskingQuiz = true; // set guard

  let cat = null;
  if (img.includes("quiz_earthquake.png")) cat = "earthquake";
  else if (img.includes("quiz_fire.png")) cat = "fire";
  else if (img.includes("quiz_water.png")) cat = "water";

  const q = getRandomQuiz(cat);
  askQuiz(
    currentPlayer,
    () => { // ç­”å°
      playerScores[currentPlayer] += 3;
      logEl.innerText += `  ç­”å°é¡Œç›®ï¼šã€Œ${q.question}ã€ åŠ  3 åˆ†`;
      logEl.scrollTop = logEl.scrollHeight;
      updateStatus(); // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
      checkScoreWin();
      isAskingQuiz = false; // release guard
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    },
    () => { // ç­”éŒ¯
      isAskingQuiz = false; // release guard
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    },
    q // æŒ‡å®šé¡Œç›®
  );
  return;
}
// 5) æ‹†åœ°ï¼šå•ç­”ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
// fire2ï¼šæ¶ˆé˜²å±€ï¼ˆç”¨ askfireQuestionï¼‰
if (imgNow.includes("fire2.png")) {
  handleOwnershipQuiz("fire2.png", "fire_station", "æ¶ˆé˜²å±€", toIndex, askfireQuestion, () => {
    const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
    if (pKeyAfterEvent) {
      handleProperty(toIndex, () => {
        currentPlayer = (currentPlayer + 1) % nPlayers;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        updateStatus();
      });
    } else {
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      updateStatus();
    }
  });
  return;
}

// rain1ï¼šæ°´åˆ©å±€ï¼ˆç”¨ askWaterBureauQuestionï¼‰
if (imgNow.includes("rain1.png")) {
  handleOwnershipQuiz("rain1.png", "water_bureau", "æ°´åˆ©å±€", toIndex, askWaterBureauQuestion, () => {
    const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
    if (pKeyAfterEvent) {
      handleProperty(toIndex, () => {
        currentPlayer = (currentPlayer + 1) % nPlayers;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        updateStatus();
      });
    } else {
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      updateStatus();
    }
  });
  return;
}

// earthquake3ï¼š921 åšç‰©é¤¨ï¼ˆç”¨ askMuseumQuestionï¼‰
if (imgNow.includes("earthquake3.png")) {
  handleOwnershipQuiz("earthquake3.png", "museum921", "921åšç‰©é¤¨", toIndex, askMuseumQuestion, () => {
    const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
    if (pKeyAfterEvent) {
      handleProperty(toIndex, () => {
        currentPlayer = (currentPlayer + 1) % nPlayers;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        updateStatus();
      });
    } else {
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      updateStatus();
    }
  });
  return;
}





// 5) è‹¥ landing æ˜¯äº‹ä»¶æ ¼ï¼Œä¸”æœ¬æ¬¡äº‹ä»¶æ˜¯ã€Œä½ç§»å‹äº‹ä»¶ã€ï¼Œåšäº‹ä»¶é€£é–ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
      if ((img.includes("event1.png") || img.includes("event2.png")) && moveEffects.includes(event.effect)) {
	  alert("é€£é–äº‹ä»¶å¡");
        const nextEvent = eventList[Math.floor(Math.random() * eventList.length)];
        setTimeout(() => {
          handleEventEffect(nextEvent, newStep);
        }, 200);
        return;
      } 
      // 6) ä»¥ä¸Šçš†é â†’ åœ¨é€™è£¡æª¢æŸ¥åœ°ç”¢ï¼ˆè²·åœ°ï¼æ”¶è²»ï¼‰ï¼Œè™•ç†å®Œæ‰æ›äºº
			 const imgSrcNow = getCellImageSrc(toIndex);
      console.log('LAND after event:', toIndex, imgSrcNow, 'cachedKey=', propertyKeys[toIndex]);

      const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(imgSrcNow);
      if (pKeyAfterEvent) {
        handleProperty(toIndex, () => {
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
          updateStatus();
        });
      } else {
        currentPlayer = (currentPlayer + 1) % nPlayers;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        updateStatus();
      }
    } ,animDir);
  });
}
document.addEventListener('keydown', function(e) {
    if ((e.code === "Space" || e.key === " ") && !gameEnded) {
      e.preventDefault();
      rollDice();
    }
  });
  
  
</script>
</body>
</html>
