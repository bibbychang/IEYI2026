<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>å¤§å¯Œç¿éŠæˆ²</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 1rem; display: flex; }
	#left-panel { flex: 1; }
    #right-panel { width: 750px; margin-left: 10px; }
    #game-board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 2px;
    }
    .cell {
      width: 60px; height: 60px; border: 1px solid #aaa;
      position: relative; background: white;
    }
    .cell img {
      width: 100%; height: 100%; object-fit: contain;
      position: absolute; top: 0; left: 0;
    }
    .order-number {
      position: absolute; bottom: 2px; right: 4px;
      font-size: 10px; background: rgba(255,255,255,0.7);
      padding: 1px 3px; border-radius: 4px;
    }
    .player {
      width: 40px; height: 40px; position: absolute;
      z-index: 5;
    }
    .player1 { top: 4px; left: 4px; }
    .player2 { top: 4px; right: 4px; }
    .player img { width: 100%; height: 100%; }
    #log {     
	  
	  white-space: pre-line; font-size: 14px;
      background: #f5f5f5; border: 1px solid #ccc; padding: 6px;
      max-height: 600px; overflow-y: auto;  
	  
    }
	 #configInfo {
      background: #e8f4ff;
      padding: 10px;
      border: 1px solid #89b;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 14px;
	  width:200px;
    }
	#event-card-display {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 280px; height: 380px;
      background: white;
      border: 2px solid #444;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 9999;
      padding: 20px;
      animation: fadeIn 0.4s ease;
    }
    #event-card-display.show {
      display: flex;
    }
	
	.game-map-wrapper {
  position: relative;
  width: 100%; height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}




.game-map-tooltip {
  visibility: hidden;
  opacity: 0;
  width: max-content;
  max-width: 140px;
  background: #333;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 2px 2px;
  z-index: 10;
  bottom: 100%; left: 50%;
  
  font-size: 12px;
  pointer-events: none;
  white-space: pre-line;
  transition: opacity 0.3s;
}
.game-map-wrapper:hover .game-map-tooltip {
  visibility: visible;
  opacity: 1;
}
	
  </style>
</head>
<body>
<div id="left-panel">
  <h2>ğŸ² éŠæˆ²é–‹å§‹ï¼</h2><div id="configInfo"></div>
   <div id="status" style="margin: 10px 0;"></div>
  <div>
    <button onclick="rollDice()">æ“²éª° ğŸ² ç©å®¶ <span id="currentPlayer">1</span></button>
	
    å‰›å‰›ç©å®¶<span id="people">-</span> æ“²å‡º <span id="diceResult">-</span>
	
  </div>
  <fieldset style="margin-top: 10px; border: 1px solid #ccc; padding: 10px;">
  
  <legend>ğŸ¯ æŒ‡å®šéª°å­é»æ•¸ï¼ˆä½œå¼Šç”¨ï¼‰</legend>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="0" checked> ä¸æŒ‡å®š</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="1"> 1</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="2"> 2</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="3"> 3</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="4"> 4</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="5"> 5</label>
  <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="6"> 6</label>
</fieldset>
  <div id="game-board"></div>
  
  
</div>
<div id="right-panel">
    <h2>ç´€éŒ„</h2>
  <div id="log"></div>
  <div id="event-card-display"></div>
  </div>
  
<script>





const config = JSON.parse(localStorage.getItem("gameConfig") || '{}');
const { mode, timeLimit, scoreTarget, mapData, pathIndices } = config;
document.getElementById("configInfo").innerText =
  mode === "time"
    ? `ğŸ¯ æ¨¡å¼ï¼šé™æ™‚åˆ¶ï¼ˆ${timeLimit} ç§’ï¼‰`
    : `ğŸ¯ æ¨¡å¼ï¼šç©åˆ†åˆ¶ï¼ˆ${scoreTarget} åˆ†ï¼‰`;
const gameBoard = document.getElementById("game-board");
const logEl = document.getElementById("log");
let playerSteps = [0, 0];
let playerScores = [0, 0];
let playerSkills = [1, 1]; 
let currentPlayer = 0;
let playerTokens = [null, null];
let gameEnded = false;
let timer = null;
let timeLeft = timeLimit;


let lastDiceRoll = [0, 0];  // ç”¨ä¾†è¨˜éŒ„æ¯ä½ç©å®¶ä¸Šä¸€æ¬¡æ“²å‡ºçš„é»æ•¸
let quizQuestions = [];
let passedStart = false;
fetch("quiz.json")
  .then(res => res.json())
  .then(data => quizQuestions = data);
  const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
  
let skipTurn = [false, false];
const eventList = [
  { desc: "E01ï¼šåœ°éœ‡ç™¼ç”Ÿæ™‚ï¼Œä½ ç«‹åˆ»èº²åˆ°å …å›ºæ¡Œå­ä¸‹ã€‚å¹¸é‹é€ƒéä¸€åŠ«ï¼", effect: "å‰é€²1æ ¼" },
  { desc: "E02ï¼šåœ°éœ‡æ™‚ä½ è·‘å‘æ¨“æ¢¯é€ƒç”Ÿï¼Œè¢«è­¦è¡›åˆ¶æ­¢ã€‚åœä¸€å›åˆåæ€ã€‚", effect: "åœä¸€å›åˆ" },
  { desc: "E03ï¼šä½ å¿˜äº†å›ºå®šæ›¸æ«ƒï¼Œåœ°éœ‡æ™‚æ±è¥¿æ‰ä¸‹ä¾†ï¼Œè«‹é€€å›1æ ¼ã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E04ï¼šåœ°éœ‡å¾Œé¦¬ä¸Šé–‹ç“¦æ–¯ç…®æ³¡éºµï¼Œç™¼ç”Ÿç«è­¦ï¼", effect: "å›åˆ°èµ·é»" },
  { desc: "E05ï¼šä½ ç†Ÿè¨˜ç–æ•£è·¯ç·šï¼Œè¿…é€Ÿå¸¶åŒå­¸æ’¤é›¢ï¼Œç²å¾—å¾—2åˆ†ã€‚", effect: "å¾—2åˆ†" },
  { desc: "E06ï¼šä½ ç”¨é˜²ç½åŒ…ä¸­çš„å“¨å­å‘¼æ•‘ï¼ŒæˆåŠŸç²æ•‘ï¼", effect: "å‰é€²2æ ¼" },
  { desc: "E07ï¼šä½ å†·éœèº²é¿ä¸¦å¹«åŠ©åŒå­¸é€ƒé›¢ï¼Œè¡¨ç¾å„ªç§€ï¼", effect: "å‰é€²2æ ¼" },
  { desc: "E08ï¼šåœ°éœ‡å¾Œæ‰“é›»è©±å ±å¹³å®‰ï¼Œé›»è©±æ“å¡ä¸­ã€‚", effect: "åœä¸€å›åˆ" },
  { desc: "E09ï¼šåœ°éœ‡æ™‚çª—æˆ¶ç ´è£‚ä½ è¢«ç¢ç»ç’ƒåŠƒå‚·ã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E10ï¼šä½ åƒåŠ é˜²éœ‡æ¼”ç·´ï¼Œç†Ÿæ‚‰é¿é›£è·¯ç·šï¼", effect: "å¾—1åˆ†" },
  { desc: "E11ï¼šä½ èº²åœ¨æ›¸æ«ƒæ—é‚Šï¼Œè¢«æ›¸å£“å€’ã€‚", effect: "å‰é€²1æ ¼" },
  { desc: "E12ï¼šåœ°éœ‡æ™‚ä½ å¤§å–Šã€Œä¸è¦å‹•ã€è®“å¤§å®¶é©šæ…Œã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E13ï¼šä½ èº²åœ¨å»æ‰€è£¡ï¼Œè¢«å¡ä½äº†ï¼", effect: "åœä¸€å›åˆ" },
  { desc: "E14ï¼šä½ è·Ÿæœ‹å‹é–‹ç©ç¬‘èªªã€Œåœ°éœ‡å¿«ä¾†ã€ï¼ŒçµæœçœŸçš„æ–äº†ï¼", effect: "é€€å›1æ ¼" },
  { desc: "E15ï¼šåœ°éœ‡æ™‚ï¼Œä½ æ‹å½±ç‰‡ä¸Šå‚³ï¼Œåè€Œçµ†å€’è¢«å›°ä½ã€‚", effect: "å‰é€²1æ ¼" },
  { desc: "E16ï¼šä½ å¹«è€å¸«æ¬é˜²ç½ç‰©è³‡ï¼Œæœ‰å‚™ç„¡æ‚£ã€‚", effect: "å‰é€²2æ ¼" },
  { desc: "E17ï¼šåœ°éœ‡åŒ…è£¡æœ‰æ°´å’Œå“¨å­ï¼Œä½ å†·éœç­‰å¾…æ•‘æ´ï¼", effect: "å‰é€²1æ ¼" },
  { desc: "E18ï¼šä½ è½å¾å»£æ’­æŒ‡ç¤ºå‰å¾€ç©ºåœ°é¿é›£ã€‚", effect: "å¾—1åˆ†" }
];

buildBoard();
updateStatus();


  if (mode === "score") {
    // ç§¯åˆ†åˆ¶ï¼šè¨­å®šç›®æ¨™åˆ†æ•¸
	
    //scoreGoal = parseInt(document.getElementById("scoreTarget").value);
  } else if (mode === "time") {
    // é™æ™‚åˆ¶ï¼šå•Ÿå‹•å€’æ•¸è¨ˆæ™‚
    timeLeft = config.timeLimit;
    const status = document.getElementById("status");
    status.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ ç©å®¶: ${playerScores[0]}åˆ† / ç©å®¶2: ${playerScores[1]}åˆ†`;

    timer = setInterval(() => {
      timeLeft--;
      status.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ ç©å®¶: ${playerScores[0]}åˆ† / ç©å®¶2: ${playerScores[1]}åˆ†`;

      if (timeLeft <= 0) {
        clearInterval(timer);
        gameEnded = true;

        // æ¯”è¼ƒé›™æ–¹åˆ†æ•¸
        if (playerScores[0] > playerScores[1]) {
          alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ‰ ç©å®¶ 1 ä»¥ ${playerScores[0]} åˆ†ç²å‹`);
        } else if (playerScores[1] > playerScores[0]) {
          alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ‰ ç©å®¶ 2 ä»¥ ${playerScores[1]} åˆ†ç²å‹`);
        } else {
          alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ¤ é›™æ–¹å¹³æ‰‹ï¼Œå„å¾— ${playerScores[0]} åˆ†ï¼`);
        }
      }
    }, 1000);
  }

function getDescription(filename) {
  const name = filename.split('/').pop().trim();
  const descriptions = {
    "start.png": "èµ·é»ï¼šç©å®¶å¾é€™è£¡é–‹å§‹",    
    "quiz.png": "ç­”é¡Œæ ¼ï¼šç­”å°å¯å¾—åˆ†",
    "event1.png": "äº‹ä»¶å¡1ï¼šéš¨æ©Ÿäº‹ä»¶",
    "event2.png": "äº‹ä»¶å¡2ï¼šéš¨æ©Ÿäº‹ä»¶",
	"fire1.png": "ç«ç½",
    "fire2.png": "ç«ç½", 
	"light.png": "ç‡ˆå…‰",
    "bag1.png": "åŒ…åŒ…", 
	"bag2.png": "åŒ…åŒ…",
    "card1.png": "ç©ºç™½å¡ç‰‡",
	"card2.png": "å¡ç‰‡",
	"earthquake1.png": "åœ°éœ‡äº†", 
	"earthquake2.png": "åœ°éœ‡äº†",
    "earthquake3.png": "åœ°éœ‡äº†",
	"ok1.png": "æ²’äº‹",
	"ok2.png": "æ²’äº‹",
	"ok3.png": "æ²’äº‹",
	"rain1.png": "ä¸‹é›¨",
	"rain2.png": "ä¸‹é›¨",
	"rain3.png": "ä¸‹é›¨",
	"safe.png": "å®‰å…¨å€",
	"safezone.png": "å®‰å…¨å€",
	"warning1.png": "è­¦å‘Š",
	"warning2.png": "è­¦å‘Š",	
    "underdesk.png": "è¢«æ›¸å£“å€’é€€å›èµ·é»",
    "dice.png": "éª°å­æ ¼ï¼šå¯ä»¥å†æ“²ä¸€æ¬¡",
    // ...å¯ä»¥åŠ æ›´å¤š
  };
  return descriptions[name] ||  "";
}


function buildBoard() {
  for (let i = 0; i < 64; i++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    if (mapData[i]) {
      const wrapper = document.createElement("div");
	  wrapper.className = "game-map-wrapper";
	  // åŠ åœ–ç‰‡
	  const img = new Image();
	  img.src = mapData[i];
	  wrapper.appendChild(img);
	  // åŠ  tooltip
	  const tooltip = document.createElement("div");
	  tooltip.className = "game-map-tooltip";
	  tooltip.textContent = getDescription(img.src);
	  wrapper.appendChild(tooltip);

	  cell.appendChild(wrapper);
    }
    if (pathIndices.includes(i)) {
      const label = document.createElement("div");
      label.className = "order-number";
      label.textContent = pathIndices.indexOf(i) + 1;
      cell.appendChild(label);
    }
    gameBoard.appendChild(cell);
  }
  renderPlayers();
  if (!pathIndices || pathIndices.length === 0) {
  alert("âš ï¸ è«‹å…ˆå¾ editor.html è¨­å®šç§»å‹•é †åºä¸¦é–‹å§‹éŠæˆ²ï¼");
}
}
function askQuiz(playerIndex,onCorrect, onWrong) {
  const synth = window.speechSynthesis;
  const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];

  const modal = document.createElement("div");
  modal.style.position = "fixed";
  modal.style.top = "0";
  modal.style.left = "0";
  modal.style.width = "100%";
  modal.style.height = "100%";
  modal.style.backgroundColor = "rgba(0,0,0,0.7)";
  modal.style.display = "flex";
  modal.style.justifyContent = "center";
  modal.style.alignItems = "center";
  modal.style.zIndex = "9999";

  const box = document.createElement("div");
  box.style.background = "white";
  box.style.padding = "20px";
  box.style.borderRadius = "8px";
  box.style.width = "300px";
  box.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
  box.style.textAlign = "center";
  box.style.animation = "slideIn 0.4s ease-out";

  const q = document.createElement("h3");
  q.textContent = quiz.question;
  box.appendChild(q);

  quiz.options.forEach(opt => {
    const btn = document.createElement("button");
	const log = document.getElementById("log");
    btn.textContent = opt;
    btn.style.display = "block";
    btn.style.margin = "8px auto";
    btn.style.padding = "8px 16px";
    btn.style.fontSize = "16px";
    btn.style.cursor = "pointer";
    btn.onclick = () => {
      document.body.removeChild(modal); 
      if (opt.trim().startsWith(quiz.answer)) {
        alert("ç­”å°äº†ï¼åŠ 3åˆ†ã€‚");
		log.innerText += `  ç­”å°é¡Œç›®ï¼šã€Œ${quiz.question}ã€ åŠ  3 åˆ†`;
		
		//log.innerText += `  ç©å®¶${playerIndex + 1} ç­”å°é¡Œç›®ï¼šã€Œ${quiz.question}ã€ åŠ  3 åˆ†`;
		log.scrollTop = log.scrollHeight;
        playerScores[playerIndex] += 3;   // âœ… ç­”å°åŠ  3 åˆ†
		updateStatus();
		onCorrect();
      } else {
        alert("ç­”éŒ¯äº†ï¼è¼ªåˆ°ä¸‹ä¸€ä½ç©å®¶ã€‚");
		//logAction(playerIndex, lastDiceRoll[playerIndex], pathIndices[playerSteps[playerIndex]]);
		//log.innerText += `  ç©å®¶${playerIndex + 1} ç­”éŒ¯ï¼šã€Œ${quiz.question}ã€ `;
		
		log.innerText += `  ç­”éŒ¯ï¼šã€Œ${quiz.question}ã€ `;
		log.scrollTop = log.scrollHeight;
		updateStatus();
		onCorrect();
        
      }
    };
    
	box.appendChild(btn);
  });

  modal.appendChild(box);

  // ä½¿ç”¨èªéŸ³æœ—è®€å•é¡Œèˆ‡é¸é …
  const utterance = new SpeechSynthesisUtterance(`${quiz.question} é¸é …æ˜¯ï¼š${quiz.options.join('ã€')}`);
  utterance.lang = 'zh-TW';
  synth.speak(utterance);

  document.body.appendChild(modal);
}


function renderPlayers() {
  document.querySelectorAll(".player").forEach(p => p.remove());
  playerSteps.forEach((step, idx) => {
    const cellIndex = pathIndices[step];
    const cell = gameBoard.children[cellIndex];
    const token = document.createElement("div");
    token.className = `player player${idx+1}`;
    const car = new Image();
    car.src = idx === 0 ? "car_red.png" : "car_blue.png";
    token.appendChild(car);
    cell.appendChild(token);
    playerTokens[idx] = token;
  });
}
function rollDice() {
      if (gameEnded) return;
	  console.log("log");
	  const log = document.getElementById("log");
	  const selected = document.querySelector('input[name="diceOverride"]:checked');
		let dice = 0;
		
		if (selected && selected.value !== "0") {
    dice = parseInt(selected.value);
  } else {
    dice = Math.floor(Math.random() * 6) + 1;
  }
		
		
		
	  if (skipTurn[currentPlayer]) {
		alert(`ğŸ›‘ ç©å®¶ ${currentPlayer + 1} åœä¸€å›åˆ`);
		log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} åœä¸€å›åˆ`;
		skipTurn[currentPlayer] = false;  // é‡è¨­è·³éç‹€æ…‹
		currentPlayer = (currentPlayer + 1) % 2;  // æ›ä¸‹ä¸€ä½
		document.getElementById("currentPlayer").textContent = currentPlayer + 1;
		return;
	  }
      //const dice = Math.floor(Math.random() * 6) + 1;
	
		log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} æ“²å‡º${dice}`;
		
		lastDiceRoll[currentPlayer] = dice;
		alert(`ç©å®¶${currentPlayer + 1} æ“²å‡º${dice}`);
		document.getElementById("diceResult").textContent = dice;
		document.getElementById("people").textContent = currentPlayer+1;
		const prevStep = playerSteps[currentPlayer];
		let step = playerSteps[currentPlayer] + dice;
	  
			  
		const pathLen = pathIndices.length;

		if ((prevStep < pathLen) && (step >= pathLen)) {
		  passedStart = true;
		}
		step = step % pathLen;
	  
      const fromIndex = pathIndices[prevStep % pathIndices.length];
      const toIndex = pathIndices[step];
      const cellImg = mapData[toIndex] || "";

		if (fromIndex === undefined || toIndex === undefined) {
		  alert("âš ï¸ æ‰¾ä¸åˆ°å°æ‡‰çš„æ ¼å­ï¼Œå¯èƒ½æ˜¯åœ°åœ–å°šæœªæ­£ç¢ºè¨­å®šã€‚");
		  return;
		}


      function nextTurn() {
        currentPlayer = (currentPlayer + 1) % 2;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      }

      function proceed() {
	  //alert(`ğŸ‰ ç©å®¶ ${currentPlayer + 1} å¾· ${scoreTarget} åˆ†`);
	  const pathLength = pathIndices.length;
	  const prev = playerSteps[currentPlayer];
	  const newStep = step;
	  // âœ… åŠ åˆ†ç”¨æ——æ¨™ï¼Œé¿å…é‡è¤‡åŠ åˆ†
	  if (passedStart ) {
		playerScores[currentPlayer] += 1;
		alert("ğŸ‰é€™é‚Šæ˜¯å¥—åœˆçµ‚é»æ˜¯ä¸€èˆ¬æ ¼çš„åŠ åˆ†   å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†ï¼"); //yes
		log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†`;
		passedStart = false;
	  }
	  
		playerSteps[currentPlayer] = step;
		animateMove(currentPlayer, fromIndex, toIndex, () => {
		
		//log.innerText += `  ç©å®¶${currentPlayer + 1} å¾${fromIndex}ç§»å‹•åˆ°${toIndex}\t\t`;
		  updateStatus();
		  logAction(currentPlayer, dice, toIndex);
		  //alert(`ğŸ‰ ç©å®¶ ${currentPlayer + 1} å¾· ${scoreTarget} åˆ†`);
		  //alert(`ğŸ‰${mode} `);
		  //alert(`ğŸ‰0b`);
			if (mode === "score" && playerScores[currentPlayer] >= scoreTarget) {
			  //alert(`ğŸ‰???`);
			  gameEnded = true;
			  //alert(`ğŸ‰ ç©å®¶ ${currentPlayer + 1} é”åˆ° ${scoreTarget} åˆ†ï¼Œç²å‹ï¼`);
			  clearInterval(timer);
			  return;
			}
			//alert(`ğŸ‰proceed_nextturn`);
			nextTurn(); //modify
		  
		});
		
		
	  }
		if (cellImg.includes("dice.png")) {
		  
		  const fromIndex = toIndex;
		  const toStartIndex = pathIndices[0];
		  playerSteps[currentPlayer] = step;
				  animateMove(currentPlayer, fromIndex, toIndex, () => {
			updateStatus();
			alert("ğŸ² æ­å–œï¼ä½ è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼");
			log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼`;
			setTimeout(() => {
			  rollDice();  // âœ… å†æ“²ä¸€æ¬¡
			}, 300);
		  });
		  return;
		}
 if (cellImg.includes("underdesk.png")) {
		  alert("ğŸ“¢ ä½ èº²åˆ°æ›¸æ«ƒæ—é‚Šï¼Œè¢«æ›¸å£“å€’ï¼é€€å›èµ·é»ï¼");
		  log.innerText += ` è¢«æ›¸å£“å€’ï¼é€€å›èµ·é»`;
		  const fromIndex = toIndex;
		  const toStartIndex = pathIndices[0];
		  playerSteps[currentPlayer] = 0;
		  animateMove(currentPlayer, fromIndex, toStartIndex, () => {
			updateStatus();	
			currentPlayer = (currentPlayer + 1) % 2;
			document.getElementById("currentPlayer").textContent = currentPlayer + 1;
		  });
		} else if (cellImg.includes("quiz.png")) {
			//log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} èµ°åˆ°quiz`;
		  askQuiz(currentPlayer, proceed, nextTurn);
		} else if (cellImg.includes("event1.png") || cellImg.includes("event2.png")) {
		  const randomEvent = eventList[Math.floor(Math.random() * eventList.length)];
		  playerSteps[currentPlayer] = step;
		  animateMove(currentPlayer, fromIndex, toIndex, () => {
			handleEventEffect(randomEvent, step);  // âœ… å‹•ç•«çµæŸå¾Œå†åŸ·è¡Œäº‹ä»¶
			
		  });
		} 
		
		
		else if (cellImg.includes("card2.png")) {
  playerSkills[currentPlayer]++;
  updateStatus();
   proceed();
  alert(`ğŸ´ æ­å–œï¼ç©å®¶${currentPlayer+1} ç²å¾—ä¸€å¼µæŠ€èƒ½å¡ï¼Œç›®å‰æŠ€èƒ½å¡ï¼š${playerSkills[currentPlayer]} å¼µ`);
  logEl.innerText += `\nğŸ´ ç©å®¶${currentPlayer+1} ç²å¾—1å¼µæŠ€èƒ½å¡`;
  logEl.scrollTop = logEl.scrollHeight;
}
		
		
		
		
		
		else {//ä¸æ˜¯ä»¥ä¸Šå¹¾ç¨®  è¦æ›äºº
		  //alert(`ğŸ‰else`);
		  proceed();
		  //currentPlayer = (currentPlayer + 1) % 2;
			//document.getElementById("currentPlayer").textContent = currentPlayer + 1;
		}





    }

  function animateMove(playerIdx, from, to, callback) {
  const token = playerTokens[playerIdx];
  log.innerText += `ccc`;
      if (!token) return;
	  log.innerText += `eee`;
      const rectFrom = gameBoard.children[from].getBoundingClientRect();
      const rectTo = gameBoard.children[to].getBoundingClientRect();
      const clone = token.cloneNode(true);
      clone.style.position = 'fixed';
      clone.style.zIndex = '9999';
      clone.style.left = `${rectFrom.left}px`;
      clone.style.top = `${rectFrom.top}px`;
      clone.style.transition = 'all 0.4s ease';
      document.body.appendChild(clone);
      setTimeout(() => {
        clone.style.left = `${rectTo.left}px`;
        clone.style.top = `${rectTo.top}px`;
      }, 10);
      setTimeout(() => {
        document.body.removeChild(clone);
        gameBoard.children[to].appendChild(token);
        if (callback) callback();
      }, 450);
    }

function updateStatus() {
  const status = document.getElementById("status");
  if (mode === "time") {
    status.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ï¼Œç©å®¶1: ${playerScores[0]}åˆ†ï¼Œç©å®¶2: ${playerScores[1]}åˆ† ç©å®¶1æŠ€èƒ½å¡ï¼š${playerSkills[0]}ã€€ç©å®¶2æŠ€èƒ½å¡ï¼š${playerSkills[1]}`;
  } else {
    status.textContent = `ç©åˆ†åˆ¶ï¼šç©å®¶1: ${playerScores[0]}åˆ†ï¼Œç©å®¶2: ${playerScores[1]}åˆ† ç©å®¶1æŠ€èƒ½å¡ï¼š${playerSkills[0]}ã€€ç©å®¶2æŠ€èƒ½å¡ï¼š${playerSkills[1]}`;
  }
}

function log(msg) {
  logEl.innerText += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

function logAction(player, dice, pos) {
      const log = document.getElementById("log");
      const stepNum = pathIndices.indexOf(pos) + 1;
      const imgSrc = mapData[pos] || "";
      const imgName = imgSrc.split('/').pop();
      //log.innerText += `ç©å®¶${player + 1} æ“²å‡º ${dice}ï¼Œç§»å‹•åˆ°ç¬¬ ${stepNum} æ ¼ï¼ˆ${imgName}ï¼‰`;
	  log.innerText += ` ç§»å‹•åˆ°ç¬¬ ${stepNum} æ ¼ï¼ˆ${imgName}ï¼‰`;
      log.scrollTop = log.scrollHeight;
	  //alert("ğŸ“¢ğŸ“¢ğŸ“¢ ï¼");
    }

function didCompleteLap(prevStep, newStep, pathLength) {
  return prevStep > newStep; // ä»£è¡¨ç¹éé ­å›åˆ°èµ·é»
}


  

function showEventCard(event, callback) {
  const card = document.getElementById("event-card-display");
  let skillBtnHtml = "";
  if (playerSkills[currentPlayer] > 0) {
    skillBtnHtml = `<button id="event-skill-btn">ä½¿ç”¨ç‰¹æ®ŠæŠ€èƒ½</button>`;
  }
  card.innerHTML = `
    <h3>ğŸ´ äº‹ä»¶å¡</h3>
    <p>${event.desc}</p>
    <strong>â¡ ${event.effect}</strong>
    <button id="event-ok-btn">ç¢ºèª</button>
    ${skillBtnHtml}
  `;
  card.classList.add("show");

  // åŸæœ¬ç¢ºèª
  card.querySelector("#event-ok-btn").onclick = () => {
    hideEventCard();
    if (callback) callback();
  };
  // æœ‰æŠ€èƒ½æ‰æœ‰æŒ‰éˆ•
  if (playerSkills[currentPlayer] > 0) {
    card.querySelector("#event-skill-btn").onclick = () => {
      alert("ğŸ® ä½ ä½¿ç”¨äº†ç‰¹æ®ŠæŠ€èƒ½ï¼Œæœ¬æ¬¡äº‹ä»¶æ•ˆæœç„¡æ•ˆï¼");
      playerSkills[currentPlayer]--;
      updateStatus();
      hideEventCard();
      // è·³éäº‹ä»¶ã€æ›äºº
      currentPlayer = (currentPlayer + 1) % 2;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      logEl.innerText += `\nğŸ® ç©å®¶${currentPlayer ? 2 : 1} ä½¿ç”¨æŠ€èƒ½å¡ï¼Œäº‹ä»¶ç„¡æ•ˆ`;
      logEl.scrollTop = logEl.scrollHeight;
      updateStatus();
    };
  }
}

function hideEventCard() {
  document.getElementById("event-card-display").classList.remove("show");
}

function handleEventEffect(event, fromStep) {
  showEventCard(event, () => {
    const moveEffects = ["å‰é€²1æ ¼", "å‰é€²2æ ¼", "é€€å›1æ ¼", "é€€å›2æ ¼", "å›åˆ°èµ·é»"];
    const log = document.getElementById("log");
    const lastRoll = lastDiceRoll[currentPlayer];
    log.innerText += `  è§¸ç™¼äº‹ä»¶ï¼šã€Œ${event.desc} ${event.effect}ã€\n`;
    log.scrollTop = log.scrollHeight;
	

    let newStep = playerSteps[currentPlayer];

    if (event.effect === "å‰é€²1æ ¼") {
      newStep = (newStep + 1) % pathIndices.length;
    } else if (event.effect === "å‰é€²2æ ¼") {
      newStep = (newStep + 2) % pathIndices.length;
    } else if (event.effect === "é€€å›1æ ¼") {
      newStep = (newStep - 1 + pathIndices.length) % pathIndices.length;
    } else if (event.effect === "é€€å›2æ ¼") {
      newStep = (newStep - 2 + pathIndices.length) % pathIndices.length;
    } else if (event.effect === "å›åˆ°èµ·é»") {
      newStep = 0;
    }
	//logAction(currentPlayer, dice, newStep);
    if (event.effect === "å¾—2åˆ†") {
      playerScores[currentPlayer] += 2;
      updateStatus();
    } else if (event.effect === "å¾—1åˆ†") {
      playerScores[currentPlayer] += 1;
      updateStatus();
    } else if (event.effect === "åœä¸€å›åˆ") {
      skipTurn[currentPlayer] = true;
    }

    const fromIndex = pathIndices[fromStep];
    const toIndex = pathIndices[newStep];
    playerSteps[currentPlayer] = newStep;

    animateMove(currentPlayer, fromIndex, toIndex, () => {
      updateStatus();
      const img = mapData[toIndex] || "";

      if (passedStart) {
        playerScores[currentPlayer] += 1;
        alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†(é€™é‚Šæ˜¯å¥—åœˆå¾Œ  èµ°åˆ°eventçš„åŠ åˆ†  ä½†å¦‚æœæ˜¯eventé€£é–å‰é€²æ˜¯ä¸åŠ åˆ†çš„)ï¼");
        log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†`;
        passedStart = false;
        updateStatus();
      }

      if (img.includes("dice.png")) {
        alert("ğŸ² æ­å–œï¼ä½ è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼");
        log.innerText += `\nğŸ¯ ç©å®¶${currentPlayer + 1} è¸©åˆ°éª°å­æ ¼ï¼Œå¯ä»¥å†æ“²ä¸€æ¬¡ï¼ï¼ˆäº‹ä»¶å¾Œï¼‰`;
        setTimeout(() => {
          rollDice();
        }, 300);
        return;
      }

      if (img.includes("underdesk.png")) {
        alert("ğŸ“¢ ä½ èµ°åˆ°äº† underdeskï¼è¢«æ›¸å£“å€’ï¼Œé€€å›èµ·é»ï¼");
		log.innerText += ` ç©å®¶${currentPlayer + 1}è¢«æ›¸å£“å€’ï¼é€€å›èµ·é»`;
        const toStart = pathIndices[0];
        playerSteps[currentPlayer] = 0;
        animateMove(currentPlayer, toIndex, toStart, () => {
          updateStatus();
          currentPlayer = (currentPlayer + 1) % 2;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        });
        return;
      }
//console.log(img, "quizåˆ¤æ–·");
      if (img.includes("quiz.png")) {
        askQuiz(currentPlayer, () => {
          currentPlayer = (currentPlayer + 1) % 2;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        }, () => {
          currentPlayer = (currentPlayer + 1) % 2;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        });
        return;
      }

      if ((img.includes("event1.png") || img.includes("event2.png")) && moveEffects.includes(event.effect)) {
        const nextEvent = eventList[Math.floor(Math.random() * eventList.length)];
        setTimeout(() => {
          handleEventEffect(nextEvent, newStep);
        }, 200);
      } else {
        currentPlayer = (currentPlayer + 1) % 2;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
		updateStatus();
      }
    });
  });
}
document.addEventListener('keydown', function(e) {
    if ((e.code === "Space" || e.key === " ") && !gameEnded) {
      e.preventDefault();
      rollDice();
    }
  });
</script>
</body>
</html>
