<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Disaster Monopoly</title>

    <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0.5rem;
      display: flex;
    }
:root{
 
  --cell: min(90px, calc((100vw - 40px) / 8));
}

    #left-panel {
      flex: 1;
    }

    #right-panel {
      
      margin-left: 10px;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(8, var(--cell));      
      grid-template-rows: repeat(8, var(--cell));     
      gap: 2px;
	  width:100%;
  max-width: calc(var(--cell)*8 + 14px);
  margin:0 auto;
    }




    .cell {
	
	 width:var(--cell) !important;
  height:var(--cell) !important;      
      
      border: 1px solid #aaa;
      position: relative;
      background: white;
    }

    .cell img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      position: absolute;
      top: 0;
      left: 0;
    }

    .order-number {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.7);
      padding: 1px 3px;
      border-radius: 4px;
    }

    .player {
      width: 40px;
      height: 40px;
      position: absolute;
      z-index: 5;
    }

    .player1 {
      top: 4px;
      left: 4px;
    }

    .player2 {
      top: 4px;
      right: 4px;
    }

    .player3 {
      bottom: 4px;
      left: 4px;
    }

    .player4 {
      bottom: 4px;
      right: 4px;
    }

    .player img {
      width: 100%;
      height: 100%;
    }

    #log {

      white-space: pre-line;
      font-size: 14px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      padding: 6px;
      max-height: 1000px;
      overflow-y: auto;

    }

    #configInfo {
      background: #e8f4ff;
      padding: 10px;
      border: 1px solid #89b;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 14px;
      
      
    }

    #event-card-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 280px;
      height: 380px;
      background: white;
      border: 2px solid #444;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 9999;
      padding: 20px;
      animation: fadeIn 0.4s ease;
    }

    #event-card-display.show {
      display: flex;
    }

    .game-map-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }




    .game-map-tooltip {
      visibility: hidden;
      opacity: 0;
      width: max-content;
      max-width: 140px;
      background: #333;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 2px 2px;
      z-index: 10;
      bottom: 100%;
      left: 50%;

      font-size: 12px;
      pointer-events: none;
      white-space: pre-line;
      transition: opacity 0.3s;
    }

    .game-map-wrapper:hover .game-map-tooltip {
      visibility: visible;
      opacity: 1;
    }

    #game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: linear-gradient(135deg, #ff5f6d, #ffc371);
      color: white;
      border: 4px solid #fff;
      border-radius: 15px;
      padding: 30px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      z-index: 10000;
      transition: transform 0.5s ease, opacity 0.5s ease;
      opacity: 0;
    }

    #game-over.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    #game-over h1 {
      font-size: 2.5em;
      margin-bottom: 20px;
    }

    #game-over button {
      background: white;
      color: #ff5f6d;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s, transform 0.3s;
    }

    #game-over button:hover {
      background: #ffe0e6;
      transform: scale(1.1);
    }

    #quiz-history {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: #fff;
      color: #333;
      border: 3px solid #ccc;
      border-radius: 10px;
      padding: 20px;
      text-align: left;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      z-index: 10001;
      width: 400px;
      max-height: 70%;
      overflow-y: auto;
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }

    #quiz-history.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    #quiz-history h2 {
      text-align: center;
    }

    #roll-dice-btn {
      background: linear-gradient(135deg, #ff7e5f, #feb47b);
      border: none;
      color: white;
      padding: 2px 2px;
      font-size: 20px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      letter-spacing: 1px;
    }

    #roll-dice-btn:hover {
      background: linear-gradient(135deg, #feb47b, #ff7e5f);
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    #roll-dice-btn:active {
      transform: translateY(0) scale(0.98);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    /* ==== Scoreboard (美化) ==== */
    #status {
      margin: 12px 0;
    }

    .score-grid {
      display: grid;
      grid-auto-flow: column;
      /* 單列排列 */
      grid-auto-columns: 1fr;
      /* 每張卡片等分容器寬度 */
      gap: 12px;
      padding: 6px 4px;
      overflow: hidden;
      /* 不要捲軸 */
    }

    .score-card {
      --accent: #e0e0e0;
      height: 80px;
      --bg: rgba(0, 0, 0, .03);
      background: #fff;
      border: 2px solid var(--accent);
      border-radius: 14px;
      padding: 2px 12px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      /* 不再把左右拉到兩端 */
      position: relative;
      gap: 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, .06);
      grid-template-columns: 120px 1fr auto;
    }

    @media (max-width: 900px) {
      .score-card {
        grid-template-columns: 100px 1fr auto;
      }
    }

    .player-avatar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .player-avatar .token {
      width: 36px;
      height: 36px;
      object-fit: contain
    }

    .player-avatar .name {
      font-weight: 800;
      letter-spacing: .4px;
      line-height: 1.1
    }

    .score-card .left {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .score-card .right {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      flex: 1;
    }

    .score {
      font-size: 22px;
      font-weight: 800
    }

    .badges {
      display: flex;
      gap: 6px
    }

    .badge.pause {
      border-style: dashed;
      opacity: .9
    }

    .badge {
      font-size: 12px;
      border: 1px solid var(--accent);
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--bg)
    }

    .score-card.active {
      box-shadow:
        0 0 0 6px rgba(var(--accent-rgb, 0, 0, 0), .45),
        0 10px 24px rgba(0, 0, 0, .18);
      transform: translateY(-1px);
    }

    /* Colors: P1紅 / P2藍 / P3綠 / P4紅 */
    .score-card.p1 {
      --accent: #e74c3c;
      --accent-rgb: 231, 76, 60;
    }

    .score-card.p2 {
      --accent: #3498db;
      --accent-rgb: 52, 152, 219;
    }

    .score-card.p3 {
      --accent: #2ecc71;
      --accent-rgb: 46, 204, 113;
    }

    .score-card.p4 {
      --accent: #f1c40f;
      --accent-rgb: 241, 196, 15;
    }

    .skill-cards {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      min-height: 28px;
    }

    .skill-cards .scard {
      width: 22px;
      height: 22px;
      padding: 1px;
      border: 1px solid var(--accent);
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .15);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .skill-cards .scard img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .goal {
      width: 60px;
      /* ← 進度條底長度固定 */
      height: 8px;
      border-radius: 999px;
      background: #eef1f6;
      /* 底色 */
      overflow: hidden;
      position: relative;
    }

    .goal .bar {
      height: 100%;
      width: 0%;
      /* 由 JS 以百分比設定 */
      background: linear-gradient(90deg, var(--accent, #888), rgba(0, 0, 0, .15));
      transition: width .35s ease;
    }

    .goal {
      width: 80px;
      height: 8px;
      border-radius: 999px;
      background: #eef1f6;
      overflow: hidden;
      position: relative;
    }

    .goal .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent, #888), rgba(0, 0, 0, .15));
      transition: width .35s ease;
    }

    /* 目標達成時用實色，右緣看起來才會「真的滿」 */
    .goal .bar.full {
      background: var(--accent, #888);
    }

    .score-card.winner::after {
      content: "👑";
      position: absolute;
      top: -12px;
      right: -12px;
      font-size: 32px;
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, .25));
    }

    .quiz-opt {
      display: block;
      width: 80%;
      /* 固定寬度。想吃滿容器就改成 100% */
      max-width: 100%;
      margin: 8px auto;
      box-sizing: border-box;
      text-align: left;
    }/* 讓地圖可縮放（若你已加過可略過） */
/* ==== 1) 柔性格寬（跟 editor 一樣）==== */
:root{
  --cell: min(90px, calc((100vw - 32px) / 8));
}
@media (max-width:480px){
  :root{ --cell: min(72px, calc((100vw - 24px) / 8)); }
}

/* ==== 2) 外層允許換行（左右欄改上下堆）==== */
body{ flex-wrap: wrap; gap: 20px; box-sizing: border-box; }

/* ==== 3) 版面順序：左(頂部) → 棋盤 → 右(Record最底) ==== */
@media (max-width: 768px){
  #left-panel{ order:1; flex:1 1 100%; width:100%; min-width:0; }
  
  #game-board, #board-wrap, #center-panel, #game-frame{ order:2; width:100%; max-width:100%; margin:0 auto; }
  #right-panel{ order:3; flex:1 1 100%; width:100%; min-width:0; }
}

/* ==== 4) 取消右欄死寬，桌機仍能佔位 ==== */
#right-panel{
  width: auto !important;           /* 覆蓋 750px */
  flex: 1 1 360px;
  margin-left: 10px;
}

/* ==== 5) 記分板/設定滿版（覆蓋 720px 舊值與 inline style）==== */
#configInfo, fieldset, .scoreboard, .status-card, .player-card, .controls, .card, .panel{
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box;
}

/* ==== 6) 棋盤用變數格寬，而不是 90px ==== */
#game-board{
  display: grid;
  grid-template-columns: repeat(8, var(--cell)) !important;
  grid-template-rows:    repeat(8, var(--cell)) !important;
  gap: 2px;
  width: 100%;
  max-width: calc(var(--cell) * 8 + 14px);
  margin: 0 auto;
}
#game-board .cell{
  width: var(--cell) !important;
  height: var(--cell) !important;
}
#game-board .cell img{ max-width:100%; max-height:100%; object-fit:contain; }
#configInfo, fieldset, .scoreboard, .status-card, .player-card, .controls, .card, .panel{
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box;
}


@media (max-width:768px){
  #log{ max-height: 40vh; overflow:auto; }
}
@media (max-width: 768px){
  body > div:first-of-type{
    flex-wrap: wrap !important;    
    width: 100%;
  }
}

.dm-overlay{
  position: fixed; inset: 0;
  background: rgba(0,0,0,.55);
  display: flex; justify-content: center; align-items: center;
  z-index: 99999;
  padding: 16px;
}
.dm-box{
  width: min(90vw, 420px);
  background: #fff; border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.3);
  padding: 16px 16px 12px;
  font-size: 18px; line-height: 1.5;
}
.dm-actions{
  display: flex; justify-content: flex-end; gap: 12px; margin-top: 12px;
}
.dm-btn{ border: 0; background: none; font-size: 18px; padding: 6px 10px; }
.dm-btn.ok{ color: #1a73e8; font-weight: 700; }
.dm-btn.cancel{ color: #666; }


  .dm-overlay{ align-items: flex-start; }
  .dm-box{ margin-top: calc(12vh + env(safe-area-inset-top, 0px)); }

.dm-actions{
  display: flex; justify-content: flex-end; gap: 12px; margin-top: 12px;
}
.dm-btn{ border: 0; background: none; font-size: 18px; padding: 6px 10px; }
.dm-btn.ok{ color: #1a73e8; font-weight: 700; }
.dm-btn.cancel{ color: #666; }


  .dm-overlay{ align-items: flex-start; }
  .dm-box{ margin-top: calc(12vh + env(safe-area-inset-top, 0px)); }

.dm-actions{
  display:flex;
  justify-content:flex-end;
  gap:12px;
  margin-top:12px;
}

/* 共用按鈕樣式 */
.dm-btn{
  -webkit-appearance:none;
  appearance:none;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:10px 16px;              /* 點擊區大一點 */
  min-height:40px;
  border-radius:10px;
  border:1px solid transparent;
  font-size:16px;
  font-weight:600;
  cursor:pointer;
  user-select:none;
  transition:transform .02s ease, box-shadow .15s ease, background-color .15s ease, border-color .15s ease;
  box-shadow:0 1px 2px rgba(0,0,0,.05);
}

/* 主要按鈕：確定/好 */
.dm-btn.ok{
  background:#1a73e8;             /* Google 藍 */
  border-color:#1a73e8;
  color:#fff;
}
.dm-btn.ok:hover{ filter:brightness(.97); }
.dm-btn.ok:active{ transform:translateY(1px); filter:brightness(.94); }

/* 次要按鈕：取消 */
.dm-btn.cancel{
  background:#f3f4f6;             /* 淺灰 */
  border-color:#e5e7eb;
  color:#374151;                   /* 深灰字 */
}
.dm-btn.cancel:hover{ background:#e5e7eb; }
.dm-btn.cancel:active{ transform:translateY(1px); }

/* 鍵盤可及性 */
.dm-btn:focus-visible{
  outline:2px solid #2563eb;
  outline-offset:2px;
}

/* 手機：按鈕更好按，左右平均寬（可依喜好保留或刪除） */
@media (max-width:768px){
  .dm-actions{ justify-content:stretch; }
  .dm-btn{ flex:1 1 0; min-height:44px; }
}

  </style>
  <style>
  body {
  background:
    radial-gradient(circle at 10px 10px, rgba(0,0,0,0.05) 1.2px, transparent 1.3px) 0 0 / 14px 14px,
    linear-gradient(180deg, #fffbe8, #fff4c9 60%, #ffeeb5 100%);
}
/* 1) 擲骰按鈕：黃色膠囊＋粗黑邊＋實心下影 */
#roll-dice-btn{
  background:#ffd400 !important;
  color:#111 !important;
  border:2px solid #111 !important;
  border-radius:16px !important;
  padding:6px 14px !important;
  font-weight:900 !important;
  letter-spacing:.5px !important;
  box-shadow:0 4px 0 #111 !important;  /* 漫畫式實心影 */
}
#roll-dice-btn:hover{
  transform:translateY(-1px) !important;
  box-shadow:0 6px 0 #111 !important;
}
#roll-dice-btn:active{
  transform:translateY(1px) !important;
  box-shadow:0 2px 0 #111 !important;
}

/* 2) 紀錄框：白底、圓角、粗黑邊、實心下影 */
#log{
  background:#ffffff !important;
  border:2px solid #111 !important;
  border-radius:16px !important;
  box-shadow:0 3px 0 #111 !important;
  padding:12px 16px !important;
  font-size:16px !important;
  line-height:1.6 !important;
}

/* 3) 路徑順序數字：白色圓點＋粗黑邊＋粗體字 */
.order-number{
  background:#fff !important;
  color:#111 !important;
  border:2px solid #111 !important;
  border-radius:999px !important;
  padding:1px 3px !important;
  font-weight:900 !important;
  font-size:10px !important;
  box-shadow:0 1px 0 #111 !important; /* 漫畫式實心影 */
}



/* 厚度投影：讓每格看起來「有厚度」而不是只有外框 */
#game-board .cell::after{
  content:"";
  position:absolute; inset:0;
  border-radius:12px;
  transform: translateY(2px);     /* 厚度高度；想薄一點改 3px */
  background: rgba(0,0,0,.06);    /* 厚度的暗面 */
  filter: blur(0.3px);
  z-index:-1;
}

/* 滑過微彈跳，更有立體感（不做3D傾斜） */
#game-board .cell:hover{
  transform: translateY(-2px);
  box-shadow:
    inset 0 2px 0 rgba(255,255,255,.85),
    inset 0 -3px 0 rgba(0,0,0,.08),
    0 3px 0 #111;
}

/* 圖片維持乾淨：無外框/陰影 */
#game-board .cell img{
transform: scale(0.95);
  transform-origin: center center;
  border:none !important;
  box-shadow:none !important;
  filter:none !important;
}

</style>
  
  
</head>

<body>

<div style="display: flex; align-items: flex-start; gap: 20px; width: 100%; min-height: 100vh; box-sizing: border-box;">
  <div id="left-panel">
  <div id="topbar">
    <div id="configInfo"></div>
    <div id="status" style="margin: 10px 0;"></div>
    <div>
      <button id="roll-dice-btn" onclick="rollDice()">🎲 Player <span id="currentPlayer">1</span></button>

      Previous Player<span id="people">-</span> rolled <span id="diceResult">-</span>
    
    <fieldset style="margin-top: 10px; border: 1px solid #ccc; padding: 10px;">

      <legend>🎯 Set Dice (Cheat)</legend>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="0" checked> random</label>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="1"> 1</label>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="2"> 2</label>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="3"> 3</label>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="4"> 4</label>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="5"> 5</label>
      <label style="margin-right: 8px;"><input type="radio" name="diceOverride" value="6"> 6</label>
    </fieldset>
	</div>
	</div>
    <div id="game-board"></div>


  </div>
  <div id="right-panel">

    <div id="event-card-display"></div>

  

    <h2>🎲Record</h2>
    <div id="log"></div>

  </div>
  <div id="game-over" class="hidden">
    <h1>🏆 Game Over 🏆</h1>
    <p id="winner-text"></p>
    <button onclick="restartGame()">Restart</button>
    <button onclick="showQuizHistory()">View Quiz History</button>
    <button onclick="closeGameOver()">❌ Close</button>
  </div>
  <!-- 顯示答題記錄的區塊 -->
  <div id="quiz-history" class="hidden">
    <h2>📚 Quiz History</h2>
    <div id="quiz-list"></div>
    <button onclick="closeQuizHistory()">Close</button>
  </div>

  <audio id="diceSound" src="dice-sound.mp3" preload="auto"></audio>
  <script>


    let config = {};
    try { config = JSON.parse(localStorage.getItem("gameConfig") || '{}'); } catch (e) { config = {}; }

    // ---- 預設地圖（當未載入任何地圖設定時啟用）----

    function __buildDefaultMap() {
      // 外圈路徑（8x8）：上→右→下→左（共 28 格）


      // 使用你提供的 map1 陣列語法（只放置有內容的格子）
      const map1 = [
        { index: 0, img: 'start.png' },
        { index: 1, img: 'fire_station_0.png' },
        { index: 2, img: 'dice.png' },
        { index: 3, img: 'bag1.png' },
        { index: 4, img: 'museum921_0.png' },
        { index: 5, img: 'ok1.png' },
        { index: 6, img: 'event1.png' },
        { index: 7, img: 'quiz_water.png' },
        { index: 15, img: 'underdesk.png' },
        { index: 23, img: 'water_bureau_0.png' },
        { index: 31, img: 'light.png' },
        { index: 39, img: 'back.png' },
        { index: 38, img: 'ok3.png' },
        { index: 37, img: 'card2.png' },
        { index: 29, img: 'fire_station_0.png' },
        { index: 21, img: 'ok2.png' },
        { index: 20, img: 'rain1.png' },
        { index: 19, img: 'quiz_earthquake.png' },
        { index: 27, img: 'fire2.png' },
        { index: 35, img: 'dice.png' },
        { index: 34, img: 'quiz_water.png' },
        { index: 33, img: 'event1.png' },
        { index: 32, img: 'fire_station_0.png' },
        { index: 24, img: 'earthquake3.png' },
        { index: 17, img: 'rain1.png' },
        { index: 8, img: 'quiz_fire.png' },
      ];

      // 轉成遊戲用的 mapData 結構（index -> img）
      const map = {};


      for (const { index, img } of map1) {
        if (Number.isInteger(index) && typeof img === 'string') {
          map[index] = img;
        }
      }

      const seen = new Set();
      const ring = [];
      for (const { index } of map1) {
        if (Number.isInteger(index) && !seen.has(index)) {
          seen.add(index);
          ring.push(index);
        }
      }
      return { ring, map };
    }

    function __isValidConfig(cfg) {
      const okPath = Array.isArray(cfg?.pathIndices)
        && cfg.pathIndices.length > 0
        && cfg.pathIndices.every(n => Number.isInteger(n) && n >= 0 && n < 64);

      const okMap = cfg?.mapData && Object.keys(cfg.mapData).length > 0;

      return okPath && okMap;
    }

    // 若沒有地圖（pathIndices 或 mapData 皆可作為判斷）→ 套用預設
    (function __ensureDefaults() {
      if (!__isValidConfig(config)) {
        const { ring, map } = __buildDefaultMap();
        config.pathIndices = ring;
        config.mapData = map;
        config.mode = config.mode || "score";
        config.scoreTarget = config.scoreTarget || 20;
        config.timeLimit = config.timeLimit || 120;
        config.playerCount = config.playerCount || 2;
      }
    })();


    const { mode, timeLimit, scoreTarget, playerCount, mapData, pathIndices } = config;
    const nPlayers = config.playerCount || 2;
    document.getElementById("configInfo").innerText =
      mode === "time"
        ? `🎯 Mode: Timed（${timeLimit} sec）`
    : `🎯 Mode: Score（${scoreTarget} pts）`;
    const gameBoard = document.getElementById("game-board");
    const logEl = document.getElementById("log");
    document.getElementById("configInfo").innerText = "Disaster Monopoly —" + document.getElementById("configInfo").innerText;
    console.log(config);

    let playerSteps = new Array(nPlayers).fill(0);
    let playerScores = new Array(nPlayers).fill(10);
    let playerSkills = new Array(nPlayers).fill(1); // 每人初始1技能卡
    let skipTurn = new Array(nPlayers).fill(false);
    let lastDiceRoll = new Array(nPlayers).fill(0);
    let playerTokens = new Array(nPlayers).fill(null);
    let currentPlayer = 0;

    let gameEnded = false;
    let winnerIndex = null;
    let timer = null;
    let timeLeft = timeLimit;

    let quizHistory = [];
    let isAskingQuiz = false; // ✅ 防呆：避免同一回合重複彈出問答

    function isQuizTileName(name) {
      if (!name) return false;
      return name.includes("quiz_earthquake.png") || name.includes("quiz_fire.png") || name.includes("quiz_water.png");
    }

    function closeGameOver() {
      document.getElementById('game-over').classList.remove('show');
    }
    let quizQuestions = [];
    let passedStart = false;

    const QUIZ = {
      fire: [
        { category: 'fire', question: 'What should you do when encountering thick smoke?', options: ['Move forward low while covering mouth and nose', 'Run with head up', 'Take the elevator to leave'], answer: 0 },
        { category: 'fire', question: 'Which step in using a fire extinguisher (PASS) is wrong?', options: ['Pull the pin', 'Aim at the base', 'Aim at the top of the smoke'], answer: 2 },
        { category: 'fire', question: 'When discovering a fire, what is the safest thing to do first?', options: ['Go back immediately to take valuables', 'Shout “fire” and report', 'Run upstairs'], answer: 1 },
        { category: 'fire', question: 'What danger does thick smoke in a fire cause?', options: ['Just a smell, no harm', 'Makes it hard to see direction', 'Helps us find the fire source', 'Makes people faint and call for help automatically'], answer: 1 },
        { category: 'fire', question: 'When you see wires sparking or smoking, what is the safest action?', options: ['Pour water on it', 'Unplug immediately', 'Notify an adult or teacher and stay away', 'Use a stick to knock down the wire'], answer: 2 },
        { category: 'fire', question: 'Which situation is most likely to cause a fire?', options: ['Turning off the lights at night to sleep', 'Forgetting to turn off appliances after use', 'Weather turning cold', 'Living room being too quiet'], answer: 1 },
        { category: 'fire', question: 'If home wiring is old, what should you do?', options: ['Wrap with tape and keep using', 'Have a professional check and replace', 'Burn it to see if it catches fire', 'Unplug everything and stop using electricity'], answer: 1 },
        { category: 'fire', question: 'Why can’t you use the elevator to escape during a fire?', options: ['Elevator is too crowded', 'Air inside is too poor', 'Fire may cause malfunction or power outage trapping you', 'Elevator is too slow'], answer: 2 },
        { category: 'fire', question: 'If your clothes catch fire, what should you do?', options: ['Run fast to blow out the fire', 'Hide in bathroom and pour water', 'Stop, drop, and roll; cover flames with thick cloth', 'Stand and shout for help'], answer: 2 },
        { category: 'fire', question: 'When discovering a fire, you should immediately?', options: ['Record a video and upload', 'Hide in the room', 'Escape quickly and call 119', 'Go back to get your phone'], answer: 2 },
        { category: 'fire', question: 'Where is using a lighter more likely to cause a fire?', options: ['Bathroom', 'Kitchen', 'Playground', 'Living room'], answer: 1 },
        { category: 'fire', question: 'Which of the following items is most flammable?', options: ['Metal', 'Plastic toys', 'Quilt', 'Ice'], answer: 2 },
        { category: 'fire', question: 'Why should you cover your mouth and nose during a fire?', options: ['Keep warm', 'Can’t see the fire', 'Avoid inhaling smoke', 'Prevent screaming'], answer: 2 },
        { category: 'fire', question: 'Which action is wrong?', options: ['Don’t play with lighters', 'Turn off appliances before sleep', 'Escape immediately when discovering fire', 'Use elevator to escape during fire'], answer: 3 },
        { category: 'fire', question: 'What should you do after using the gas stove?', options: ['Keep the fire on', 'Forget to turn off is fine', 'Make sure flame is out and turn off gas switch', 'Blow gas with an electric fan'], answer: 2 },
        { category: 'fire', question: 'What is 119 used for?', options: ['Check weather', 'Order pizza', 'Report fire and emergency help', 'Check address'], answer: 2 },
        { category: 'fire', question: 'When discovering a fire, you should immediately?', options: ['Record a video and upload', 'Hide in the room', 'Escape quickly and call 119', 'Go back to get your phone'], answer: 2 },
        { category: 'fire', question: 'What is the safest way to escape during a fire?', options: ['Stay still', 'Crawl low', 'Run upright', 'Take the elevator'], answer: 1 }
      ],
     water: [
        { category: 'water', question: 'Which behavior is safe during a typhoon?', options: ['Go out in heavy rain to take photos', 'Hide under a big tree to avoid rain', 'Stay at home with gas turned off, windows closed, and watch weather updates', 'Go to the beach to watch waves'], answer: 2 },
        { category: 'water', question: 'Why should you not walk into floodwaters?', options: ['Water is dirty and will damage shoes', 'There might be small fish biting', 'Floodwater may hide wires, holes, or unseen dangers', 'Floodwater might cause a cold'], answer: 2 },
        { category: 'water', question: 'Which is NOT a cause of flooding?', options: ['Heavy rain or typhoon', 'River water rising rapidly', 'Poor drainage system', 'Weather being too dry'], answer: 3 },
        { category: 'water', question: 'To reduce the impact of floods, what can we do in daily life?', options: ['Throw trash into drains', 'Build houses in low-lying areas', 'Clean drainage holes and prevent blockage', 'Ignore weather forecasts'], answer: 2 },
        { category: 'water', question: 'During a flood, if the government announces evacuation, what should we do?', options: ['Stay at home and sleep', 'Go out with an umbrella for fun', 'Immediately follow instructions to evacuation sites and watch weather updates', 'Record a video and upload it'], answer: 2 },
        { category: 'water', question: 'Which is NOT a possible consequence of flooding?', options: ['House flooding', 'Farmland damage', 'Road interruptions', 'Hotter weather'], answer: 3 },
        { category: 'water', question: 'When a flood occurs, what should we do?', options: ['Stay at home and watch TV', 'Go to the river to see water level', 'Follow adults’ instructions to safe places', 'Jump into water to swim'], answer: 2 },
        { category: 'water', question: 'Which can help reduce the chance of flooding?', options: ['Throw garbage into drains', 'Build drainage systems', 'Cut down all trees', 'Throw garbage into rivers'], answer: 1 },
        { category: 'water', question: 'Why should garbage not be thrown into drains?', options: ['It’s fine, water will wash it away', 'Garbage will decrease', 'It clogs easily and causes flooding', 'It’s more convenient'], answer: 2 },
        { category: 'water', question: 'Facing flood surges and landslides, where should we avoid staying?', options: ['River channels and low-lying valleys', 'On slopes waiting for rescue', 'Strong houses for shelter', 'High riverbanks away from water'], answer: 0 },
        { category: 'water', question: 'Which is NOT a natural cause of flooding?', options: ['Rainwater flowing into rivers', 'Soil erosion on slopes causing sedimentation', 'Snow melting into rivers', 'Urban cement surfaces draining quickly'], answer: 3 },
        { category: 'water', question: 'Which is NOT a human factor causing or worsening floods?', options: ['Deforestation causing soil erosion', 'Urban surface hardening leading to waterlogging', 'Rivers not dredged regularly causing silt buildup', 'River erosion deepening naturally, increasing flow'], answer: 3 },
        { category: 'water', question: 'Which flood prevention method can be done daily?', options: ['Check weather information regularly and prepare emergency supplies', 'Let trash accumulate in drains', 'Ignore typhoon and heavy rain forecasts', 'Stack sandbags inside windows'], answer: 0 },
        { category: 'water', question: 'Which statement about flood escape tools is correct?', options: ['Use empty oil drums or plastic bottles as simple float devices', 'Paper boxes make the most stable rafts', 'Balls (like basketballs) are the best float tools', 'Life-saving devices do not need sealing'], answer: 0 },
        { category: 'water', question: 'What is the most common main cause of flooding?', options: ['Earthquakes causing ground collapse', 'Heavy rain exceeding river drainage capacity', 'Sudden drop in temperature', 'Increased air pollution'], answer: 1 }
      ],
      earthquake: [
        { category: 'earthquake', question: 'Where is the safest place to hide during an earthquake?', options: ['Inside an elevator', 'Under a desk', 'On the balcony'], answer: 1 },
        { category: 'earthquake', question: 'What should you do immediately during an earthquake?', options: ['Run out of the classroom', 'Find sturdy furniture to hide under', 'Take photos with your phone'], answer: 1 },
        { category: 'earthquake', question: 'Which of the following should NOT be done during an earthquake?', options: ['Hide in a corner', 'Move close to a window', 'Stay calm'], answer: 1 },
        { category: 'earthquake', question: 'Why shouldn’t you use an elevator during an earthquake?', options: ['Elevator may be crowded', 'Elevator may get stuck', 'Too slow'], answer: 1 },
        { category: 'earthquake', question: 'What should be included in an earthquake emergency kit?', options: ['Flashlight', 'Toys', 'Books'], answer: 0 },
        { category: 'earthquake', question: 'If a strong earthquake happens at school, what should you do?', options: ['Chat with classmates', 'Follow teacher’s instructions', 'Leave school on your own'], answer: 1 },
        { category: 'earthquake', question: 'Why should you stay away from windows during an earthquake?', options: ['Glass may break', 'Can’t see outside', 'Too cold'], answer: 0 },
        { category: 'earthquake', question: 'After an earthquake, where should you be cautious of aftershocks?', options: ['Open outdoor areas', 'Stairways', 'Everywhere is safe after the quake'], answer: 1 },
        { category: 'earthquake', question: 'Which of the following is NOT necessary in an emergency kit?', options: ['Whistle', 'Flashlight', 'Video games'], answer: 2 },
        { category: 'earthquake', question: 'Why should you open the door during an earthquake?', options: ['To check what neighbors are doing', 'For ventilation', 'To prevent it from getting stuck'], answer: 2 },
        { category: 'earthquake', question: 'Where are earthquakes most likely to occur?', options: ['Mountain areas', 'Near volcanoes', 'At plate boundaries'], answer: 2 },
        { category: 'earthquake', question: 'What should you do if an earthquake happens in a movie theater?', options: ['Run out quickly', 'Duck down and cover your head', 'Keep sitting and watching'], answer: 1 },
        { category: 'earthquake', question: 'Why can stairways be dangerous during earthquakes?', options: ['Easily crowded', 'Structurally unstable', 'Too tall'], answer: 1 },
        { category: 'earthquake', question: 'What should you do if you are in a car during an earthquake?', options: ['Get out immediately', 'Stay calm and pull over', 'Speed up to leave'], answer: 1 },
        { category: 'earthquake', question: 'Which action should be most avoided during an earthquake?', options: ['Screaming loudly', 'Finding exits', 'Holding onto a wall'], answer: 0 },
        { category: 'earthquake', question: 'What is the most important principle during an earthquake?', options: ['Stay calm', 'Escape quickly', 'Shout loudly'], answer: 0 },
        { category: 'earthquake', question: 'Why should you not use electrical appliances immediately after an earthquake?', options: ['No electricity', 'May cause fire', 'Too noisy'], answer: 1 },
      ]







    };
    //fetch("quiz_all.json")
    //  .then(res => res.json())
    // .then(data => quizQuestions = data);
    // const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];


    // 題庫格式建議：[{ category: "earthquake"|"fire"|"water", question, options:[], answer }]
    // answer 可是數字索引(0-based) 或 舊格式的「選項字首」(例如 "A." / "B.")
    function getRandomQuiz(category) {
      let pool = [];
      if (category === 'fire') pool = QUIZ.fire;
      else if (category === 'water') pool = QUIZ.water;
      else if (category === 'earthquake') pool = QUIZ.earthquake;
      else pool = [...QUIZ.fire, ...QUIZ.water, ...QUIZ.earthquake];
      if (!pool.length) return null;
      return pool[Math.floor(Math.random() * pool.length)];
    }

    // 兼容你原本的答題判定：支援「索引」或「字首」
    function isCorrectAnswer(quizObj, optionText, optionIndex) {
      if (typeof quizObj.answer === 'number') {
        return optionIndex === quizObj.answer; // 0-based 索引
      }
      if (typeof quizObj.answer === 'string') {
        // 舊格式：option 以 "A. xxx"；quiz.answer = "A"
        const prefix = optionText.trim().slice(0, quizObj.answer.length);
        return prefix === quizObj.answer;
      }
      return false;
    }

    const PROPERTY_DEFS = {
      fire_station: { buyPrice: 5, toll: 3, display: 'Forest' },
      water_bureau: { buyPrice: 5, toll: 3, display: 'Low Lying Land' },
      school: { buyPrice: 5, toll: 3, display: '學校' },
      museum921: { buyPrice: 5, toll: 3, display: 'High Building' }
    };
    const propertyOwners = {};   // { [cellIndex]: 1|2|3|4|null }
    const propertyKeys = {};   // { [cellIndex]: 'fire_station'|'water_bureau'|... } 快取加速用

    function getPropertyKey(src) {
      if (!src) return null;
      const name = src.split('/').pop().toLowerCase();

      // 先走「標準檔名」規則：<key>_<owner>.png
      for (const key of Object.keys(PROPERTY_DEFS)) {
        if (name.startsWith(key + '_')) return key;
      }

      // 兼容你用生成器產出的長檔名：用關鍵字/別名推斷
      const patterns = [
        { key: 'fire_station', re: /(fire[\s_\-]?station|消防)/ },
        { key: 'water_bureau', re: /(water[\s_\-]?(bureau|dept|department)|水利)/ },
        { key: 'school', re: /(school|學校)/ },
        { key: 'museum921', re: /(921|museum)/ }
      ];
      for (const { key, re } of patterns) {
        if (re.test(name)) return key;
      }
      return null;
    }

    function getOwnerFromImg(src) {
      if (!src) return null;
      const name = src.split('/').pop().toLowerCase();
      const m = name.match(/_(\d)\.(png|webp|jpg)$/);
      return m ? parseInt(m[1], 10) : null;
    }

    function imageForOwner(key, owner) {
      return `${key}_${owner || 0}.png`;
    }

    function setTileImage(index, newImg) {
      mapData[index] = newImg;
      const cell = gameBoard.children[index];
      const imgEl = cell && cell.querySelector('img');
      if (imgEl) imgEl.src = newImg;
    }

   const eventList = [
  { desc: "E01：An earthquake strikes! You hide under a sturdy table. Safe move! Advance 1 space.", effect: "Advance 1 space" },
  { desc: "E02：During the earthquake, you run to the stairs for escape but are stopped by the guard. Skip 1 turn for reflect.", effect: "Skip 1 turn" },
  { desc: "E03：You forgot to secure the bookshelf, and during the earthquake, things fell down. Move back 1 space.", effect: "Move back 1 space" },
  { desc: "E04：After the earthquake, you immediately turn on the gas to cook instant noodles, causing a fire!", effect: "Return to start" },
  { desc: "E05：You memorized the evacuation route and quickly led your classmates to escape, earning 2 points.", effect: "Gain 1 point" },
  { desc: "E06：You used the whistle in the disaster kit to call for help and were successfully rescued!", effect: "Advance 2 spaces" },
  { desc: "E07：You calmly avoided danger and helped your classmates escape, showing excellent performance!", effect: "Advance 2 spaces" },
  { desc: "E08：After the earthquake, you called to report safety, but the line was busy.", effect: "Skip 1 turn" },
  { desc: "E09：During the earthquake, the window shattered and you were cut by the glass.", effect: "Move back 1 space" },
  { desc: "E10：You participated in earthquake drills and became familiar with evacuation routes!", effect: "Gain 1 point" },
  { desc: "E11：You hid next to the bookshelf and were crushed by falling books.", effect: "Return to start" },
  { desc: "E12：During the earthquake, you shouted 'Don't move!' causing panic.", effect: "Move back 1 space" },
  { desc: "E13：You hid in the bathroom and got stuck!", effect: "Advance 1 space" },
  { desc: "E14：You joked with your friend saying 'The earthquake is coming', and it really shook!", effect: "Gain 1 point" },
  { desc: "E15：During the earthquake, you filmed a video to upload but tripped and got stuck.", effect: "Skip 1 turn" },
  { desc: "E16：You helped the teacher move disaster supplies, being well-prepared.", effect: "Move back 1 space" },
  { desc: "E17：The disaster kit contains water and a whistle, and you calmly wait for rescue!", effect: "Return to start" },
  { desc: "E18：You followed the broadcast instructions to evacuate to an open area.", effect: "Gain 1 point" }
];

    buildBoard();
    updateStatus();
const nextFrame = () =>  new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

    if (mode === "score") {
      // 积分制：設定目標分數

      //scoreGoal = parseInt(document.getElementById("scoreTarget").value);
    } else if (mode === "time") {
      // 限時制：啟動倒數計時
      timeLeft = config.timeLimit;
      const configInfo = document.getElementById("configInfo");
      configInfo.textContent = `Timed: ${timeLeft} sec left `;

      timer = setInterval(async() => {
        timeLeft--;
        configInfo.textContent = `Timed: ${timeLeft} sec left `;

        if (timeLeft <= 0) {
          clearInterval(timer);
          gameEnded = true;

          // 比較雙方分數
          const maxScore = Math.max(...playerScores);
          // 找出所有最高分的玩家（支援多人平手）
          const winners = [];
          for (let i = 0; i < playerScores.length; i++) {
            if (playerScores[i] === maxScore) {
              winners.push(i + 1); // 玩家編號從1開始
            }
          }
          if (winners.length === 1) {
            await alert(`⌛ Time's up! player ${winners[0]} wins with ${maxScore} pts`);
            winnerIndex = winners[0] - 1;
            updateStatus();  // ← 0-based
            showGameOverScreen(`⌛ Time's up! Player ${winners[0]} wins with ${maxScore} pts`);
          } else {
            await alert(`⌛ Time's up!🤝 Draw!player ${winners.join("、")} tie at ${maxScore} pts`);
            showGameOverScreen(`⌛ Time's up! 🤝 Draw! Players ${winners.join(", ")} tie at ${maxScore} pts`);
          }



        }
      }, 1000);
    }

    function getDescription(filename) {
      const name = filename.split('/').pop().trim();
      const descriptions = {
        "start.png": "Start: Players begin here",
    "quiz.png": "Quiz: Answer to score",
    "quiz_fire.png": "Fire Quiz: answer to score",
    "quiz_water.png": "Flood Quiz: answer to score",
    "quiz_earthquake.png": "Earthquake Quiz: answer to score",
    "event1.png": "Event Card A: random event",
    "event2.png": "Event Card B: random event",
    "fire1.png": "Fire event",
    "fire2.png": "Fire event",
    "light.png": "Light",
    "bag1.png": "First-aid kit, gain points",
    "bag2.png": "First-aid kit, gain points",
    "card1.png": "Blank card",
    "card2.png": "Skill card",
    "earthquake1.png": "Earthquake",
    "earthquake2.png": "Earthquake",
    "earthquake3.png": "Earthquake",
    "ok1.png": "No special event",
    "ok2.png": "No special event",
    "ok3.png": "No special event",
    "rain1.png": "Flood event",
    "rain2.png": "Flood event",
    "rain3.png": "Flood event",
    "safe.png": "Safe zone",
    "safezone.png": "Safe zone",
    "warning1.png": "Warning",
    "warning2.png": "Warning",
        "underdesk.png": "Earthquake occurs, hide under the table. gain points.",
        "back.png": "back to home",
        "dice.png": "Dice : roll again",
        "fire_station_0.png": "Forest",
        "water_bureau_0.png": "Low Lying Land",
        "museum921_0.png": "High Building",
        // ...可以加更多
      };
      return descriptions[name] || "";
    }


    function buildBoard() {
      for (let i = 0; i < 64; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        if (mapData[i]) {
          const wrapper = document.createElement("div");
          wrapper.className = "game-map-wrapper";
          // 加圖片
          const img = new Image();
          img.src = mapData[i];
          const pKey = getPropertyKey(mapData[i]);
          if (pKey) {
            propertyKeys[i] = pKey;
            propertyOwners[i] = getOwnerFromImg(mapData[i]) ?? 0;// 0 或 null 代表無人
          }
          wrapper.appendChild(img);
          // 加 tooltip
          const tooltip = document.createElement("div");
          tooltip.className = "game-map-tooltip";
          tooltip.textContent = getDescription(img.src);
          wrapper.appendChild(tooltip);

          cell.appendChild(wrapper);
        }
        if (pathIndices.includes(i)) {
          const label = document.createElement("div");
          label.className = "order-number";
          label.textContent = pathIndices.indexOf(i) + 1;
          cell.appendChild(label);
        }
        gameBoard.appendChild(cell);
      }
      renderPlayers();
      if (!pathIndices || pathIndices.length === 0) {
        alert("⚠️ 請先從 editor.html 設定移動順序並開始遊戲！");
      }
    }
    function displayCategory(cat) {
      switch (String(cat || '').toLowerCase()) {
        case 'water': return 'Flood';
        case 'fire': return 'Fire';
        case 'earthquake': return 'Earthquake';
        default: return cat || '';
      }
    }

    function askQuiz(playerIndex, onCorrect, onWrong, quizOverride /* 可選：指定題目 */) {
      const synth = window.speechSynthesis;
      const quiz = quizOverride || getRandomQuiz(null);
      const t0 = Date.now();   // ← 加這行記錄作答起始時間
      if (!quiz) { alert("No questions"); (onWrong || (() => { }))(); return; }

      const modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.7)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "9999";

      const box = document.createElement("div");
      box.style.background = "white";
      box.style.padding = "20px";
      box.style.borderRadius = "8px";
      box.style.width = "300px";
      box.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
      box.style.textAlign = "center";
      box.style.animation = "slideIn 0.4s ease-out";

      const q = document.createElement("h3");
      q.textContent = quiz.question;
      box.appendChild(q);


      const optsWrap = document.createElement('div');
      optsWrap.className = 'quiz-opts';
      quiz.options.forEach((opt, idx) => {
        const btn = document.createElement("button");
        btn.textContent = opt;
        btn.classList.add('quiz-opt');
        btn.style.display = "block";
        btn.style.margin = "8px auto";
        btn.style.padding = "8px 16px";
        btn.style.fontSize = "16px";
        btn.style.cursor = "pointer";
        btn.onclick = () => {
          document.body.removeChild(modal);

          const dt = Date.now() - t0;
          const correct = isCorrectAnswer(quiz, opt, idx);

          // 產生「正確答案顯示文字」
          let correctLabel = "";
          if (typeof quiz.answer === 'number') {
            correctLabel = quiz.options[quiz.answer];
          } else if (typeof quiz.answer === 'string') {
            const match = quiz.options.find(o => o.trim().startsWith(quiz.answer));
            correctLabel = `${quiz.answer}${match ? ` (${match})` : ""}`;
          }

          // 寫入歷史
          quizHistory.push({
            player: playerIndex + 1,
            question: quiz.question,
            selected: opt,
            correctAnswer: correctLabel || "",
            result: correct ? "✔️ Correct" : "❌ Wrong",
            category: quiz.category || "-",
            ms: dt,
            correct: correct
          });
          // 結果處理（保留你原本加分/不加分由呼叫端決定）
          if (correct) {
            alert("Correct！add 3 points");
            onCorrect && onCorrect();
          } else {
            alert("Wrong！");
            onWrong && onWrong();
          }
        };
        box.appendChild(btn);
      });

      modal.appendChild(box);

      // 語音朗讀
      //try {
      // const utterance = new SpeechSynthesisUtterance(`${quiz.question} 選項是：${quiz.options.join('、')}`);
      // utterance.lang = 'zh-TW';
      //  synth.speak(utterance);
      //} catch(_) {}

      document.body.appendChild(modal);
    }


    function showQuizHistory() {
      const historyEl = document.getElementById('quiz-list');
      // 明細列表
      const detailHTML = quizHistory.map(h =>
        `<div>player${h.player}：${h.question}<br>
      ➡️ answer：${h.selected}，${h.result}
      ${Number.isFinite(Number(h.ms)) ? `（${(Number(h.ms) / 1000).toFixed(1)} 秒）` : ``}<br>
      ✅ Correct Answer: ${h.correctAnswer} ${h.category ? `｜ Category：${displayCategory(h.category)}` : ``}
     </div><hr>`
      ).join('');

      // 整理每位玩家統計
      const players = typeof nPlayers !== 'undefined' ? nPlayers : Math.max(1, ...quizHistory.map(h => h.player || 1));
      const stats = [];
      for (let p = 1; p <= players; p++) {
        const items = quizHistory.filter(h => h.player === p);
        const n = items.length;
        const right = items.filter(h => h.correct === true || /正確/.test(h.result || '')).length;
        const acc = n ? (right / n * 100) : 0;
        const totalMs = items.reduce((s, h) => s + (Number(h.ms) || 0), 0);
        const avgSec = n ? Math.round((totalMs / n) / 100) / 10 : 0;
        const by = { fire: { n: 0, c: 0 }, water: { n: 0, c: 0 }, earthquake: { n: 0, c: 0 } };
        items.forEach(h => {
          const t = (h.category || '').toLowerCase();
          if (by[t]) {
            by[t].n += 1;
            by[t].c += (h.correct === true || /正確/.test(h.result || '')) ? 1 : 0;
          }
        });
        const pct = (c, n) => n ? (Math.round((c / n * 100) * 10) / 10) : 0;
        stats.push({
          player: p,
          count: n,
          acc: +(Math.round(acc * 10) / 10),
          avgSec,
          fireAcc: pct(by.fire.c, by.fire.n),
          waterAcc: pct(by.water.c, by.water.n),
          eqAcc: pct(by.earthquake.c, by.earthquake.n)
        });
      }

      // 產生表格
      const table = `
    <style>
      .stats-table{border-collapse:collapse;width:100%;font-size:14px;margin-top:8px}
      .stats-table th,.stats-table td{border:1px solid #ddd;padding:6px 8px;text-align:center}
      .stats-table th{background:#f7f7f7}
    </style>
    <h3>👥 Players results comparison</h3>
    <table class="stats-table" aria-label="每位玩家答題統計">
      <thead>
        <tr>
          <th>player</th><th>answer</th><th>ratio(%)</th><th>average answer second</th>
          <th>Fire ratio(%)</th><th>floodratio(%)</th><th>Earthquake ratio(%)</th>
        </tr>
      </thead>
      <tbody>
        ${stats.map(s => `
          <tr>
            <td>Player${s.player}</td>
            <td>${s.count}</td>
            <td>${s.acc}</td>
            <td>${s.avgSec}</td>
            <td>${s.fireAcc}</td>
            <td>${s.waterAcc}</td>
            <td>${s.eqAcc}</td>
          </tr>`).join('')}
      </tbody>
    </table>`;

      historyEl.innerHTML = detailHTML + table;
      document.getElementById('quiz-history').classList.add('show');

    }

    function closeQuizHistory() {
      document.getElementById('quiz-history').classList.remove('show');
    }



    function renderPlayers() {
      console.log("renderPlayers");
      document.querySelectorAll(".player").forEach(p => p.remove());
      for (let idx = 0; idx < nPlayers; idx++) {
        const cellIndex = pathIndices[playerSteps[idx]];
        const cell = gameBoard.children[cellIndex];
        const token = document.createElement("div");
        token.className = `player player${idx + 1}`;
        const carImgs = ["car_red.png", "car_blue.png", "car_green.png", "car_yellow.png"];
        const car = new Image();
        car.src = carImgs[idx] || "car_red.png";
        token.appendChild(car);
        cell.appendChild(token);
        playerTokens[idx] = token;
      }
    }
    function rollDice() {

      if (gameEnded) return;

      console.log("rollDice");
      if (skipTurn[currentPlayer]) {
        console.log(`player ${currentPlayer + 1} Skip one turn`);
        alert(`🛑 player ${currentPlayer + 1} Skip one turn`);
        const log = document.getElementById("log");
        log.innerText += `\n🎯player ${currentPlayer + 1} Skip one turn`;
        skipTurn[currentPlayer] = false;
        currentPlayer = (currentPlayer + 1) % nPlayers;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        updateStatus();
        return;
      }
      updateStatus();            // ← 讓正在擲骰的玩家立刻高亮
      const selected = document.querySelector('input[name="diceOverride"]:checked');
      let dice = selected && selected.value !== "0" ? parseInt(selected.value) : Math.floor(Math.random() * 6) + 1;

      playDiceAnimation(dice, () => {
        finalizeRoll(dice);
      });
    }

    function playDiceAnimation(finalDice, callback) {
      const diceOverlay = document.createElement("div");
      diceOverlay.id = "diceOverlay";
      diceOverlay.style.position = "fixed";
      diceOverlay.style.top = "50%";
      diceOverlay.style.left = "50%";
      diceOverlay.style.transform = "translate(-50%, -50%)";
      diceOverlay.style.zIndex = "1000";
      diceOverlay.style.backgroundColor = "rgba(255,255,255,0.8)";
      diceOverlay.style.padding = "20px";
      diceOverlay.style.borderRadius = "10px";

      const diceImage = document.createElement("img");
      diceImage.id = "diceImage";
      diceImage.style.width = "100px";
      diceImage.style.height = "100px";
      diceOverlay.appendChild(diceImage);
      document.body.appendChild(diceOverlay);

      const diceSound = document.getElementById("diceSound");
      if (diceSound) {
        diceSound.currentTime = 0;
        diceSound.play();
      }

      let rollCount = 12, currentRoll = 0;
      const interval = setInterval(() => {
        let tempFace = Math.floor(Math.random() * 6) + 1;
        diceImage.src = `dice${tempFace}.png`;
        currentRoll++;
        if (currentRoll >= rollCount) {
          clearInterval(interval);
          diceImage.src = `dice${finalDice}.png`;
          setTimeout(() => {
            document.body.removeChild(diceOverlay);
            if (callback) callback();
          }, 500);
        }
      }, 80);
    }

    function finalizeRoll(dice) {
      console.log("finalizeRoll dice:", dice);
      const log = document.getElementById("log");



      log.innerText += `\n🎯 player${currentPlayer + 1} rolled${dice}`;
      lastDiceRoll[currentPlayer] = dice;
      document.getElementById("diceResult").textContent = dice;
      document.getElementById("people").textContent = currentPlayer + 1;

      continueMoveLogic(dice);
    }

    async function continueMoveLogic(dice) {
      const prevStep = playerSteps[currentPlayer];
      let step = playerSteps[currentPlayer] + dice;
      const pathLen = pathIndices.length;

      if ((prevStep < pathLen) && (step >= pathLen)) {
        passedStart = true;
      }
      step = step % pathLen;

      const fromIndex = pathIndices[prevStep % pathLen];
      const toIndex = pathIndices[step];
      const cellImg = mapData[toIndex] || "";

      if (fromIndex === undefined || toIndex === undefined) {
        alert("⚠️ 找不到對應的格子，可能是地圖尚未正確設定。");
        return;
      }




      const proceed = async () =>  {
        const prev = playerSteps[currentPlayer];
        if (passedStart) {
          playerScores[currentPlayer] += 1;
          alert("🎉 Completed a lap! +1 point！");
          log.innerText += `\n🎯 player${currentPlayer + 1} Completed a lap! +1 point`;
          checkScoreWin();
          passedStart = false;
        }

        playerSteps[currentPlayer] = step;
        animateMove(currentPlayer, fromIndex, toIndex, async() => {
          updateStatus();
          if (checkScoreWin()) return;
          logAction(currentPlayer, dice, toIndex);


          const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");

          if (isQuizTileName(imgNow)) {
            if (isAskingQuiz) return; // already asking, avoid double
            isAskingQuiz = true; // set guard

            let cat = null;
            if (imgNow.includes("quiz_earthquake.png")) cat = "Earthquake questions";
            else if (imgNow.includes("quiz_fire.png")) cat = "Fire questions";
            else if (imgNow.includes("quiz_water.png")) cat = "Flood questions";

            const q = getRandomQuiz(cat);

            askQuiz(
              currentPlayer,
              () => { // ✅ 答對：+3 分，結束回合
                playerScores[currentPlayer] += 3;
                logEl.innerText += ` ✅ player${currentPlayer + 1}  ${cat || "general"} answer correct 「${q.question}」 ，add 3 points`;
                logEl.scrollTop = logEl.scrollHeight;
                updateStatus();
                checkScoreWin();
                isAskingQuiz = false; // release guard
                nextTurn(); // 結束本回合
              },
              () => { // ❌ 答錯：不加分，直接換人
                logEl.innerText += ` ❌ player${currentPlayer + 1}  ${cat || "general"} answer wrong 「${q.question}」`;
                logEl.scrollTop = logEl.scrollHeight;
                isAskingQuiz = false; // release guard
                nextTurn();
              },
              q
            );
            return; // 出題完就收工，不要再往下跑其他格子效果
          }
          if (imgNow.includes("back.png")) {
            await alert("📢 Back to Home！");
            logEl.innerText += ` Back to Home`;
            playerSteps[currentPlayer] = 0;
            renderPlayers();
            updateStatus();
            nextTurn();
            return;
          }
          // 🎲 骰子格：再擲一次（落地後判斷）
          if (imgNow.includes("dice.png")) {
            await alert("🎲 Dice，dice again！");
            playerSteps[currentPlayer] = step;
            logEl.innerText += ` Dice，dice again！`;
            logEl.scrollTop = logEl.scrollHeight;
            setTimeout(() => rollDice(), 300);
            return;
          }
          if (imgNow.includes("underdesk.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            logEl.innerText += `  Right action，add 5 poings`;
            logEl.scrollTop = logEl.scrollHeight;
            await alert(`🎴 Congra！Player ${currentPlayer + 1} Right action，add 5 poings`);
            checkScoreWin();

            // 換下一位
            nextTurn();
            return;
          }
          if (imgNow.includes("bag1.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            logEl.innerText += ` found a first-aid kit: +5 pts`;
            logEl.scrollTop = logEl.scrollHeight;
            await alert(`🎴 Congrats! Player ${currentPlayer + 1} found a first-aid kit: +5 pts`);
            checkScoreWin();

            // 換下一位
            nextTurn();
            return;
          }
          if (imgNow.includes("card2.png")) {
            playerSkills[currentPlayer]++;
            updateStatus();
            await alert(`🎴 Congrats！Player${currentPlayer + 1} get one card，now card number is：${playerSkills[currentPlayer]} `);
            logEl.innerText += ` get one card`;
            logEl.scrollTop = logEl.scrollHeight;
            nextTurn();   // 結束本回合
            return;       // 不要再往下做地產/拆地
          }


          // 🧯 fire2.png：先出題；答錯就清空所有森林地
          // fire2：森林地（用 askfireQuestion）
          if (imgNow.includes("fire2.png")) {
            handleOwnershipQuiz("fire2.png", "fire_station", "Forest", toIndex, askfireQuestion, () => {
              handleProperty(toIndex, () => nextTurn());
            });
            return;
          }
          // rain1：低窪地（用 askWaterBureauQuestion）
          if (imgNow.includes("rain1.png")) {
            handleOwnershipQuiz("rain1.png", "water_bureau", "Low Lying Land", toIndex, askWaterBureauQuestion, () => {
              handleProperty(toIndex, () => nextTurn());
            });
            return;
          }

          // earthquake3：高樓大廈（用 askMuseumQuestion）
          if (imgNow.includes("earthquake3.png")) {
            handleOwnershipQuiz("earthquake3.png", "museum921", "High Building", toIndex, askMuseumQuestion, () => {
              handleProperty(toIndex, () => nextTurn());
            });
            return;
          }



          // 原本流程end


          handleProperty(toIndex, () => {
            nextTurn();
          });
        });
      }





      if (cellImg.includes("event1.png") || cellImg.includes("event2.png")) {
        const randomEvent = eventList[Math.floor(Math.random() * eventList.length)];
        playerSteps[currentPlayer] = step;
        animateMove(currentPlayer, fromIndex, toIndex, () => {
          handleEventEffect(randomEvent, step);
        });
        return;
      }








      proceed();
    }

    function nextTurn() {
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      updateStatus();
    }



    function animateMove(playerIdx, fromCellIndex, toCellIndex, callback, direction = 1) {
      const token = playerTokens[playerIdx];
      if (!token) { callback && callback(); return; }

      const pathLen = pathIndices.length;

      // 取得「步數位置」：把 cellIndex 轉為 path 上的序號
      let curStep = pathIndices.indexOf(fromCellIndex);
      const targetStep = pathIndices.indexOf(toCellIndex);
      if (curStep === -1 || targetStep === -1) { // 安全防呆
        // 找不到就直接瞬移
        gameBoard.children[toCellIndex].appendChild(token);
        callback && callback();
        return;
      }

      // 每格停留時間（可自行調整速度）
      const STEP_DELAY = 180; // 毫秒
      const stepDir = (direction === -1 ? -1 : 1);
      // 逐格前進直到 targetStep
      function stepOnce() {
        if (curStep === targetStep) {
          // 走完
          callback && callback();
          return;
        }
        // 依方向走一格（可前進/後退，含環繞）
        curStep = (curStep + stepDir + pathLen) % pathLen;
        const nextCellIndex = pathIndices[curStep];

        // 將棋子放到下一格（不複製、不顯示分身 → 不會殘影）
        gameBoard.children[nextCellIndex].appendChild(token);

        // 繼續下一格
        setTimeout(stepOnce, STEP_DELAY);
      }

      // 從當前格開始走
      setTimeout(stepOnce, STEP_DELAY);
    }
    function checkScoreWin() {
      if (mode === "score") {
        for (let i = 0; i < nPlayers; i++) {
          if (playerScores[i] >= scoreTarget) {
            gameEnded = true;
            winnerIndex = i; // ← 標記贏家，讓記分板加上 .winner
            updateStatus();// ← 標記贏家，讓記分板加上 .winner
            //alert(`🎉 玩家 ${i + 1} 達到 ${scoreTarget} 分，獲勝！`);
            showGameOverScreen(`🎉 player ${i + 1} get ${scoreTarget} pts，WIN！`);
            clearInterval(timer);
            return true;
          }
        }
      }
      return false;
    }


    function updateStatus() {
      // 彩色卡片式記分板：顯示分數與技能卡數
      const carImgs = ["car_red.png", "car_blue.png", "car_green.png", "car_yellow.png"];
      const status = document.getElementById("status");
      const rawGoal = (document.getElementById('scoreTarget')?.value ?? (typeof config !== 'undefined' ? config.scoreTarget : 20));
      let goalScore = (() => {
        const n = parseInt(String(rawGoal).replace(/[^\d.-]/g, ''), 10);
        return Number.isFinite(n) && n > 0 ? n : 20;
      })();
      if (typeof config !== 'undefined' && config.mode === 'time') {
        goalScore = 50;   // OK：因為上面用 let
      }




      if (!status) return;

      let cards = "";
      for (let i = 0; i < nPlayers; i++) {
        const isActive = (i === currentPlayer);

        const isWinner = (winnerIndex === i);
        const cls = `score-card p${i + 1}${isActive ? " active" : ""}${isWinner ? " winner" : ""}`;
        const car = carImgs[i] || "car_red.png";
        const score = (Array.isArray(playerScores) && typeof playerScores[i] !== "undefined") ? playerScores[i] : 0;
        const skills = (Array.isArray(playerSkills) && typeof playerSkills[i] !== "undefined") ? playerSkills[i] : 0;
        const pausedBadge = (Array.isArray(skipTurn) && skipTurn[i]) ? `<span class="badge pause">Pause</span>` : ``;
        const skillIcons = Array.from({ length: skills },
          () => `<span class="scard"><img src="card2.png" alt="卡"></span>`
        ).join("");

        const pct = goalScore ? (playerScores[i] / goalScore) * 100 : 0;
        const isFull = playerScores[i] >= goalScore;
        const pctStr = isFull ? '100%' : `${Math.max(0, Math.min(100, pct)).toFixed(2)}%`;


        cards += `
      <div class="${cls}">
        <div class="left">
          <div class="player-avatar">
            <img class="token" src="${car}" alt="P${i + 1}">
            <div class="name">Player${i + 1}</div>
          </div>
        </div>
        <div class="right">
          <div class="score">${score}pts</div>
		  <div   class="goal"   title="目標 ${goalScore} 分"   role="progressbar"   aria-valuemin="0"   aria-valuemax="${goalScore}"   aria-valuenow="${score}" >
			<div class="bar${isFull ? ' full' : ''}" style="width:${pctStr}"></div>
		</div>
          <div class="badges">            
            <div class="skill-cards" aria-label="技能卡 ${skills} 張">${skillIcons}</div>${pausedBadge}
          </div>  
        </div>
      </div>`;
      }
      status.innerHTML = `<div class="score-grid">${cards}</div>`;
    }


    function showGameOverScreen(winnerText) {
      const over = document.getElementById('game-over');
      document.getElementById('winner-text').textContent = winnerText;
      over.classList.add('show');
    }

    function restartGame() {
      location.reload();  // 直接重整頁面
    }


    function log(msg) {
      logEl.innerText += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function logAction(player, dice, pos) {
      const log = document.getElementById("log");
      const stepNum = pathIndices.indexOf(pos) + 1;
      const imgSrc = mapData[pos] || "";
      const imgName = imgSrc.split('/').pop();
      //log.innerText += `player${player + 1} rolled ${dice}，move to ${stepNum} ${imgName}）`;
      log.innerText += ` move to ${stepNum} （${imgName}）`;
      log.scrollTop = log.scrollHeight;
      //alert("📢📢📢 ！");
    }

    function didCompleteLap(prevStep, newStep, pathLength) {
      return prevStep > newStep; // 代表繞過頭回到起點
    }




    function showEventCard(event, callback) {
      const card = document.getElementById("event-card-display");
      let skillBtnHtml = "";
      if (playerSkills[currentPlayer] > 0) {
        skillBtnHtml = `<button id="event-skill-btn">Used card</button>`;
      }
      card.innerHTML = `
    <h3>🎴 player${currentPlayer + 1}get event card</h3>
    <p>${event.desc}</p>
    <strong>➡ ${event.effect}</strong>
    <button id="event-ok-btn">ok</button>
    ${skillBtnHtml}
  `;
      card.classList.add("show");

      // 原本確認
      card.querySelector("#event-ok-btn").onclick = () => {
        hideEventCard();
        if (callback) callback();
      };
      // 有技能才有按鈕
      if (playerSkills[currentPlayer] > 0) {
        card.querySelector("#event-skill-btn").onclick = () => {
          alert("🎮 Used Event Card, this event had no effect！");
          if (passedStart) {
            playerScores[currentPlayer] += 1;

            //alert("🎉 完成一圈，加1分(這邊是套圈後  走到event的加分 然後用技能卡的)！");
            alert("🎉 Completed a lap! +1 point！");

            log.innerText += `\n🎯 player${currentPlayer + 1} Completed a lap! +1 point！`;
            passedStart = false;
            updateStatus();
            checkScoreWin();
          }
          playerSkills[currentPlayer]--;
          updateStatus();
          hideEventCard();
          // 跳過事件、換人

          logEl.innerText += ` event trigger：「${event.desc} ${event.effect}」，Used event card, no effect`;
          logEl.scrollTop = logEl.scrollHeight;
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;


          updateStatus();
        };
      }
    }

    function hideEventCard() {
      document.getElementById("event-card-display").classList.remove("show");
    }

    function getPropertyIndexesByKey(propKey, ownerFilter /* (ownerId)=>bool */ = null) {
      const arr = [];
      const total = 64; // 8x8 棋盤
      for (let i = 0; i < total; i++) {
        const key = propertyKeys[i] || getPropertyKey(mapData[i] || "");
        if (key === propKey) {
          const owner = (propertyOwners[i] ?? 0);
          if (!ownerFilter || ownerFilter(owner)) arr.push(i);
        }
      }
      return arr;
    }

    // 清空指定 ownerId 擁有的「某一種地產」(propKey) → 變回 *_0.png
    function clearPropertiesByOwner(propKey, ownerId) {
      if (ownerId == null) return;
      const targets = getPropertyIndexesByKey(propKey, o => (o === ownerId));
      targets.forEach(i => {
        propertyOwners[i] = 0;
        setTileImage(i, imageForOwner(propKey, 0)); // e.g. water_bureau_0.png
      });
      updateStatus();
    }

    // 共用：在指定觸發圖(tileName) 被踩到時，進行固定問答 & 依規則清空
    // 規則：
    //   若自己擁有該類地：  答錯 → 清自己；答對 → 保留
    //   若別人擁有該類地：答對 → 清別人；答錯 → 保留
    // 無人擁有則只提示。
    function handleOwnershipQuiz(tileName, propKey, propDisplayName, toIndex, askFunc, afterResolve) {
      const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");
      if (!imgNow.includes(tileName)) { afterResolve && afterResolve(); return; }

      askFunc(correct => {
        const me = currentPlayer + 1;
        const mine = getPropertyIndexesByKey(propKey, o => (o === me));            // 我的同類地
        const others = getPropertyIndexesByKey(propKey, o => (o > 0 && o !== me));    // 別人的同類地
        const otherOwnerIds = [...new Set(others.map(i => propertyOwners[i]))];       // 可能多位

        if (mine.length === 0 && others.length === 0) {
          alert(correct ? `you right，but no one has${propDisplayName}`
            : `you wrong，but no one has${propDisplayName}`);
          afterResolve && afterResolve();
          return;
        }

        if (correct) {
          // ✅ 答對：保留自己的、清掉所有其他人的
          if (otherOwnerIds.length > 0) {
            otherOwnerIds.forEach(oid => clearPropertiesByOwner(propKey, oid));
            logEl.innerText += `\n✅ you right，clear others${propDisplayName}`;
            logEl.scrollTop = logEl.scrollHeight;
          }
          alert(`you right：reserve own ${propDisplayName}，and clear others ${propDisplayName}`);
        } else {
          // ❌ 答錯：清掉自己的、其他人保留
          if (mine.length > 0) {
            clearPropertiesByOwner(propKey, me);
            logEl.innerText += `\n❌ you wrong，your${propDisplayName}clean`;
            logEl.scrollTop = logEl.scrollHeight;
          }
          alert(`you wrong：your${propDisplayName}clean，other player reserve`);
        }

        afterResolve && afterResolve();
      });
    }



    function askWaterBureauQuestion(onDone) {
      // onDone(true/false)
      const modal = document.createElement("div");
      Object.assign(modal.style, {
        position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
        display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
      });
      const box = document.createElement("div");
      Object.assign(box.style, {
        background: "#fff", padding: "20px", borderRadius: "10px",
        width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
      });
      const h3 = document.createElement("h3");
      h3.textContent = "Heavy rain warning time should be？";
      const opts = [
        { key: "1", text: "Stay in low places" },
        { key: "2", text: "Pay attention to weather conditions and avoid rivers" },// ✅ 正解
        { key: "3", text: "Go directly to see the sea" }
      ];
      box.appendChild(h3);
      opts.forEach(o => {
        const btn = document.createElement("button");
        btn.textContent = o.text;
        btn.classList.add('quiz-opt');
        Object.assign(btn.style, { display: "block", margin: "8px auto", padding: "8px 16px", cursor: "pointer" });
        btn.onclick = () => {
          const correct = (o.key === "2");
          document.body.removeChild(modal);
          onDone && onDone(correct);
        };
        box.appendChild(btn);

      });


      modal.appendChild(box);
      document.body.appendChild(modal);
    }



    function askMuseumQuestion(onDone) {
      // onDone(true/false)
      const modal = document.createElement("div");
      Object.assign(modal.style, {
        position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
        display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
      });
      const box = document.createElement("div");
      Object.assign(box.style, {
        background: "#fff", padding: "20px", borderRadius: "10px",
        width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
      });
      const h3 = document.createElement("h3");
      h3.textContent = "n which year did the 921 Taiwan earthquake occur?？";
      const opts = [
        { key: "1", text: "1998" },
        { key: "2", text: "1999" },// ✅ 正解
        { key: "3", text: "2000" }
      ];
      box.appendChild(h3);
      opts.forEach(o => {
        const btn = document.createElement("button");
        btn.textContent = o.text;
        btn.classList.add('quiz-opt');
        Object.assign(btn.style, { display: "block", margin: "8px auto", padding: "8px 16px", cursor: "pointer" });
        btn.onclick = () => {
          const correct = (o.key === "2");
          document.body.removeChild(modal);
          onDone && onDone(correct);
        };
        box.appendChild(btn);

      });


      modal.appendChild(box);
      document.body.appendChild(modal);
    }


    function askfireQuestion(onDone) {
      // onDone(true/false)
      const modal = document.createElement("div");
      Object.assign(modal.style, {
        position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
        display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
      });
      const box = document.createElement("div");
      Object.assign(box.style, {
        background: "#fff", padding: "20px", borderRadius: "10px",
        width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
      });
      const h3 = document.createElement("h3");
      h3.textContent = "What to do if you encounter thick smoke？";
      const opts = [
        { key: "1", text: "Cover your mouth and nose while moving forward" },// ✅ 正解
        { key: "2", text: "Look up, run, take the elevator and leave" },
        { key: "3", text: "Take the elevator to leave" }
      ];
      box.appendChild(h3);
      opts.forEach(o => {
        const btn = document.createElement("button");
        btn.textContent = o.text;
        btn.classList.add('quiz-opt');
        Object.assign(btn.style, { display: "block", margin: "8px auto", padding: "8px 16px", cursor: "pointer" });
        btn.onclick = () => {
          const correct = (o.key === "1");
          document.body.removeChild(modal);
          onDone && onDone(correct);
        };
        box.appendChild(btn);

      });


      modal.appendChild(box);
      document.body.appendChild(modal);
    }
    // 回傳所有森林地格的 index（可選擁有者過濾）
    function getFireStationIndexes(ownerFilter /*(ownerId)=>bool*/ = null) {
      const arr = [];
      for (let i = 0; i < mapData.length; i++) {
        const key = propertyKeys[i] || getPropertyKey(mapData[i] || "");
        if (key === 'fire_station') {
          if (!ownerFilter || ownerFilter(propertyOwners[i] ?? 0)) {
            arr.push(i);
          }
        }
      }
      return arr;
    }

    // 清空指定 owner 的森林地（ownerId: 1..4；若傳 null 代表不清空任何）
    // 會把該 owner 擁有的所有森林地變回 fire_station_0.png
    function clearFireStationsByOwner(ownerId) {
      if (ownerId == null) return;
      const targets = getFireStationIndexes(o => (o === ownerId));
      targets.forEach(i => {
        propertyOwners[i] = 0;
        setTileImage(i, imageForOwner('fire_station', 0)); // fire_station_0.png
      });
      updateStatus();
    }

    function getCellImageSrc(index) {
      const cell = gameBoard.children[index];
      const imgEl = cell ? cell.querySelector('img') : null;
      return imgEl ? imgEl.src : (mapData[index] || "");
    }
    // === 全域：地產處理（購買／過路費）===
    async function handleProperty(index, afterDone) {
      const imgSrc = getCellImageSrc(index);            // 用 DOM 讀圖
      const pKey = propertyKeys[index] || getPropertyKey(imgSrc);
      if (!pKey) {
        console.log('[PROP] not a property:', { index, imgSrc });
        afterDone && afterDone();
        return;
      }

      propertyKeys[index] = pKey;

      // owner 正規化：無人 → 0
      if (propertyOwners[index] == null) {
        const parsed = getOwnerFromImg(imgSrc);         // 0..4 或 null
        propertyOwners[index] = (parsed == null ? 0 : parsed);
      }

      const owner = propertyOwners[index];              // 0 | 1..4
      const me = currentPlayer + 1;
      const def = PROPERTY_DEFS[pKey];
      const price = def.buyPrice;
      const toll = def.toll;

      const name = def.display;

      console.log('[PROP] enter', { index, pKey, name, imgSrc, owner, me, price, myScore: playerScores[currentPlayer] });

      // 無人持有 → 詢問是否購買
      if (owner === 0) {
        if (playerScores[currentPlayer] >= price) {
          console.log('[PROP] ask to buy', { name, price, me });
          const yes = await showConfirm(`${name} price ${price} points。 Player ${me} want to buy？`);
          if (yes) {
            playerScores[currentPlayer] -= price;
            propertyOwners[index] = me;
            setTileImage(index, imageForOwner(pKey, me)); // 同步 mapData + DOM
            updateStatus(); // 先刷新計分板

            setTimeout(() => {
              logEl.innerText += `  ${price} buy「${name}」`;
              logEl.scrollTop = logEl.scrollHeight;
              afterDone && afterDone();
            }, 0);
            return;
          }
        } else {
          alert(`player${me} score not enough,can't buy「${name}」（need ${price} points）`);
			logEl.innerText += `score not enough,can't buy「${name}」（need ${price} points）`;
          logEl.scrollTop = logEl.scrollHeight;
        }
        afterDone && afterDone();
        return;
      }

      // === 已有人持有 → 付過路費或自己的地 ===
      if (owner !== me) {
        if (playerScores[currentPlayer] >= toll) {
          // 夠錢，正常付費
          playerScores[currentPlayer] -= toll;
          playerScores[owner - 1] += toll;
          updateStatus(); // 先刷新計分板

          setTimeout(() => {
            alert(`Player${me} pay「${name}」 ${toll} toll to player${owner}`);
        logEl.innerText += `\n💰 Player${me} 「${name}」pay ${toll} toll to player${owner}`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            afterDone && afterDone();
          }, 0);
          return;
        } else {
          // 不夠：把全部給對方（可依規則改）
          const all = playerScores[currentPlayer];
          playerScores[owner - 1] += all;
          playerScores[currentPlayer] = 0;
          updateStatus();

          setTimeout(() => {
            alert(`Player${me} score not enough，pay all ${all} to player${owner}`);
			logEl.innerText += `\n⚠️ Player${me} score not enough，pay all ${all} to player${owner}`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            afterDone && afterDone();
          }, 0);
          return;
        }
      }

      // 自己的地 → 沒事
      afterDone && afterDone();
    }



    function handleEventEffect(event, fromStep) {
      console.log("handleEventEffect");
      showEventCard(event, () => {
        const moveEffects = ["Advance 1 space", "Advance 2 spaces", "Move back 1 space", "Move back 2 spaces", "Return to start"];
		const log = document.getElementById("log");
        const lastRoll = lastDiceRoll[currentPlayer];
        log.innerText += `  Trigger Event：「${event.desc} ${event.effect}」`;
        log.scrollTop = log.scrollHeight;


        let newStep = playerSteps[currentPlayer];

        if (event.effect === "Advance 1 space") {
          newStep = (newStep + 1) % pathIndices.length;
        } else if (event.effect === "Advance 2 spaces") {
          newStep = (newStep + 2) % pathIndices.length;
        } else if (event.effect === "Move back 1 space") {
          newStep = (newStep - 1 + pathIndices.length) % pathIndices.length;
        } else if (event.effect === "Move back 2 spaces") {
          newStep = (newStep - 2 + pathIndices.length) % pathIndices.length;
        } else if (event.effect === "Return to start") {
          newStep = 0;
        }
        //logAction(currentPlayer, dice, newStep);
        if (event.effect === "Gain 2 points") {
          playerScores[currentPlayer] += 2;
          updateStatus();
          checkScoreWin();

        } else if (event.effect === "Gain 1 point") {
          playerScores[currentPlayer] += 1;
          updateStatus();
          checkScoreWin();
        } else if (event.effect === "Skip 1 turn") {
          skipTurn[currentPlayer] = true;
          // 直接換下一位玩家
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
          updateStatus();
          return; // 防止繼續執行後續程式
        }
        // 事件：回到起點 → 直接瞬移（不播放動畫）
        if (event.effect === "Return to start") {
          playerSteps[currentPlayer] = 0;
          renderPlayers();
          updateStatus();
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
          return;
        }

        const fromIndex = pathIndices[fromStep];
        const toIndex = pathIndices[newStep];
        // 決定動畫方向：退回 → 後退；其他 → 前進
        let animDir = (event.effect === "Move back 1 space" || event.effect === "Move back 2 spaces") ? -1 : 1;


        const imgNow = getCellImageSrc(toIndex);
        playerSteps[currentPlayer] = newStep;

        animateMove(currentPlayer, fromIndex, toIndex, () => {
          console.log("handleEventEffect_animateMove");
          updateStatus();
          const img = mapData[toIndex] || "";

          if (passedStart) {
            playerScores[currentPlayer] += 1;

            //alert("🎉 完成一圈，加1分(這邊是套圈後  走到event的加分  但如果是event連鎖前進是不加分的)！");

            log.innerText += `\n🎯 player${currentPlayer + 1} complete one lap ，add 1 point`;
            passedStart = false;
            updateStatus();
            alert("⚠complete one lap ，add 1 point");
            checkScoreWin();
          }
          // === 事件後的目的地特性判斷 ===
          // 1) 骰子格：再擲一次（不檢查地產）
          if (img.includes("dice.png")) {
            alert("🎲 Congratulations! You landed on a dice space and can roll again!");
            log.innerText += `\n🎯 Player${currentPlayer + 1} landed on a dice space and can roll again`;        
            setTimeout(() => {
              rollDice();
            }, 300);
            return;
          }
          //add
          // 2) 技能卡：拿卡（不檢查地產）
          if (img.includes("card2.png")) {
            playerSkills[currentPlayer]++;
            updateStatus();
            // proceed();
            alert(`🎴 Congratulations！Player${currentPlayer + 1} get 1 card，now card number is：${playerSkills[currentPlayer]} `);
            logEl.innerText += ` get 1 card`;
            logEl.scrollTop = logEl.scrollHeight;
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }
          if (img.includes("underdesk.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            // proceed();
            alert(`🎴 Congratulations!！Player${currentPlayer+1} add 5 points`);
            logEl.innerText += ` add 5 points`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }



          if (img.includes("bag1.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            // proceed();
            alert(`🎴 player ${currentPlayer + 1} add 5 points`);
            logEl.innerText += ` add 5 points`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }

          // 3) back：退回起點（不檢查地產）
          if (img.includes("back.png")) {
            alert("📢 back to home");
            log.innerText += ` player${currentPlayer + 1}，back to home`;
            playerSteps[currentPlayer] = 0;
            renderPlayers();                  // 立即重繪棋子位置
            updateStatus();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }
          //console.log(img, "quiz判斷");
          // 4) quiz：問答（不檢查地產）

          if (isQuizTileName(img)) {
            if (isAskingQuiz) return; // already asking, avoid double
            isAskingQuiz = true; // set guard

            let cat = null;
            if (img.includes("quiz_earthquake.png")) cat = "Earthquake Question";
            else if (img.includes("quiz_fire.png")) cat = "Fire Question";
            else if (img.includes("quiz_water.png")) cat = "Flood Question";

            const q = getRandomQuiz(cat);
            askQuiz(
              currentPlayer,
              () => { // 答對
                playerScores[currentPlayer] += 3;

                logEl.innerText += `   ${cat || "general"} right answer：「${q.question}」 add 3 points`;
                logEl.scrollTop = logEl.scrollHeight;
                updateStatus(); // 更新分數顯示
                checkScoreWin();
                isAskingQuiz = false; // release guard
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
              },
              () => { // 答錯
                isAskingQuiz = false; // release guard
                logEl.innerText += `   ${cat || "general"} wrong answer：「${q.question}」 `;
                logEl.scrollTop = logEl.scrollHeight;
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
              },
              q // 指定題目
            );
            return;
          }
          // 5) 拆地：問答（不檢查地產）
          // fire2：森林地（用 askfireQuestion）
          if (imgNow.includes("fire2.png")) {
            handleOwnershipQuiz("fire2.png", "fire_station", "Forest", toIndex, askfireQuestion, () => {
              const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
              if (pKeyAfterEvent) {
                handleProperty(toIndex, () => {
                  currentPlayer = (currentPlayer + 1) % nPlayers;
                  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                  updateStatus();
                });
              } else {
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                updateStatus();
              }
            });
            return;
          }

          // rain1：低窪地（用 askWaterBureauQuestion）
          if (imgNow.includes("rain1.png")) {
            handleOwnershipQuiz("rain1.png", "water_bureau", "Low Lying Land", toIndex, askWaterBureauQuestion, () => {
              const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
              if (pKeyAfterEvent) {
                handleProperty(toIndex, () => {
                  currentPlayer = (currentPlayer + 1) % nPlayers;
                  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                  updateStatus();
                });
              } else {
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                updateStatus();
              }
            });
            return;
          }

          // earthquake3：高樓大廈（用 askMuseumQuestion）
          if (imgNow.includes("earthquake3.png")) {
            handleOwnershipQuiz("earthquake3.png", "museum921", "High Building", toIndex, askMuseumQuestion, () => {
              const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
              if (pKeyAfterEvent) {
                handleProperty(toIndex, () => {
                  currentPlayer = (currentPlayer + 1) % nPlayers;
                  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                  updateStatus();
                });
              } else {
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                updateStatus();
              }
            });
            return;
          }





          // 5) 若 landing 是事件格，且本次事件是「位移型事件」，做事件連鎖（不檢查地產）
          if ((img.includes("event1.png") || img.includes("event2.png")) && moveEffects.includes(event.effect)) {
            //alert("Event Chain");
            const nextEvent = eventList[Math.floor(Math.random() * eventList.length)];
            setTimeout(() => {
              handleEventEffect(nextEvent, newStep);
            }, 200);
            return;
          }
          // 6) 以上皆非 → 在這裡檢查地產（買地／收費），處理完才換人
          const imgSrcNow = getCellImageSrc(toIndex);
          console.log('LAND after event:', toIndex, imgSrcNow, 'cachedKey=', propertyKeys[toIndex]);

          const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(imgSrcNow);
          if (pKeyAfterEvent) {
            handleProperty(toIndex, () => {
              currentPlayer = (currentPlayer + 1) % nPlayers;
              document.getElementById("currentPlayer").textContent = currentPlayer + 1;
              updateStatus();
            });
          } else {
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            updateStatus();
          }
        }, animDir);
      });
    }
    document.addEventListener('keydown', function (e) {
      if ((e.code === "Space" || e.key === " ") && !gameEnded) {
        e.preventDefault();
        rollDice();
      }
    });

function showConfirm(msg, { okText = "Ok", cancelText = "Cancel" } = {}) {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.className = "dm-overlay";
    const box = document.createElement("div");
    box.className = "dm-box";
    const p = document.createElement("div");
    p.textContent = msg;
    const actions = document.createElement("div");
    actions.className = "dm-actions";
    const btnCancel = document.createElement("button");
    btnCancel.className = "dm-btn cancel";
    btnCancel.textContent = cancelText;
    const btnOk = document.createElement("button");
    btnOk.className = "dm-btn ok";
    btnOk.textContent = okText;

    btnCancel.onclick = () => { document.body.removeChild(overlay); resolve(false); };
    btnOk.onclick = () => { document.body.removeChild(overlay); resolve(true); };
    overlay.onclick = (e) => { if (e.target === overlay) btnCancel.onclick(); }; // 點遮罩取消
    actions.append(btnCancel, btnOk);
    box.append(p, actions);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
  });
}
// ----- 自訂 ALERT（位置可控、外觀與 confirm 一致）-----
function showAlert(message, { okText = "確認" } = {}) {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.className = "dm-overlay";          // ← 用你已存在的樣式
    const box = document.createElement("div");
    box.className = "dm-box";

    const content = document.createElement("div");
    content.textContent = String(message);

    const actions = document.createElement("div");
    actions.className = "dm-actions";
    const btnOk = document.createElement("button");
    btnOk.className = "dm-btn ok";
    btnOk.textContent = okText;

    btnOk.onclick = () => { document.body.removeChild(overlay); resolve(); };
    overlay.onclick = (e) => { if (e.target === overlay) btnOk.onclick(); }; // 點遮罩＝關閉

    actions.appendChild(btnOk);
    box.append(content, actions);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
  });
}

// 全域覆寫 alert：之後呼叫 alert("訊息") 會顯示在相同位置
// 備註：這是非阻塞的。若你想等待使用者按「好」再繼續，請在呼叫處用 `await alert("...")`。
window.alert = (msg) => showAlert(msg);
  </script>
  </div>
</body>

</html>