<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Disaster Monopoly</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0.5rem;
      display: flex;
    }
:root{
 
  --cell: min(90px, calc((100vw - 40px) / 8));
}

    #left-panel {
      flex: 1;
    }

    #right-panel {
      
      margin-left: 10px;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(8, var(--cell));      
      grid-template-rows: repeat(8, var(--cell));     
      gap: 2px;
	  width:100%;
  max-width: calc(var(--cell)*8 + 14px);
  margin:0 auto;
    }




    .cell {
	
	 width:var(--cell) !important;
  height:var(--cell) !important;      
      
      border: 1px solid #aaa;
      position: relative;
      background: white;
    }

    .cell img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      position: absolute;
      top: 0;
      left: 0;
    }

    .order-number {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.7);
      padding: 1px 3px;
      border-radius: 4px;
    }

    .player {
      width: 50px;
      height: 50px;
      position: absolute;
      z-index: 5;
    }

    .player1 {
      top: 4px;
      left: 4px;
    }

    .player2 {
      top: 4px;
      right: 4px;
    }

    .player3 {
      bottom: 4px;
      left: 4px;
    }

    .player4 {
      bottom: 4px;
      right: 4px;
    }

    .player img {
      width: 100%;
      height: 100%;
    }

    #log {

      white-space: pre-line;
      font-size: 14px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      padding: 6px;
      max-height: 1000px;
      overflow-y: auto;

    }

    #configInfo {
      
      background: #dceeff !important;       /* æ·ºè—åº•ï¼Œå¯æ”¹æˆ #eaf5ff */
  color: #111 !important;
  border: 2.5px solid #111 !important;  /* ç²—é»‘é‚Š */
  border-radius: 16px !important;       /* è† å›Šåœ“è§’ */
  padding: 8px 14px !important;
  font-weight: 700 !important;
  box-shadow: 0 4px 0 #111 !important;  /* å¯¦å¿ƒä¸‹å½± */
      
    }

    #event-card-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 280px;
      height: 380px;
      background: white;
      border: 2px solid #444;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 9999;
      padding: 20px;
      animation: fadeIn 0.4s ease;
    }

    #event-card-display.show {
      display: flex;
    }

    .game-map-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }




    .game-map-tooltip {
      visibility: hidden;
      opacity: 0;
      width: max-content;
      max-width: 140px;
      background: #333;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 2px 2px;
      z-index: 10;
      bottom: 100%;
      left: 50%;

      font-size: 12px;
      pointer-events: none;
      white-space: pre-line;
      transition: opacity 0.3s;
    }

    .game-map-wrapper:hover .game-map-tooltip {
      visibility: visible;
      opacity: 1;
    }

    #game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: linear-gradient(135deg, #ff5f6d, #ffc371);
      color: white;
      border: 4px solid #fff;
      border-radius: 15px;
      padding: 30px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      z-index: 10000;
      transition: transform 0.5s ease, opacity 0.5s ease;
      opacity: 0;
    }

    #game-over.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    #game-over h1 {
      font-size: 2.5em;
      margin-bottom: 20px;
    }

    #game-over button {
      background: white;
      color: #ff5f6d;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s, transform 0.3s;
    }

    #game-over button:hover {
      background: #ffe0e6;
      transform: scale(1.1);
    }

    #quiz-history {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: #fff;
      color: #333;
      border: 3px solid #ccc;
      border-radius: 10px;
      padding: 20px;
      text-align: left;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      z-index: 10001;
      width: 400px;
      max-height: 70%;
      overflow-y: auto;
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }

    #quiz-history.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    #quiz-history h2 {
      text-align: center;
    }

    #roll-dice-btn {
      background: linear-gradient(135deg, #ff7e5f, #feb47b);
      border: none;
      color: white;
      padding: 2px 2px;
      font-size: 20px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      letter-spacing: 1px;
    }

    #roll-dice-btn:hover {
      background: linear-gradient(135deg, #feb47b, #ff7e5f);
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    #roll-dice-btn:active {
      transform: translateY(0) scale(0.98);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    /* ==== Scoreboard (ç¾åŒ–) ==== */
    #status {
      margin: 12px 0;
    }

    .score-grid {
      display: grid;
      grid-auto-flow: column;
      /* å–®åˆ—æ’åˆ— */
      grid-auto-columns: 1fr;
      /* æ¯å¼µå¡ç‰‡ç­‰åˆ†å®¹å™¨å¯¬åº¦ */
      gap: 12px;
      padding: 6px 4px;
      overflow: hidden;
      /* ä¸è¦æ²è»¸ */
    }

    .score-card {
      --accent: #e0e0e0;
      height: 80px;
      --bg: rgba(0, 0, 0, .03);
      background: #fff;
      border: 2px solid var(--accent);
      border-radius: 14px;
      padding: 2px 12px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      /* ä¸å†æŠŠå·¦å³æ‹‰åˆ°å…©ç«¯ */
      position: relative;
      gap: 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, .06);
      grid-template-columns: 120px 1fr auto;
	  
	  
	  
	  
	  
	  

    }

    @media (max-width: 900px) {
      .score-card {
        grid-template-columns: 100px 1fr auto;
      }
    }

    .player-avatar {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .player-avatar .token {
      width: 36px;
      height: 36px;
      object-fit: contain
    }

    .player-avatar .name {
      font-weight: 800;
      letter-spacing: .4px;
      line-height: 1.1
    }

    .score-card .left {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .score-card .right {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      flex: 1;
    }

    .score {
      font-size: 22px;
      font-weight: 800
    }

    .badges {
      display: flex;
      gap: 6px
    }

    .badge.pause {
      border-style: dashed;
      opacity: .9
    }

    .badge {
      font-size: 12px;
      border: 1px solid var(--accent);
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--bg)
    }

    .score-card.active {
      box-shadow:
        0 0 0 6px rgba(var(--accent-rgb, 0, 0, 0), .45),
        0 10px 24px rgba(0, 0, 0, .18);
      transform: translateY(-1px);
    }

    /* Colors: P1ç´… / P2è— / P3ç¶  / P4ç´… */
    .score-card.p1 {
      --accent: #e74c3c;
      --accent-rgb: 231, 76, 60;
    }

    .score-card.p2 {
      --accent: #3498db;
      --accent-rgb: 52, 152, 219;
    }

    .score-card.p3 {
      --accent: #2ecc71;
      --accent-rgb: 46, 204, 113;
    }

    .score-card.p4 {
      --accent: #f1c40f;
      --accent-rgb: 241, 196, 15;
    }

    .skill-cards {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      min-height: 28px;
    }

    .skill-cards .scard {
      width: 22px;
      height: 22px;
      padding: 1px;
      border: 1px solid var(--accent);
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .15);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .skill-cards .scard img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .goal {
      width: 60px;
      /* â† é€²åº¦æ¢åº•é•·åº¦å›ºå®š */
      height: 8px;
      border-radius: 999px;
      background: #eef1f6;
      /* åº•è‰² */
      overflow: hidden;
      position: relative;
    }

    .goal .bar {
      height: 100%;
      width: 0%;
      /* ç”± JS ä»¥ç™¾åˆ†æ¯”è¨­å®š */
      background: linear-gradient(90deg, var(--accent, #888), rgba(0, 0, 0, .15));
      transition: width .35s ease;
    }

    .goal {
      width: 80px;
      height: 8px;
      border-radius: 999px;
      background: #eef1f6;
      overflow: hidden;
      position: relative;
    }

    .goal .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent, #888), rgba(0, 0, 0, .15));
      transition: width .35s ease;
    }

    /* ç›®æ¨™é”æˆæ™‚ç”¨å¯¦è‰²ï¼Œå³ç·£çœ‹èµ·ä¾†æ‰æœƒã€ŒçœŸçš„æ»¿ã€ */
    .goal .bar.full {
      background: var(--accent, #888);
    }

    .score-card.winner::after {
      content: "ğŸ‘‘";
      position: absolute;
      top: -12px;
      right: -12px;
      font-size: 32px;
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, .25));
    }

    .quiz-opt {
      display: block;
      width: 80%;
      /* å›ºå®šå¯¬åº¦ã€‚æƒ³åƒæ»¿å®¹å™¨å°±æ”¹æˆ 100% */
      max-width: 100%;
      margin: 8px auto;
      box-sizing: border-box;
      text-align: left;
    }/* è®“åœ°åœ–å¯ç¸®æ”¾ï¼ˆè‹¥ä½ å·²åŠ éå¯ç•¥éï¼‰ */
/* ==== 1) æŸ”æ€§æ ¼å¯¬ï¼ˆè·Ÿ editor ä¸€æ¨£ï¼‰==== */
:root{
  --cell: min(90px, calc((100vw - 32px) / 8));
}
@media (max-width:480px){
  :root{ --cell: min(72px, calc((100vw - 24px) / 8)); }
}

/* ==== 2) å¤–å±¤å…è¨±æ›è¡Œï¼ˆå·¦å³æ¬„æ”¹ä¸Šä¸‹å †ï¼‰==== */
body{ flex-wrap: wrap; gap: 20px; box-sizing: border-box; }

/* ==== 3) ç‰ˆé¢é †åºï¼šå·¦(é ‚éƒ¨) â†’ æ£‹ç›¤ â†’ å³(Recordæœ€åº•) ==== */
@media (max-width: 768px){
  #left-panel{ order:1; flex:1 1 100%; width:100%; min-width:0; }
  
  #game-board, #board-wrap, #center-panel, #game-frame{ order:2; width:100%; max-width:100%; margin:0 auto; }
  #right-panel{ order:3; flex:1 1 100%; width:100%; min-width:0; }
}

/* ==== 4) å–æ¶ˆå³æ¬„æ­»å¯¬ï¼Œæ¡Œæ©Ÿä»èƒ½ä½”ä½ ==== */
#right-panel{
  width: auto !important;           /* è¦†è“‹ 750px */
  flex: 1 1 360px;
  margin-left: 10px;
}

/* ==== 5) è¨˜åˆ†æ¿/è¨­å®šæ»¿ç‰ˆï¼ˆè¦†è“‹ 720px èˆŠå€¼èˆ‡ inline styleï¼‰==== */
#configInfo, fieldset, .scoreboard, .status-card, .player-card, .controls, .card, .panel{
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box;
}

/* ==== 6) æ£‹ç›¤ç”¨è®Šæ•¸æ ¼å¯¬ï¼Œè€Œä¸æ˜¯ 90px ==== */
#game-board{
  display: grid;
  grid-template-columns: repeat(8, var(--cell)) !important;
  grid-template-rows:    repeat(8, var(--cell)) !important;
  gap: 2px;
  width: 100%;
  max-width: calc(var(--cell) * 8 + 14px);
  margin: 0 auto;
}
#game-board .cell{
  width: var(--cell) !important;
  height: var(--cell) !important;
}
#game-board .cell img{ max-width:100%; max-height:100%; object-fit:contain; }
#configInfo, fieldset, .scoreboard, .status-card, .player-card, .controls, .card, .panel{
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box;
}


@media (max-width:768px){
  #log{ max-height: 40vh; overflow:auto; }
}
@media (max-width: 768px){
  body > div:first-of-type{
    flex-wrap: wrap !important;    
    width: 100%;
  }
}

.dm-overlay{
  position: fixed; inset: 0;
  background: rgba(0,0,0,.55);
  display: flex; justify-content: center; align-items: center;
  z-index: 99999;
  padding: 16px;
}
.dm-box{
  width: min(90vw, 420px);
  background: #fff; border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.3);
  padding: 16px 16px 12px;
  font-size: 18px; line-height: 1.5;
}
.dm-actions{
  display: flex; justify-content: flex-end; gap: 12px; margin-top: 12px;
}
.dm-btn{ border: 0; background: none; font-size: 18px; padding: 6px 10px; }
.dm-btn.ok{ color: #1a73e8; font-weight: 700; }
.dm-btn.cancel{ color: #666; }


  .dm-overlay{ align-items: flex-start; }
  .dm-box{ margin-top: calc(12vh + env(safe-area-inset-top, 0px)); }

.dm-actions{
  display:flex;
  justify-content:flex-end;
  gap:12px;
  margin-top:12px;
}

/* å…±ç”¨æŒ‰éˆ•æ¨£å¼ */
.dm-btn{
  -webkit-appearance:none;
  appearance:none;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:10px 16px;              /* é»æ“Šå€å¤§ä¸€é» */
  min-height:40px;
  border-radius:10px;
  border:1px solid transparent;
  font-size:16px;
  font-weight:600;
  cursor:pointer;
  user-select:none;
  transition:transform .02s ease, box-shadow .15s ease, background-color .15s ease, border-color .15s ease;
  box-shadow:0 1px 2px rgba(0,0,0,.05);
}

/* ä¸»è¦æŒ‰éˆ•ï¼šç¢ºå®š/å¥½ */
.dm-btn.ok{
  background:#1a73e8;             /* Google è— */
  border-color:#1a73e8;
  color:#fff;
}
.dm-btn.ok:hover{ filter:brightness(.97); }
.dm-btn.ok:active{ transform:translateY(1px); filter:brightness(.94); }

/* æ¬¡è¦æŒ‰éˆ•ï¼šå–æ¶ˆ */
.dm-btn.cancel{
  background:#f3f4f6;             /* æ·ºç° */
  border-color:#e5e7eb;
  color:#374151;                   /* æ·±ç°å­— */
}
.dm-btn.cancel:hover{ background:#e5e7eb; }
.dm-btn.cancel:active{ transform:translateY(1px); }

/* éµç›¤å¯åŠæ€§ */
.dm-btn:focus-visible{
  outline:2px solid #2563eb;
  outline-offset:2px;
}

/* æ‰‹æ©Ÿï¼šæŒ‰éˆ•æ›´å¥½æŒ‰ï¼Œå·¦å³å¹³å‡å¯¬ï¼ˆå¯ä¾å–œå¥½ä¿ç•™æˆ–åˆªé™¤ï¼‰ */
@media (max-width:768px){
  .dm-actions{ justify-content:stretch; }
  .dm-btn{ flex:1 1 0; min-height:44px; }
}



  </style>
  
  
   <style>
  body {
  background:
    radial-gradient(circle at 10px 10px, rgba(0,0,0,0.05) 1.2px, transparent 1.3px) 0 0 / 14px 14px,
    linear-gradient(180deg, #fffbe8, #fff4c9 60%, #ffeeb5 100%);
}
/* 1) æ“²éª°æŒ‰éˆ•ï¼šé»ƒè‰²è† å›Šï¼‹ç²—é»‘é‚Šï¼‹å¯¦å¿ƒä¸‹å½± */
#roll-dice-btn{
  background:#ffd400 !important;
  color:#111 !important;
  border:2px solid #111 !important;
  border-radius:16px !important;
  padding:6px 14px !important;
  font-weight:900 !important;
  letter-spacing:.5px !important;
  box-shadow:0 4px 0 #111 !important;  /* æ¼«ç•«å¼å¯¦å¿ƒå½± */
}
#roll-dice-btn:hover{
  transform:translateY(-1px) !important;
  box-shadow:0 6px 0 #111 !important;
}
#roll-dice-btn:active{
  transform:translateY(1px) !important;
  box-shadow:0 2px 0 #111 !important;
}

/* 2) ç´€éŒ„æ¡†ï¼šç™½åº•ã€åœ“è§’ã€ç²—é»‘é‚Šã€å¯¦å¿ƒä¸‹å½± */
#log{
  background:#ffffff !important;
  border:2px solid #111 !important;
  border-radius:16px !important;
  box-shadow:0 3px 0 #111 !important;
  padding:12px 16px !important;
  font-size:16px !important;
  line-height:1.6 !important;
}

/* 3) è·¯å¾‘é †åºæ•¸å­—ï¼šç™½è‰²åœ“é»ï¼‹ç²—é»‘é‚Šï¼‹ç²—é«”å­— */
.order-number{
  background:#fff !important;
  color:#111 !important;
  border:2px solid #111 !important;
  border-radius:999px !important;
  padding:1px 3px !important;
  font-weight:900 !important;
  font-size:10px !important;
  box-shadow:0 1px 0 #111 !important; /* æ¼«ç•«å¼å¯¦å¿ƒå½± */
}



/* åšåº¦æŠ•å½±ï¼šè®“æ¯æ ¼çœ‹èµ·ä¾†ã€Œæœ‰åšåº¦ã€è€Œä¸æ˜¯åªæœ‰å¤–æ¡† */
#game-board .cell::after{
  content:"";
  position:absolute; inset:0;
  border-radius:12px;
  transform: translateY(2px);     /* åšåº¦é«˜åº¦ï¼›æƒ³è–„ä¸€é»æ”¹ 3px */
  background: rgba(0,0,0,.06);    /* åšåº¦çš„æš—é¢ */
  filter: blur(0.3px);
  z-index:-1;
}

/* æ»‘éå¾®å½ˆè·³ï¼Œæ›´æœ‰ç«‹é«”æ„Ÿï¼ˆä¸åš3Då‚¾æ–œï¼‰ */
#game-board .cell:hover{
  transform: translateY(-2px);
  box-shadow:
    inset 0 2px 0 rgba(255,255,255,.85),
    inset 0 -3px 0 rgba(0,0,0,.08),
    0 3px 0 #111;
}

/* åœ–ç‰‡ç¶­æŒä¹¾æ·¨ï¼šç„¡å¤–æ¡†/é™°å½± */
#game-board .cell img{
transform: scale(0.95);
  transform-origin: center center;
  border:none !important;
  box-shadow:none !important;
  filter:none !important;
}

.dice-override-group {
    /* ç§»é™¤é‚Šæ¡†å’Œå…§è·ï¼Œè®“å®ƒèå…¥èƒŒæ™¯ */
    border: none !important; 
    padding: 0 !important;
    margin-top: 10px; /* ä¿æŒèˆ‡ä¸Šæ–¹å…ƒç´ çš„é–“è· */
}

/* æ¨™é¡Œæ–‡å­— (Legend) */
.dice-override-group legend {
    color: #888; /* å°‡æ¨™é¡Œæ–‡å­—é¡è‰²èª¿æš— */
    font-size: 0.9em;
    padding: 0;
    margin-bottom: 5px;
}

/* æ¯å€‹é¸é …çš„æ–‡å­— */
.dice-override-group label {
    color: #FFF0AC; /* ä¿æŒå¯è®€æ€§ */
    display: inline-block;
    margin-right: 12px !important; /* ä¿®æ­£é–“è· */
    font-size: 0.95em;
}

/* ç¢ºä¿ Radio æŒ‰éˆ•æ˜¯ä½èª¿çš„é¡è‰² */
.dice-override-group input[type="radio"] {
  transform: scale(0.9);    /* é»é»ç¸®å° */
  margin-right: 2px;
  accent-color: #FFF0AC;       /* é»é¸é¡è‰²è®Šç° */
  opacity: 0.6;
}


</style>
  
  
</head>

<body>
<div style="display: flex; align-items: flex-start; gap: 20px; width: 100%; min-height: 100vh; box-sizing: border-box;">
  <div id="left-panel">
  <div id="topbar">
  <!-- è¨˜åˆ†æ¿èˆ‡è¨­å®šåŸæœ¬çš„é‚£äº›å…ƒç´ æ”¾é€™è£¡ -->
<!--<input id="apikey" type="text" style="width: 80%;" placeholder="è²¼ä¸Šä½ çš„ API Key">
<button onclick="makeQuiz()">å‡ºä¸€é¡Œç«ç½é˜²ç½é¡Œç›®</button>
<pre id="output">(å°šæœªå‡ºé¡Œ)</pre>-->
    <div id="configInfo"></div>
    <div id="status" style="margin: 10px 0;"></div>
    <div>
      <button id="roll-dice-btn" onclick="rollDice()">ğŸ² Player <span id="currentPlayer">1</span></button>

      Previous Player<span id="people">-</span> rolled <span id="diceResult">-</span>

<fieldset class="dice-override-group">
Â  Â  Â 
<!--<legend>ğŸ¯ æŒ‡å®šéª°å­é»æ•¸ï¼ˆä½œå¼Šç”¨ï¼‰</legend>!-->
Â  Â  Â  <label><input type="radio" name="diceOverride" value="0" checked> random</label>
Â  Â  Â  <label><input type="radio" name="diceOverride" value="1"> 1</label>
Â  Â  Â  <label><input type="radio" name="diceOverride" value="2"> 2</label>
Â  Â  Â  <label><input type="radio" name="diceOverride" value="3"> 3</label>
Â  Â  Â  <label><input type="radio" name="diceOverride" value="4"> 4</label>
Â  Â  Â  <label><input type="radio" name="diceOverride" value="5"> 5</label>
Â  Â  Â  <label><input type="radio" name="diceOverride" value="6"> 6</label>
</fieldset>



    </div>
    
	
	</div>
    <div id="game-board"></div>


  </div>
  <div id="right-panel">

    <div id="event-card-display"></div>

    <!-- <h2 >ğŸ¥ å±•ç¤ºå½±ç‰‡</h2><video id="demoVideo" controls width="200" style="border-radius:8px; ">
  <source src="v1.mp4" type="video/mp4">
  æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ HTML5 å½±ç‰‡ã€‚
</video>
-->
    <h2>ğŸ²Record</h2>
    <div id="log"></div>

  </div>
  <div id="game-over" class="hidden">
    <h1>ğŸ† Game Over ğŸ†</h1>
    <p id="winner-text"></p>
    <button onclick="restartGame()">Restart</button>
    <button onclick="showQuizHistory()">View Quiz History</button>
    <button onclick="closeGameOver()">âŒ Close</button>
  </div>
  <!-- é¡¯ç¤ºç­”é¡Œè¨˜éŒ„çš„å€å¡Š -->
  <div id="quiz-history" class="hidden">
    <h2>ğŸ“š Quiz History</h2>
    <div id="quiz-list"></div>
    <button onclick="closeQuizHistory()">Close</button>
  </div>

  <audio id="diceSound" src="dice-sound.mp3" preload="auto"></audio>
  <script>


    let config = {};
    try { config = JSON.parse(localStorage.getItem("gameConfig") || '{}'); } catch (e) { config = {}; }
	const USE_AI_QUIZ = !!(config.settings && config.settings.useAIQuiz);


    // ---- é è¨­åœ°åœ–ï¼ˆç•¶æœªè¼‰å…¥ä»»ä½•åœ°åœ–è¨­å®šæ™‚å•Ÿç”¨ï¼‰----

    function __buildDefaultMap() {
      // å¤–åœˆè·¯å¾‘ï¼ˆ8x8ï¼‰ï¼šä¸Šâ†’å³â†’ä¸‹â†’å·¦ï¼ˆå…± 28 æ ¼ï¼‰


      // ä½¿ç”¨ä½ æä¾›çš„ map1 é™£åˆ—èªæ³•ï¼ˆåªæ”¾ç½®æœ‰å…§å®¹çš„æ ¼å­ï¼‰
      const map1 = [
        { index: 0, img: 'start.png' },
        { index: 1, img: 'fire_station_0.png' },
        { index: 2, img: 'dice.png' },
        { index: 3, img: 'bag1.png' },
        { index: 4, img: 'museum921_0.png' },
        { index: 5, img: 'ok1.png' },
        { index: 6, img: 'event1.png' },
        { index: 7, img: 'quiz_water.png' },
        { index: 15, img: 'underdesk.png' },
        { index: 23, img: 'water_bureau_0.png' },
        { index: 31, img: 'light.png' },
        { index: 39, img: 'back.png' },
        { index: 38, img: 'ok3.png' },
        { index: 37, img: 'card2.png' },
        { index: 29, img: 'fire_station_0.png' },
        { index: 21, img: 'ok2.png' },
        { index: 20, img: 'rain1.png' },
        { index: 19, img: 'quiz_earthquake.png' },
        { index: 27, img: 'fire2.png' },
        { index: 35, img: 'dice.png' },
        { index: 34, img: 'quiz_water.png' },
        { index: 33, img: 'event1.png' },
        { index: 32, img: 'fire_station_0.png' },
        { index: 24, img: 'earthquake3.png' },
        { index: 17, img: 'rain1.png' },
        { index: 8, img: 'quiz_fire.png' },
      ];

      // è½‰æˆéŠæˆ²ç”¨çš„ mapData çµæ§‹ï¼ˆindex -> imgï¼‰
      const map = {};


      for (const { index, img } of map1) {
        if (Number.isInteger(index) && typeof img === 'string') {
          map[index] = img;
        }
      }

      const seen = new Set();
      const ring = [];
      for (const { index } of map1) {
        if (Number.isInteger(index) && !seen.has(index)) {
          seen.add(index);
          ring.push(index);
        }
      }
      return { ring, map };
    }
function catNameTC(cat){
  return cat === "fire" ? "Fire"
       : cat === "water" ? "Flood"
       : cat === "earthquake" ? "Earthquake"
       : "ä¸€èˆ¬";
}

    function __isValidConfig(cfg) {
      const okPath = Array.isArray(cfg?.pathIndices)
        && cfg.pathIndices.length > 0
        && cfg.pathIndices.every(n => Number.isInteger(n) && n >= 0 && n < 64);

      const okMap = cfg?.mapData && Object.keys(cfg.mapData).length > 0;

      return okPath && okMap;
    }

    // è‹¥æ²’æœ‰åœ°åœ–ï¼ˆpathIndices æˆ– mapData çš†å¯ä½œç‚ºåˆ¤æ–·ï¼‰â†’ å¥—ç”¨é è¨­
    (function __ensureDefaults() {
      if (!__isValidConfig(config)) {
        const { ring, map } = __buildDefaultMap();
        config.pathIndices = ring;
        config.mapData = map;
        config.mode = config.mode || "score";
        config.scoreTarget = config.scoreTarget || 20;
        config.timeLimit = config.timeLimit || 120;
        config.playerCount = config.playerCount || 2;
      }
    })();


    const { mode, timeLimit, scoreTarget, playerCount, mapData, pathIndices } = config;
    const nPlayers = config.playerCount || 2;
    document.getElementById("configInfo").innerText =
      mode === "time"
        ? `ğŸ¯ Mode: Timeï¼ˆ${timeLimit} secï¼‰`
        : `ğŸ¯ Mode: Scoreï¼ˆ${scoreTarget} ptsï¼‰`;
		document.getElementById("configInfo").innerText += USE_AI_QUIZ
  ? " ï½œğŸ¤– Question Mode: AI-generated"
  : " ï½œğŸ“˜ Question Mode: Question Bank";
    const gameBoard = document.getElementById("game-board");
    const logEl = document.getElementById("log");
    document.getElementById("configInfo").innerText = "Disaster Monopoly â€”" + document.getElementById("configInfo").innerText;
    console.log(config);

    let playerSteps = new Array(nPlayers).fill(0);
    let playerScores = new Array(nPlayers).fill(10);
    let playerSkills = new Array(nPlayers).fill(1); // æ¯äººåˆå§‹1æŠ€èƒ½å¡
    let skipTurn = new Array(nPlayers).fill(false);
    let lastDiceRoll = new Array(nPlayers).fill(0);
    let playerTokens = new Array(nPlayers).fill(null);
    let currentPlayer = 0;

    let gameEnded = false;
    let winnerIndex = null;
    let timer = null;
    let timeLeft = timeLimit;
	let timerPaused = false;  // aiå‡ºé¡Œæ™‚é–“æš«åœ
	
	function tickTimer() {
  timeLeft--;
  const configInfo = document.getElementById("configInfo");
  configInfo.textContent = `Time modeï¼šremaining ${timeLeft} sec `;
  if (timeLeft <= 0) {
    clearInterval(timer);
    timer = null;
    gameEnded = true;
    // ï¼ˆä»¥ä¸‹ç¶­æŒä½ åŸæœ¬çµæŸçµç®—çš„ç¨‹å¼ç¢¼ï¼‰
    const maxScore = Math.max(...playerScores);
    const winners = [];
    for (let i = 0; i < playerScores.length; i++) {
      if (playerScores[i] === maxScore) winners.push(i + 1);
    }
    if (winners.length === 1) {
      alert(`âŒ› Time's up! Player ${winners[0]} wins with ${maxScore} pts`).then(()=>{
        winnerIndex = winners[0] - 1;
        updateStatus();
        showGameOverScreen(`âŒ›  Time's up! Player ${winners[0]} wins with ${maxScore} pts`);
      });
    } else {
      alert(`âŒ› Time's up!ğŸ¤ Draw! Player ${winners.join("ã€")} tie at ${maxScore} pts`).then(()=>{
        showGameOverScreen(`âŒ› Time's up!ğŸ¤ Draw! Player ${winners.join("ã€")} tie at ${maxScore} pts`);
      });
    }
  }
}

function startTimer() {
  if (mode !== 'time' || gameEnded) return;
  if (timer) return;
  timer = setInterval(tickTimer, 1000);
}

function stopTimer() {
  if (timer) { clearInterval(timer); timer = null; }
}

function pauseTimer() {         // â˜… æ–°å¢ï¼šæš«åœ
  if (mode !== 'time') return;
  timerPaused = true;
  stopTimer();
}

function resumeTimer() {        // â˜… æ–°å¢ï¼šæ¢å¾©
  if (mode !== 'time') return;
  if (!gameEnded) {
    timerPaused = false;
    startTimer();
  }
}
	
	
    let quizHistory = [];
    let isAskingQuiz = false; // âœ… é˜²å‘†ï¼šé¿å…åŒä¸€å›åˆé‡è¤‡å½ˆå‡ºå•ç­”

    function isQuizTileName(name) {
      if (!name) return false;
      return name.includes("quiz_earthquake.png") || name.includes("quiz_fire.png") || name.includes("quiz_water.png");
    }

    function closeGameOver() {
      document.getElementById('game-over').classList.remove('show');
    }
    let quizQuestions = [];
    let passedStart = false;

    const QUIZ = {
      fire: [
        { category: 'fire', question: 'What should you do when encountering thick smoke?', options: ['Move forward low while covering mouth and nose', 'Run with head up', 'Take the elevator to leave'], answer: 0 },
        { category: 'fire', question: 'Which step in using a fire extinguisher (PASS) is wrong?', options: ['Pull the pin', 'Aim at the base', 'Aim at the top of the smoke'], answer: 2 },
        { category: 'fire', question: 'When discovering a fire, what is the safest thing to do first?', options: ['Go back immediately to take valuables', 'Shout â€œfireâ€ and report', 'Run upstairs'], answer: 1 },
        { category: 'fire', question: 'What danger does thick smoke in a fire cause?', options: ['Just a smell, no harm', 'Makes it hard to see direction', 'Helps us find the fire source', 'Makes people faint and call for help automatically'], answer: 1 },
        { category: 'fire', question: 'When you see wires sparking or smoking, what is the safest action?', options: ['Pour water on it', 'Unplug immediately', 'Notify an adult or teacher and stay away', 'Use a stick to knock down the wire'], answer: 2 },
        { category: 'fire', question: 'Which situation is most likely to cause a fire?', options: ['Turning off the lights at night to sleep', 'Forgetting to turn off appliances after use', 'Weather turning cold', 'Living room being too quiet'], answer: 1 },
        { category: 'fire', question: 'If home wiring is old, what should you do?', options: ['Wrap with tape and keep using', 'Have a professional check and replace', 'Burn it to see if it catches fire', 'Unplug everything and stop using electricity'], answer: 1 },
        { category: 'fire', question: 'Why canâ€™t you use the elevator to escape during a fire?', options: ['Elevator is too crowded', 'Air inside is too poor', 'Fire may cause malfunction or power outage trapping you', 'Elevator is too slow'], answer: 2 },
        { category: 'fire', question: 'If your clothes catch fire, what should you do?', options: ['Run fast to blow out the fire', 'Hide in bathroom and pour water', 'Stop, drop, and roll; cover flames with thick cloth', 'Stand and shout for help'], answer: 2 },
        { category: 'fire', question: 'When discovering a fire, you should immediately?', options: ['Record a video and upload', 'Hide in the room', 'Escape quickly and call 119', 'Go back to get your phone'], answer: 2 },
        { category: 'fire', question: 'Where is using a lighter more likely to cause a fire?', options: ['Bathroom', 'Kitchen', 'Playground', 'Living room'], answer: 1 },
        { category: 'fire', question: 'Which of the following items is most flammable?', options: ['Metal', 'Plastic toys', 'Quilt', 'Ice'], answer: 2 },
        { category: 'fire', question: 'Why should you cover your mouth and nose during a fire?', options: ['Keep warm', 'Canâ€™t see the fire', 'Avoid inhaling smoke', 'Prevent screaming'], answer: 2 },
        { category: 'fire', question: 'Which action is wrong?', options: ['Donâ€™t play with lighters', 'Turn off appliances before sleep', 'Escape immediately when discovering fire', 'Use elevator to escape during fire'], answer: 3 },
        { category: 'fire', question: 'What should you do after using the gas stove?', options: ['Keep the fire on', 'Forget to turn off is fine', 'Make sure flame is out and turn off gas switch', 'Blow gas with an electric fan'], answer: 2 },
        { category: 'fire', question: 'What is 119 used for?', options: ['Check weather', 'Order pizza', 'Report fire and emergency help', 'Check address'], answer: 2 },
        { category: 'fire', question: 'When discovering a fire, you should immediately?', options: ['Record a video and upload', 'Hide in the room', 'Escape quickly and call 119', 'Go back to get your phone'], answer: 2 },
        { category: 'fire', question: 'What is the safest way to escape during a fire?', options: ['Stay still', 'Crawl low', 'Run upright', 'Take the elevator'], answer: 1 }
      ],
     water: [
        { category: 'water', question: 'Which behavior is safe during a typhoon?', options: ['Go out in heavy rain to take photos', 'Hide under a big tree to avoid rain', 'Stay at home with gas turned off, windows closed, and watch weather updates', 'Go to the beach to watch waves'], answer: 2 },
        { category: 'water', question: 'Why should you not walk into floodwaters?', options: ['Water is dirty and will damage shoes', 'There might be small fish biting', 'Floodwater may hide wires, holes, or unseen dangers', 'Floodwater might cause a cold'], answer: 2 },
        { category: 'water', question: 'Which is NOT a cause of flooding?', options: ['Heavy rain or typhoon', 'River water rising rapidly', 'Poor drainage system', 'Weather being too dry'], answer: 3 },
        { category: 'water', question: 'To reduce the impact of floods, what can we do in daily life?', options: ['Throw trash into drains', 'Build houses in low-lying areas', 'Clean drainage holes and prevent blockage', 'Ignore weather forecasts'], answer: 2 },
        { category: 'water', question: 'During a flood, if the government announces evacuation, what should we do?', options: ['Stay at home and sleep', 'Go out with an umbrella for fun', 'Immediately follow instructions to evacuation sites and watch weather updates', 'Record a video and upload it'], answer: 2 },
        { category: 'water', question: 'Which is NOT a possible consequence of flooding?', options: ['House flooding', 'Farmland damage', 'Road interruptions', 'Hotter weather'], answer: 3 },
        { category: 'water', question: 'When a flood occurs, what should we do?', options: ['Stay at home and watch TV', 'Go to the river to see water level', 'Follow adultsâ€™ instructions to safe places', 'Jump into water to swim'], answer: 2 },
        { category: 'water', question: 'Which can help reduce the chance of flooding?', options: ['Throw garbage into drains', 'Build drainage systems', 'Cut down all trees', 'Throw garbage into rivers'], answer: 1 },
        { category: 'water', question: 'Why should garbage not be thrown into drains?', options: ['Itâ€™s fine, water will wash it away', 'Garbage will decrease', 'It clogs easily and causes flooding', 'Itâ€™s more convenient'], answer: 2 },
        { category: 'water', question: 'Facing flood surges and landslides, where should we avoid staying?', options: ['River channels and low-lying valleys', 'On slopes waiting for rescue', 'Strong houses for shelter', 'High riverbanks away from water'], answer: 0 },
        { category: 'water', question: 'Which is NOT a natural cause of flooding?', options: ['Rainwater flowing into rivers', 'Soil erosion on slopes causing sedimentation', 'Snow melting into rivers', 'Urban cement surfaces draining quickly'], answer: 3 },
        { category: 'water', question: 'Which is NOT a human factor causing or worsening floods?', options: ['Deforestation causing soil erosion', 'Urban surface hardening leading to waterlogging', 'Rivers not dredged regularly causing silt buildup', 'River erosion deepening naturally, increasing flow'], answer: 3 },
        { category: 'water', question: 'Which flood prevention method can be done daily?', options: ['Check weather information regularly and prepare emergency supplies', 'Let trash accumulate in drains', 'Ignore typhoon and heavy rain forecasts', 'Stack sandbags inside windows'], answer: 0 },
        { category: 'water', question: 'Which statement about flood escape tools is correct?', options: ['Use empty oil drums or plastic bottles as simple float devices', 'Paper boxes make the most stable rafts', 'Balls (like basketballs) are the best float tools', 'Life-saving devices do not need sealing'], answer: 0 },
        { category: 'water', question: 'What is the most common main cause of flooding?', options: ['Earthquakes causing ground collapse', 'Heavy rain exceeding river drainage capacity', 'Sudden drop in temperature', 'Increased air pollution'], answer: 1 }
      ],
      earthquake: [
        { category: 'earthquake', question: 'Where is the safest place to hide during an earthquake?', options: ['Inside an elevator', 'Under a desk', 'On the balcony'], answer: 1 },
        { category: 'earthquake', question: 'What should you do immediately during an earthquake?', options: ['Run out of the classroom', 'Find sturdy furniture to hide under', 'Take photos with your phone'], answer: 1 },
        { category: 'earthquake', question: 'Which of the following should NOT be done during an earthquake?', options: ['Hide in a corner', 'Move close to a window', 'Stay calm'], answer: 1 },
        { category: 'earthquake', question: 'Why shouldnâ€™t you use an elevator during an earthquake?', options: ['Elevator may be crowded', 'Elevator may get stuck', 'Too slow'], answer: 1 },
        { category: 'earthquake', question: 'What should be included in an earthquake emergency kit?', options: ['Flashlight', 'Toys', 'Books'], answer: 0 },
        { category: 'earthquake', question: 'If a strong earthquake happens at school, what should you do?', options: ['Chat with classmates', 'Follow teacherâ€™s instructions', 'Leave school on your own'], answer: 1 },
        { category: 'earthquake', question: 'Why should you stay away from windows during an earthquake?', options: ['Glass may break', 'Canâ€™t see outside', 'Too cold'], answer: 0 },
        { category: 'earthquake', question: 'After an earthquake, where should you be cautious of aftershocks?', options: ['Open outdoor areas', 'Stairways', 'Everywhere is safe after the quake'], answer: 1 },
        { category: 'earthquake', question: 'Which of the following is NOT necessary in an emergency kit?', options: ['Whistle', 'Flashlight', 'Video games'], answer: 2 },
        { category: 'earthquake', question: 'Why should you open the door during an earthquake?', options: ['To check what neighbors are doing', 'For ventilation', 'To prevent it from getting stuck'], answer: 2 },
        { category: 'earthquake', question: 'Where are earthquakes most likely to occur?', options: ['Mountain areas', 'Near volcanoes', 'At plate boundaries'], answer: 2 },
        { category: 'earthquake', question: 'What should you do if an earthquake happens in a movie theater?', options: ['Run out quickly', 'Duck down and cover your head', 'Keep sitting and watching'], answer: 1 },
        { category: 'earthquake', question: 'Why can stairways be dangerous during earthquakes?', options: ['Easily crowded', 'Structurally unstable', 'Too tall'], answer: 1 },
        { category: 'earthquake', question: 'What should you do if you are in a car during an earthquake?', options: ['Get out immediately', 'Stay calm and pull over', 'Speed up to leave'], answer: 1 },
        { category: 'earthquake', question: 'Which action should be most avoided during an earthquake?', options: ['Screaming loudly', 'Finding exits', 'Holding onto a wall'], answer: 0 },
        { category: 'earthquake', question: 'What is the most important principle during an earthquake?', options: ['Stay calm', 'Escape quickly', 'Shout loudly'], answer: 0 },
        { category: 'earthquake', question: 'Why should you not use electrical appliances immediately after an earthquake?', options: ['No electricity', 'May cause fire', 'Too noisy'], answer: 1 },
      ]


    };
    //fetch("quiz_all.json")
    //  .then(res => res.json())
    // .then(data => quizQuestions = data);
    // const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];


    // é¡Œåº«æ ¼å¼å»ºè­°ï¼š[{ category: "earthquake"|"fire"|"water", question, options:[], answer }]
    // answer å¯æ˜¯æ•¸å­—ç´¢å¼•(0-based) æˆ– èˆŠæ ¼å¼çš„ã€Œé¸é …å­—é¦–ã€(ä¾‹å¦‚ "A." / "B.")
    function getRandomQuiz(category) {
      let pool = [];
      if (category === 'fire') pool = QUIZ.fire;
      else if (category === 'water') pool = QUIZ.water;
      else if (category === 'earthquake') pool = QUIZ.earthquake;
      else pool = [...QUIZ.fire, ...QUIZ.water, ...QUIZ.earthquake];
      if (!pool.length) return null;
      return pool[Math.floor(Math.random() * pool.length)];
    }

async function makeQuiz(){}

// âœ… å¹«åŠ©è§£æ AI å›å‚³æ–‡å­—æˆé¡Œç›®ç‰©ä»¶
function parseGeminiQuizText(text) {
  const mQ = text.match(/Question[:ï¼š](.*)/);
  const q = mQ ? mQ[1].trim() : "";
  const opts = [];
  for (const ch of ["A","B","C","D"]) {
    const m = text.match(new RegExp(`${ch}[)ï¼\\.]\\s*(.+)`));
    if (m) opts.push(`${ch}) ${m[1].trim()}`);
  }
  const mA = text.match(/Answer[:ï¼š]\s*([A-D])/);
  const ans = mA ? mA[1] : null;
  return q && opts.length === 4 && ans ? {
    question: q,
    options: opts,
    answerIndex: {A:0,B:1,C:2,D:3}[ans]
  } : null;
}



    // å…¼å®¹ä½ åŸæœ¬çš„ç­”é¡Œåˆ¤å®šï¼šæ”¯æ´ã€Œç´¢å¼•ã€æˆ–ã€Œå­—é¦–ã€
    function isCorrectAnswer(quizObj, optionText, optionIndex) {
      if (typeof quizObj.answer === 'number') {
        return optionIndex === quizObj.answer; // 0-based ç´¢å¼•
      }
      if (typeof quizObj.answer === 'string') {
        // èˆŠæ ¼å¼ï¼šoption ä»¥ "A. xxx"ï¼›quiz.answer = "A"
        const prefix = optionText.trim().slice(0, quizObj.answer.length);
        return prefix === quizObj.answer;
      }
      return false;
    }

    const PROPERTY_DEFS = {
      fire_station: { buyPrice: 5, toll: 3, display: 'Forest' },
      water_bureau: { buyPrice: 5, toll: 3, display: 'Low Lying Land' },
      school: { buyPrice: 5, toll: 3, display: 'å­¸æ ¡' },
      museum921: { buyPrice: 5, toll: 3, display: 'High Building' }
    };
    const propertyOwners = {};   // { [cellIndex]: 1|2|3|4|null }
    const propertyKeys = {};   // { [cellIndex]: 'fire_station'|'water_bureau'|... } å¿«å–åŠ é€Ÿç”¨

    function getPropertyKey(src) {
      if (!src) return null;
      const name = src.split('/').pop().toLowerCase();

      // å…ˆèµ°ã€Œæ¨™æº–æª”åã€è¦å‰‡ï¼š<key>_<owner>.png
      for (const key of Object.keys(PROPERTY_DEFS)) {
        if (name.startsWith(key + '_')) return key;
      }

      // å…¼å®¹ä½ ç”¨ç”Ÿæˆå™¨ç”¢å‡ºçš„é•·æª”åï¼šç”¨é—œéµå­—/åˆ¥åæ¨æ–·
      const patterns = [
        { key: 'fire_station', re: /(fire[\s_\-]?station|æ¶ˆé˜²)/ },
        { key: 'water_bureau', re: /(water[\s_\-]?(bureau|dept|department)|æ°´åˆ©)/ },
        { key: 'school', re: /(school|å­¸æ ¡)/ },
        { key: 'museum921', re: /(921|museum)/ }
      ];
      for (const { key, re } of patterns) {
        if (re.test(name)) return key;
      }
      return null;
    }

    function getOwnerFromImg(src) {
      if (!src) return null;
      const name = src.split('/').pop().toLowerCase();
      const m = name.match(/_(\d)\.(png|webp|jpg)$/);
      return m ? parseInt(m[1], 10) : null;
    }

    function imageForOwner(key, owner) {
      return `${key}_${owner || 0}.png`;
    }

    function setTileImage(index, newImg) {
      mapData[index] = newImg;
      const cell = gameBoard.children[index];
      const imgEl = cell && cell.querySelector('img');
      if (imgEl) imgEl.src = newImg;
    }

   const eventList = [
  { desc: "E01ï¼šAn earthquake strikes! You hide under a sturdy table. Safe move! Advance 1 space.", effect: "Advance 1 space" },
  { desc: "E02ï¼šDuring the earthquake, you run to the stairs for escape but are stopped by the guard. Skip 1 turn for reflect.", effect: "Skip 1 turn" },
  { desc: "E03ï¼šYou forgot to secure the bookshelf, and during the earthquake, things fell down. Move back 1 space.", effect: "Move back 1 space" },
  { desc: "E04ï¼šAfter the earthquake, you immediately turn on the gas to cook instant noodles, causing a fire!", effect: "Return to start" },
  { desc: "E05ï¼šYou memorized the evacuation route and quickly led your classmates to escape, earning 2 points.", effect: "Gain 1 point" },
  { desc: "E06ï¼šYou used the whistle in the disaster kit to call for help and were successfully rescued!", effect: "Advance 2 spaces" },
  { desc: "E07ï¼šYou calmly avoided danger and helped your classmates escape, showing excellent performance!", effect: "Advance 2 spaces" },
  { desc: "E08ï¼šAfter the earthquake, you called to report safety, but the line was busy.", effect: "Skip 1 turn" },
  { desc: "E09ï¼šDuring the earthquake, the window shattered and you were cut by the glass.", effect: "Move back 1 space" },
  { desc: "E10ï¼šYou participated in earthquake drills and became familiar with evacuation routes!", effect: "Gain 1 point" },
  { desc: "E11ï¼šYou hid next to the bookshelf and were crushed by falling books.", effect: "Return to start" },
  { desc: "E12ï¼šDuring the earthquake, you shouted 'Don't move!' causing panic.", effect: "Move back 1 space" },
  { desc: "E13ï¼šYou hid in the bathroom and got stuck!", effect: "Advance 1 space" },
  { desc: "E14ï¼šYou joked with your friend saying 'The earthquake is coming', and it really shook!", effect: "Gain 1 point" },
  { desc: "E15ï¼šDuring the earthquake, you filmed a video to upload but tripped and got stuck.", effect: "Skip 1 turn" },
  { desc: "E16ï¼šYou helped the teacher move disaster supplies, being well-prepared.", effect: "Move back 1 space" },
  { desc: "E17ï¼šThe disaster kit contains water and a whistle, and you calmly wait for rescue!", effect: "Return to start" },
  { desc: "E18ï¼šYou followed the broadcast instructions to evacuate to an open area.", effect: "Gain 1 point" }
];

    buildBoard();
    updateStatus();
	const nextFrame = () =>  new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

    if (mode === "score") {
      // ç§¯åˆ†åˆ¶ï¼šè¨­å®šç›®æ¨™åˆ†æ•¸

      //scoreGoal = parseInt(document.getElementById("scoreTarget").value);
    } else if (mode === "time") {
      // é™æ™‚åˆ¶ï¼šå•Ÿå‹•å€’æ•¸è¨ˆæ™‚
      timeLeft = config.timeLimit;
      const configInfo = document.getElementById("configInfo");
      configInfo.textContent = `Timedï¼š ${timeLeft} sec left `;

      timer = setInterval(async() => {
        timeLeft--;
        configInfo.textContent = `Timedï¼š ${timeLeft} sec left `;

        if (timeLeft <= 0) {
          clearInterval(timer);
          gameEnded = true;

          // æ¯”è¼ƒé›™æ–¹åˆ†æ•¸
          const maxScore = Math.max(...playerScores);
          // æ‰¾å‡ºæ‰€æœ‰æœ€é«˜åˆ†çš„ç©å®¶ï¼ˆæ”¯æ´å¤šäººå¹³æ‰‹ï¼‰
          const winners = [];
          for (let i = 0; i < playerScores.length; i++) {
            if (playerScores[i] === maxScore) {
              winners.push(i + 1); // ç©å®¶ç·¨è™Ÿå¾1é–‹å§‹
            }
          }
          if (winners.length === 1) {
            await alert(`âŒ› Time's up! Player ${winners[0]} wins with ${maxScore} pts`);
            winnerIndex = winners[0] - 1;
            updateStatus();  // â† 0-based
            showGameOverScreen(`âŒ› Time's upï¼ Player ${winners[0]} wins with ${maxScore} pts`);
          } else {
            await alert(`âŒ› Time's upï¼ğŸ¤ Drawï¼Player ${winners.join("ã€")} tie at ${maxScore} pts`);
            showGameOverScreen(`âŒ› Time's upï¼ğŸ¤ Drawï¼Player ${winners.join("ã€")} tie at ${maxScore} pts`);
          }



        }
      }, 1000);
    }

    function getDescription(filename) {
      const name = filename.split('/').pop().trim();
      const descriptions = {
        "start.png": "Start: Players begin here",
    "quiz.png": "Quiz: Answer to score",
    "quiz_fire.png": "Fire Quiz: answer to score",
    "quiz_water.png": "Flood Quiz: answer to score",
    "quiz_earthquake.png": "Earthquake Quiz: answer to score",
    "event1.png": "Event Card : random event",
    "event2.png": "Event Card : random event",
    "fire1.png": "Fire event",
    "fire2.png": "Fire event",
    "light.png": "Light prepared , gain pts",
    "bag1.png": "First-aid kit, gain pts",
    "bag2.png": "First-aid kit, gain pts",
    "card1.png": "Blank card",
    "card2.png": "Skill card",
    "earthquake1.png": "Earthquake",
    "earthquake2.png": "Earthquake",
    "earthquake3.png": "Earthquake",
    "ok1.png": "No special event",
    "ok2.png": "No special event",
    "ok3.png": "No special event",
    "rain1.png": "Flood event",
    "rain2.png": "Flood event",
    "rain3.png": "Flood event",
    "safe.png": "Safe zone",
    "safezone.png": "Safe zone",
    "warning1.png": "Warning",
    "warning2.png": "Warning",
        "underdesk.png": "Earthquake occurs, hide under the table. gain pts.",
        "back.png": "back to Start",
        "dice.png": "Dice : roll again",
        "fire_station_0.png": "Forest",
        "water_bureau_0.png": "Low Lying Land",
        "museum921_0.png": "High Building",
        // ...å¯ä»¥åŠ æ›´å¤š
      };
      return descriptions[name] || "";
    }


    function buildBoard() {
      for (let i = 0; i < 64; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        if (mapData[i]) {
          const wrapper = document.createElement("div");
          wrapper.className = "game-map-wrapper";
          // åŠ åœ–ç‰‡
          const img = new Image();
          img.src = mapData[i];
          const pKey = getPropertyKey(mapData[i]);
          if (pKey) {
            propertyKeys[i] = pKey;
            propertyOwners[i] = getOwnerFromImg(mapData[i]) ?? 0;// 0 æˆ– null ä»£è¡¨ç„¡äºº
          }
          wrapper.appendChild(img);
          // åŠ  tooltip
          const tooltip = document.createElement("div");
          tooltip.className = "game-map-tooltip";
          tooltip.textContent = getDescription(img.src);
          wrapper.appendChild(tooltip);

          cell.appendChild(wrapper);
        }
        if (pathIndices.includes(i)) {
          const label = document.createElement("div");
          label.className = "order-number";
          label.textContent = pathIndices.indexOf(i) + 1;
          cell.appendChild(label);
        }
        gameBoard.appendChild(cell);
      }
      renderPlayers();
      if (!pathIndices || pathIndices.length === 0) {
        alert("âš ï¸ è«‹å…ˆå¾ editor.html è¨­å®šç§»å‹•é †åºä¸¦é–‹å§‹éŠæˆ²ï¼");
      }
    }
    function displayCategory(cat) {
      switch (String(cat || '').toLowerCase()) {
        case 'water': return 'Flood';
        case 'fire': return 'Fire';
        case 'earthquake': return 'Earthquake';
        default: return cat || '';
      }
    }

// === å‡ºé¡Œé®ç½© ===
function showQuizOverlay(text = "â³ Question is being generated") {
  if (document.getElementById("quizOverlay")) return;
  const overlay = document.createElement("div");
  overlay.id = "quizOverlay";
  overlay.style = `
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.75);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    z-index: 99999;
  `;
  overlay.innerHTML = `<div id="quizProgress">${text}</div>`;
  document.body.appendChild(overlay);
}

function setQuizOverlayText(text) {
  const el = document.getElementById("quizProgress");
  if (el) el.textContent = text;
}

function hideQuizOverlay() {
  const ov = document.getElementById("quizOverlay");
  if (ov) ov.remove();
}



    function askQuiz(playerIndex, onCorrect, onWrong, quizOverride /* å¯é¸ï¼šæŒ‡å®šé¡Œç›® */) {
      const synth = window.speechSynthesis;
      const quiz = quizOverride || getRandomQuiz(null);
      const t0 = Date.now();   // â† åŠ é€™è¡Œè¨˜éŒ„ä½œç­”èµ·å§‹æ™‚é–“
      if (!quiz) { alert("ç›®å‰æ²’æœ‰é¡Œç›®å¯ç”¨"); (onWrong || (() => { }))(); return; }

      const modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.7)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "9999";

      const box = document.createElement("div");
      box.style.background = "white";
      box.style.padding = "20px";
      box.style.borderRadius = "8px";
      box.style.width = "300px";
      box.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
      box.style.textAlign = "center";
      box.style.animation = "slideIn 0.4s ease-out";

      const q = document.createElement("h3");
      q.textContent = quiz.question;
      box.appendChild(q);


      const optsWrap = document.createElement('div');
      optsWrap.className = 'quiz-opts';
      quiz.options.forEach((opt, idx) => {
        const btn = document.createElement("button");
        btn.textContent = opt;
        btn.classList.add('quiz-opt');
        btn.style.display = "block";
        btn.style.margin = "8px auto";
        btn.style.padding = "8px 16px";
        btn.style.fontSize = "16px";
        btn.style.cursor = "pointer";
        btn.onclick = () => {
          document.body.removeChild(modal);

          const dt = Date.now() - t0;
          const correct = isCorrectAnswer(quiz, opt, idx);

          // ç”¢ç”Ÿã€Œæ­£ç¢ºç­”æ¡ˆé¡¯ç¤ºæ–‡å­—ã€
          let correctLabel = "";
          if (typeof quiz.answer === 'number') {
            correctLabel = quiz.options[quiz.answer];
          } else if (typeof quiz.answer === 'string') {
            const match = quiz.options.find(o => o.trim().startsWith(quiz.answer));
            correctLabel = `${quiz.answer}${match ? ` (${match})` : ""}`;
          }

          // å¯«å…¥æ­·å²
          quizHistory.push({
            player: playerIndex + 1,
            question: quiz.question,
            selected: opt,
            correctAnswer: correctLabel || "",
            result: correct ? "âœ”ï¸ Correct" : "âŒ Wrong",
            category: quiz.category || "-",
            ms: dt,
            correct: correct
          });
          // çµæœè™•ç†ï¼ˆä¿ç•™ä½ åŸæœ¬åŠ åˆ†/ä¸åŠ åˆ†ç”±å‘¼å«ç«¯æ±ºå®šï¼‰
          if (correct) {
            alert("You are rightï¼add 3 pts");
            onCorrect && onCorrect();
          } else {
            alert("You are wrong");
            onWrong && onWrong();
          }
        };
        box.appendChild(btn);
      });

      modal.appendChild(box);

      // èªéŸ³æœ—è®€
      //try {
      // const utterance = new SpeechSynthesisUtterance(`${quiz.question} é¸é …æ˜¯ï¼š${quiz.options.join('ã€')}`);
      // utterance.lang = 'zh-TW';
      //  synth.speak(utterance);
      //} catch(_) {}

      document.body.appendChild(modal);
    }


    function showQuizHistory() {
      const historyEl = document.getElementById('quiz-list');
      // æ˜ç´°åˆ—è¡¨
      const detailHTML = quizHistory.map(h => {
  const playerImg = `player${h.player}.png`;
  return `
    <div style="margin-bottom:10px;">
      <img src="${playerImg}" class="player-icon" style="width:24px; height:24px; vertical-align:middle; margin-right:5px;">
      Player${h.player}ï¼š${h.question}<br>
      â¡ï¸ answerï¼š${h.selected} ${h.result}
      ${Number.isFinite(Number(h.ms)) ? `ï¼ˆ${(Number(h.ms) / 1000).toFixed(1)} secï¼‰` : ``}<br>
      âœ… Correct Answer: ${h.correctAnswer} ${h.category ? `ï½œ Categoryï¼š${displayCategory(h.category)}` : ``}
    </div>
    <hr>`;
}).join('');

      // æ•´ç†æ¯ä½ç©å®¶çµ±è¨ˆ
      const players = typeof nPlayers !== 'undefined' ? nPlayers : Math.max(1, ...quizHistory.map(h => h.player || 1));
      const stats = [];
      for (let p = 1; p <= players; p++) {
        const items = quizHistory.filter(h => h.player === p);
        const n = items.length;
        const right = items.filter(h => h.correct === true || /æ­£ç¢º/.test(h.result || '')).length;
        const acc = n ? Math.round(right / n * 100) : "-";
        const totalMs = items.reduce((s, h) => s + (Number(h.ms) || 0), 0);
        const avgSec = n ? Math.round((totalMs / n) / 100) / 10 : "-";
        const by = { fire: { n: 0, c: 0 }, water: { n: 0, c: 0 }, earthquake: { n: 0, c: 0 } };
        items.forEach(h => {
          const t = (h.category || '').toLowerCase();
          if (by[t]) {
            by[t].n += 1;
            by[t].c += (h.correct === true || /æ­£ç¢º/.test(h.result || '')) ? 1 : 0;
          }
        });
        //const pct = (c, n) => n ? +(Math.round((c / n * 100) * 10) / 10) : '-';å°æ•¸é»
		const pct = (c, n) => n ? Math.round(c / n * 100) : "-";
        stats.push({
          player: p,
          count: n,
          acc: acc === "-" ? "-" : +(Math.round(acc * 10) / 10),
          avgSec,
          fireAcc: pct(by.fire.c, by.fire.n),
          waterAcc: pct(by.water.c, by.water.n),
          eqAcc: pct(by.earthquake.c, by.earthquake.n)
        });
      }

      // ç”¢ç”Ÿè¡¨æ ¼
     // ======= ç¾è§€è¡¨æ ¼ CSS =======
const table = `
<style>
.player-icon{  width: 26px;  height: 26px;  object-fit: contain;  vertical-align: middle;  margin-right: 6px;}
  .stats-table{    border-collapse:collapse;    width:100%;    font-size:15px;    margin-top:12px;    border-radius:8px;    overflow:hidden;  }
  .stats-table th{    background:#f0f0f0;    padding:8px 6px;    font-weight:900;    border-bottom:2px solid #ccc;  }
  .stats-table td{    border-bottom:1px solid #eee;    padding:8px 6px;    text-align:center;  }
  .good-rate{    font-weight:700;    color:#111;  }
  .bad-rate{     font-weight:700;     color:#3cb371;    /* ä½æ–¼51% â†’ ç¶ è‰² */  }
</style>
   <h3>ğŸ“Š Players results comparison</h3>
<table class="stats-table">
<thead>
  <tr>
    <th>Player</th><th>answer</th><th>ratio(%)</th><th>average answer time</th>
    <th>Fire ratio(%)</th><th>Flood ratio(%)</th><th>Earthquake ratio(%)</th>
  </tr>
</thead>
<tbody>
${stats.map(s => {

  const showRate = (v) => {
    if (v === "-") return `<td>-</td>`;
    const cls = v < 51 ? "bad-rate" : "good-rate";
    return `<td class="${cls}">${v}%</td>`;
  };

  // âœ” ç©å®¶åœ–ç¤ºï¼šä¾ç…§ç©å®¶ç·¨è™Ÿå‹•æ…‹è¼‰å…¥
  const playerImg = `player${s.player}.png`;

  return `
    <tr>
      <td>
        <img class="player-icon" src="${playerImg}">
        Player${s.player}
      </td>
      <td>${s.count}</td>
      ${showRate(s.acc)}
      <td>${s.avgSec === "-" ? "-" : s.avgSec + " sec"}</td>
      ${showRate(s.fireAcc)}
      ${showRate(s.waterAcc)}
      ${showRate(s.eqAcc)}
    </tr>`;
}).join('')}
</tbody>
</table>`;

      historyEl.innerHTML = detailHTML + table;
      document.getElementById('quiz-history').classList.add('show');

    }

    function closeQuizHistory() {
      document.getElementById('quiz-history').classList.remove('show');
    }



    function renderPlayers() {
      console.log("renderPlayers");
      document.querySelectorAll(".player").forEach(p => p.remove());
      for (let idx = 0; idx < nPlayers; idx++) {
        const cellIndex = pathIndices[playerSteps[idx]];
        const cell = gameBoard.children[cellIndex];
        const token = document.createElement("div");
        token.className = `player player${idx + 1}`;
        const carImgs = ["car_red.png", "car_blue.png", "car_green.png", "car_yellow.png"];
        const car = new Image();
        car.src = carImgs[idx] || "car_red.png";
        token.appendChild(car);
        cell.appendChild(token);
        playerTokens[idx] = token;
      }
    }
    function rollDice() {

      if (gameEnded) return;

      console.log("rollDice");
      if (skipTurn[currentPlayer]) {
        console.log(`Player ${currentPlayer + 1} Skip one turn`);
        alert(`ğŸ›‘ Player ${currentPlayer + 1} Skip one turn`);
        const log = document.getElementById("log");
        log.innerText += `\nğŸ¯Player ${currentPlayer + 1} Skip one turn`;
        skipTurn[currentPlayer] = false;
        currentPlayer = (currentPlayer + 1) % nPlayers;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
        updateStatus();
        return;
      }
      updateStatus();            // â† è®“æ­£åœ¨æ“²éª°çš„ç©å®¶ç«‹åˆ»é«˜äº®
      const selected = document.querySelector('input[name="diceOverride"]:checked');
      let dice = selected && selected.value !== "0" ? parseInt(selected.value) : Math.floor(Math.random() * 6) + 1;

      playDiceAnimation(dice, () => {
        finalizeRoll(dice);
      });
    }

    function playDiceAnimation(finalDice, callback) {
      const diceOverlay = document.createElement("div");
      diceOverlay.id = "diceOverlay";
      diceOverlay.style.position = "fixed";
      diceOverlay.style.top = "50%";
      diceOverlay.style.left = "50%";
      diceOverlay.style.transform = "translate(-50%, -50%)";
      diceOverlay.style.zIndex = "1000";
      diceOverlay.style.backgroundColor = "rgba(255,255,255,0.8)";
      diceOverlay.style.padding = "20px";
      diceOverlay.style.borderRadius = "10px";

      const diceImage = document.createElement("img");
      diceImage.id = "diceImage";
      diceImage.style.width = "100px";
      diceImage.style.height = "100px";
      diceOverlay.appendChild(diceImage);
      document.body.appendChild(diceOverlay);

      const diceSound = document.getElementById("diceSound");
      if (diceSound) {
        diceSound.currentTime = 0;
        diceSound.play();
      }

      let rollCount = 12, currentRoll = 0;
      const interval = setInterval(() => {
        let tempFace = Math.floor(Math.random() * 6) + 1;
        diceImage.src = `dice${tempFace}.png`;
        currentRoll++;
        if (currentRoll >= rollCount) {
          clearInterval(interval);
          diceImage.src = `dice${finalDice}.png`;
          setTimeout(() => {
            document.body.removeChild(diceOverlay);
            if (callback) callback();
          }, 500);
        }
      }, 80);
    }

    function finalizeRoll(dice) {
      console.log("finalizeRoll dice:", dice);
      const log = document.getElementById("log");



      log.innerText += `\nğŸ¯ Player${currentPlayer + 1} rolled ${dice}`;
      lastDiceRoll[currentPlayer] = dice;
      document.getElementById("diceResult").textContent = dice;
      document.getElementById("people").textContent = currentPlayer + 1;

      continueMoveLogic(dice);
    }



    async function continueMoveLogic(dice) {
      const prevStep = playerSteps[currentPlayer];
      let step = playerSteps[currentPlayer] + dice;
      const pathLen = pathIndices.length;

      if ((prevStep < pathLen) && (step >= pathLen)) {
        passedStart = true;
      }
      step = step % pathLen;

      const fromIndex = pathIndices[prevStep % pathLen];
      const toIndex = pathIndices[step];
      const cellImg = mapData[toIndex] || "";

      if (fromIndex === undefined || toIndex === undefined) {
        alert("âš ï¸ æ‰¾ä¸åˆ°å°æ‡‰çš„æ ¼å­ï¼Œå¯èƒ½æ˜¯åœ°åœ–å°šæœªæ­£ç¢ºè¨­å®šã€‚");
        return;
      }




      const proceed = async () => {
        const prev = playerSteps[currentPlayer];
        if (passedStart) {
          playerScores[currentPlayer] += 1;
          // nextFrame();                        // â˜… å…ˆé‡ç¹ªï¼Œå†è·³çª—
			await alert("ğŸ‰ Completed a lap! +1 pointï¼"); 
	  log.innerText += `\nğŸ¯ Player${currentPlayer + 1} Completed a lap! +1 pointï¼`;
          checkScoreWin();
          passedStart = false;
        }

        playerSteps[currentPlayer] = step;
        animateMove(currentPlayer, fromIndex, toIndex, async () => {
          updateStatus();
          if (checkScoreWin()) return;
          logAction(currentPlayer, dice, toIndex);


          const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");

          if (isQuizTileName(imgNow)) {
  if (isAskingQuiz) return; // é¿å…é‡è¤‡å‡ºé¡Œ
  isAskingQuiz = true;

  // ğŸ”¹è¾¨è­˜é¡Œç›®é¡å‹
  let category = null;
  if (imgNow.includes("quiz_earthquake.png")) category = "earthquake";
  else if (imgNow.includes("quiz_fire.png")) category = "fire";
  else if (imgNow.includes("quiz_water.png")) category = "water";


if (!USE_AI_QUIZ) {
    // ä¸ä½¿ç”¨ AIï¼šç›´æ¥å‡ºé¡Œåº«
    const q = getRandomQuiz(category);
    askQuiz(
      currentPlayer,
      () => {
        playerScores[currentPlayer] += 3;
        logEl.innerText += ` âœ… Player${currentPlayer + 1} answer correct ${catNameTC(category)} ï¼šã€Œ${q.question}ã€ , add 3 points`;
        logEl.scrollTop = logEl.scrollHeight;
        updateStatus();
        checkScoreWin();
        isAskingQuiz = false;
        nextTurn();
      },
      () => {
        logEl.innerText += ` âŒ Player${currentPlayer + 1} answer wrong ${catNameTC(category)} ï¼šã€Œ${q.question}ã€`;
        logEl.scrollTop = logEl.scrollHeight;
        isAskingQuiz = false;
        nextTurn();
      },
      q
    );
    return;
  }
// ä½¿ç”¨ AIï¼šç›´æ¥å‡ºé¡Œåº«

  // ğŸ”¹ç›´æ¥å¯«åœ¨ç¨‹å¼è£¡çš„ API KEY
//  const  GEMINI_KEY = localStorage.getItem("gemini_api_key");
//if (! GEMINI_KEY) {
  //alert("âš ï¸ ç„¡å¯ç”¨API Key æ”¹ç”¨é¡Œåº«ï¼");  
//}	

  



  async function aiGenerateQuiz(category) {
    const topicMap = { fire: "fire", water: "water", earthquake: "earthquake" };
    const topic = topicMap[category] || "disaster preparedness";
    const prompt = `Please generate a single-choice question related to ${topic}  for children aged 10 to 12.ï¼Œ
Provide one question and four options (Aâ€“D), and clearly indicate the correct answer (Aâ€“D).
Format strictly as follows:
Question: AI-generated â€“ ......
A) ......
B) ......
C) ......
D) ......
Answer: A`;

   try {
  const res = await fetch(
    "https://wispy-firefly-8762.yingli0923.workers.dev/api/gemini",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [
          { role: "user", parts: [{ text: prompt }] }
        ]
      })
    }
  );

      const data = await res.json();
      const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
      const parsed = parseGeminiQuizText(text);
if (!parsed) throw new Error("AI format error");

// âœ… çµ±ä¸€æ ¼å¼ï¼šè½‰æˆ answerï¼ˆ0~3ï¼‰
return {
category: category,
  question: parsed.question,
  options: parsed.options,
  answer: typeof parsed.answerIndex === "number"
    ? parsed.answerIndex
    : parsed.answer
};
    } catch (e) {
      console.warn("AI question error:", e);
      return null;
    }
  }

  // ğŸ”¹é–‹å§‹ AI å‡ºé¡Œï¼ˆå¤±æ•—å†ç”¨é¡Œåº«ï¼‰
 (async () => {
  try {
  pauseTimer();  // â˜… é€²å…¥ AI å‡ºé¡Œ â†’ å…ˆæš«åœå€’æ•¸
    // ğŸ§  é¡¯ç¤ºé®ç½©
	
    showQuizOverlay(`â³ Generating ã€Œ${catNameTC(category)}ã€ related questionâ€¦`);

    // âš™ï¸ ç”Ÿæˆé¡Œç›®
    let q = await aiGenerateQuiz(category);

    // ğŸ” å¦‚æœAIå¤±æ•— â†’ fallback é¡Œåº«
    if (!q) {
      setQuizOverlayText(`ğŸ“˜ Use question bank...`);
      q = getRandomQuiz(category);
    }

    // âœ… é—œé–‰é®ç½©ï¼ˆç”Ÿæˆå®Œæˆï¼‰
    hideQuizOverlay();
	resumeTimer();  // â˜… é¡Œç›®æº–å‚™å¥½ï¼ˆæˆ–å¤±æ•— fallbackï¼‰â†’ æ¢å¾©å€’æ•¸
    // ğŸ§© å‡ºé¡Œ
    askQuiz(
      currentPlayer,
      () => {
        playerScores[currentPlayer] += 3;
        logEl.innerText += ` âœ… Player${currentPlayer + 1} correct answer ${catNameTC(category)} ï¼šã€Œ${q.question}ã€ , add 3 points`;
        logEl.scrollTop = logEl.scrollHeight;
        updateStatus();
        checkScoreWin();
        isAskingQuiz = false;
        nextTurn();
      },
      () => {
        logEl.innerText += ` âŒ Player${currentPlayer + 1} wrong answer ${catNameTC(category)} ï¼šã€Œ${q.question}ã€`;
        logEl.scrollTop = logEl.scrollHeight;
        isAskingQuiz = false;
        nextTurn();
      },
      q
    );
  } catch (err) {
    console.error("AI generating errorï¼Œuse question bankï¼š", err);
    hideQuizOverlay(); // âš ï¸ ç¢ºä¿å‡ºéŒ¯æ™‚ä¹Ÿé—œæ‰é®ç½©
	resumeTimer();
    const q = getRandomQuiz(category);
    askQuiz(currentPlayer, ()=>{}, ()=>{}, q);
  }
})();

  return; // å‡ºé¡Œå®Œå°±çµæŸ
}

          if (imgNow.includes("back.png")) {
            
			
			
			
			
			
			
			alert("ğŸ“¢ Back to Startï¼");    
            logEl.innerText += ` Back to Start`;
            playerSteps[currentPlayer] = 0;
            renderPlayers();
            updateStatus();
			
			
  
  
            nextTurn();
            return;
          }
          // ğŸ² éª°å­æ ¼ï¼šå†æ“²ä¸€æ¬¡ï¼ˆè½åœ°å¾Œåˆ¤æ–·ï¼‰
          if (imgNow.includes("dice.png")) {
            await alert("ğŸ² Diceï¼Œdice againï¼");
            playerSteps[currentPlayer] = step;
            logEl.innerText += ` Diceï¼Œdice againï¼`;
            logEl.scrollTop = logEl.scrollHeight;
            setTimeout(() => rollDice(), 300);
            return;
          }
          if (imgNow.includes("underdesk.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            logEl.innerText += `  Right actionï¼Œadd 5 pts`;
            logEl.scrollTop = logEl.scrollHeight;
            await  alert(`ğŸ´ Congraï¼Player${currentPlayer + 1} right actionï¼Œadd 5 pts`);
            checkScoreWin();

            // æ›ä¸‹ä¸€ä½
            nextTurn();
            return;
          }
          if (imgNow.includes("bag1.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            logEl.innerText += ` got a first-aid kit: +5 pts`;
            logEl.scrollTop = logEl.scrollHeight;
            await alert(`ğŸ´ Congraï¼Player${currentPlayer + 1} got a first-aid kit: add 5 pts`);
            checkScoreWin();

            // æ›ä¸‹ä¸€ä½
            nextTurn();
            return;
          }
		  if (imgNow.includes("light.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            logEl.innerText += ` prepared glashlight at home ï¼Œadd 5 pts`;
            logEl.scrollTop = logEl.scrollHeight;
            await alert(`ğŸ´ Congraï¼Player${currentPlayer + 1} prepared glashlight at homeï¼Œadd 5 pts`);
            checkScoreWin();

            // æ›ä¸‹ä¸€ä½
            nextTurn();
            return;
          }
          if (imgNow.includes("card2.png")) {
            playerSkills[currentPlayer]++;
            updateStatus();
            alert(`ğŸ´ Congraï¼Player${currentPlayer + 1} got one escape cardï¼Œnow card number isï¼š${playerSkills[currentPlayer]} `);
            logEl.innerText += ` got one escape card`;
            logEl.scrollTop = logEl.scrollHeight;
            nextTurn();   // çµæŸæœ¬å›åˆ
            return;       // ä¸è¦å†å¾€ä¸‹åšåœ°ç”¢/æ‹†åœ°
          }


          // ğŸ§¯ fire2.pngï¼šå…ˆå‡ºé¡Œï¼›ç­”éŒ¯å°±æ¸…ç©ºæ‰€æœ‰æ£®æ—åœ°
          // fire2ï¼šæ£®æ—åœ°ï¼ˆç”¨ askfireQuestionï¼‰
          if (imgNow.includes("fire2.png")) {
            handleOwnershipQuiz("fire2.png", "fire_station", "Forest", toIndex, askfireQuestion, () => {
              handleProperty(toIndex, () => nextTurn());
            });
            return;
          }
          // rain1ï¼šä½çªªåœ°ï¼ˆç”¨ askWaterBureauQuestionï¼‰
          if (imgNow.includes("rain1.png")) {
            handleOwnershipQuiz("rain1.png", "water_bureau", "Low Lying Land", toIndex, askWaterBureauQuestion, () => {
              handleProperty(toIndex, () => nextTurn());
            });
            return;
          }

          // earthquake3ï¼šé«˜æ¨“å¤§å»ˆï¼ˆç”¨ askMuseumQuestionï¼‰
          if (imgNow.includes("earthquake3.png")) {
            handleOwnershipQuiz("earthquake3.png", "museum921", "High Building", toIndex, askMuseumQuestion, () => {
              handleProperty(toIndex, () => nextTurn());
            });
            return;
          }



          // åŸæœ¬æµç¨‹end


          handleProperty(toIndex, () => {
            nextTurn();
          });
        });
      }





      if (cellImg.includes("event1.png") || cellImg.includes("event2.png")) {
        const randomEvent = eventList[Math.floor(Math.random() * eventList.length)];
        playerSteps[currentPlayer] = step;
        animateMove(currentPlayer, fromIndex, toIndex, () => {
          handleEventEffect(randomEvent, step);
        });
        return;
      }








      proceed();
    }

    function nextTurn() {
      currentPlayer = (currentPlayer + 1) % nPlayers;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      updateStatus();
    }



    function animateMove(playerIdx, fromCellIndex, toCellIndex, callback, direction = 1) {
      const token = playerTokens[playerIdx];
      if (!token) { callback && callback(); return; }

      const pathLen = pathIndices.length;

      // å–å¾—ã€Œæ­¥æ•¸ä½ç½®ã€ï¼šæŠŠ cellIndex è½‰ç‚º path ä¸Šçš„åºè™Ÿ
      let curStep = pathIndices.indexOf(fromCellIndex);
      const targetStep = pathIndices.indexOf(toCellIndex);
      if (curStep === -1 || targetStep === -1) { // å®‰å…¨é˜²å‘†
        // æ‰¾ä¸åˆ°å°±ç›´æ¥ç¬ç§»
        gameBoard.children[toCellIndex].appendChild(token);
        callback && callback();
        return;
      }

      // æ¯æ ¼åœç•™æ™‚é–“ï¼ˆå¯è‡ªè¡Œèª¿æ•´é€Ÿåº¦ï¼‰
      const STEP_DELAY = 180; // æ¯«ç§’
      const stepDir = (direction === -1 ? -1 : 1);
      // é€æ ¼å‰é€²ç›´åˆ° targetStep
      function stepOnce() {
        if (curStep === targetStep) {
          // èµ°å®Œ
          callback && callback();
          return;
        }
        // ä¾æ–¹å‘èµ°ä¸€æ ¼ï¼ˆå¯å‰é€²/å¾Œé€€ï¼Œå«ç’°ç¹ï¼‰
        curStep = (curStep + stepDir + pathLen) % pathLen;
        const nextCellIndex = pathIndices[curStep];

        // å°‡æ£‹å­æ”¾åˆ°ä¸‹ä¸€æ ¼ï¼ˆä¸è¤‡è£½ã€ä¸é¡¯ç¤ºåˆ†èº« â†’ ä¸æœƒæ®˜å½±ï¼‰
        gameBoard.children[nextCellIndex].appendChild(token);

        // ç¹¼çºŒä¸‹ä¸€æ ¼
        setTimeout(stepOnce, STEP_DELAY);
      }

      // å¾ç•¶å‰æ ¼é–‹å§‹èµ°
      setTimeout(stepOnce, STEP_DELAY);
    }
    function checkScoreWin() {
      if (mode === "score") {
        for (let i = 0; i < nPlayers; i++) {
          if (playerScores[i] >= scoreTarget) {
            gameEnded = true;
            winnerIndex = i; // â† æ¨™è¨˜è´å®¶ï¼Œè®“è¨˜åˆ†æ¿åŠ ä¸Š .winner
            updateStatus();// â† æ¨™è¨˜è´å®¶ï¼Œè®“è¨˜åˆ†æ¿åŠ ä¸Š .winner
            //alert(`ğŸ‰ ç©å®¶ ${i + 1} é”åˆ° ${scoreTarget} åˆ†ï¼Œç²å‹ï¼`);
            showGameOverScreen(`ğŸ‰ Player ${i + 1} get ${scoreTarget} ptsï¼ŒWINï¼`);
            clearInterval(timer);
            return true;
          }
        }
      }
      return false;
    }


    function updateStatus() {
      // å½©è‰²å¡ç‰‡å¼è¨˜åˆ†æ¿ï¼šé¡¯ç¤ºåˆ†æ•¸èˆ‡æŠ€èƒ½å¡æ•¸
      const carImgs = ["car_red.png", "car_blue.png", "car_green.png", "car_yellow.png"];
      const status = document.getElementById("status");
      const rawGoal = (document.getElementById('scoreTarget')?.value ?? (typeof config !== 'undefined' ? config.scoreTarget : 20));
      let goalScore = (() => {
        const n = parseInt(String(rawGoal).replace(/[^\d.-]/g, ''), 10);
        return Number.isFinite(n) && n > 0 ? n : 20;
      })();
      if (typeof config !== 'undefined' && config.mode === 'time') {
        goalScore = 50;   // OKï¼šå› ç‚ºä¸Šé¢ç”¨ let
      }




      if (!status) return;

      let cards = "";
      for (let i = 0; i < nPlayers; i++) {
        const isActive = (i === currentPlayer);

        const isWinner = (winnerIndex === i);
        const cls = `score-card p${i + 1}${isActive ? " active" : ""}${isWinner ? " winner" : ""}`;
        const car = carImgs[i] || "car_red.png";
        const score = (Array.isArray(playerScores) && typeof playerScores[i] !== "undefined") ? playerScores[i] : 0;
        const skills = (Array.isArray(playerSkills) && typeof playerSkills[i] !== "undefined") ? playerSkills[i] : 0;
        const pausedBadge = (Array.isArray(skipTurn) && skipTurn[i]) ? `<span class="badge pause">Pause</span>` : ``;
        const skillIcons = Array.from({ length: skills },
          () => `<span class="scard"><img src="card2.png" alt="å¡"></span>`
        ).join("");

        const pct = goalScore ? (playerScores[i] / goalScore) * 100 : 0;
        const isFull = playerScores[i] >= goalScore;
        const pctStr = isFull ? '100%' : `${Math.max(0, Math.min(100, pct)).toFixed(2)}%`;


        cards += `
      <div class="${cls}">
        <div class="left">
          <div class="player-avatar">
            <img class="token" src="${car}" alt="P${i + 1}">
            <div class="name">Player${i + 1}</div>
          </div>
        </div>
        <div class="right">
          <div class="score">${score}pts</div>
		  <div   class="goal"   title="ç›®æ¨™ ${goalScore} åˆ†"   role="progressbar"   aria-valuemin="0"   aria-valuemax="${goalScore}"   aria-valuenow="${score}" >
			<div class="bar${isFull ? ' full' : ''}" style="width:${pctStr}"></div>
		</div>
          <div class="badges">            
            <div class="skill-cards" aria-label="æŠ€èƒ½å¡ ${skills} å¼µ">${skillIcons}</div>${pausedBadge}
          </div>  
        </div>
      </div>`;
      }
      status.innerHTML = `<div class="score-grid">${cards}</div>`;
    }


    function showGameOverScreen(winnerText) {
      const over = document.getElementById('game-over');
      document.getElementById('winner-text').textContent = winnerText;
      over.classList.add('show');
    }

    function restartGame() {
      location.reload();  // ç›´æ¥é‡æ•´é é¢
    }


    function log(msg) {
      logEl.innerText += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function logAction(player, dice, pos) {
      const log = document.getElementById("log");
      const stepNum = pathIndices.indexOf(pos) + 1;
      const imgSrc = mapData[pos] || "";
      const imgName = imgSrc.split('/').pop();
      //log.innerText += `Player${player + 1} rolled ${dice}ï¼Œmove to ${stepNum} ï¼ˆ${imgName}ï¼‰`;
      log.innerText += ` move to ${stepNum} ï¼ˆ${imgName}ï¼‰`;
      log.scrollTop = log.scrollHeight;
      //alert("ğŸ“¢ğŸ“¢ğŸ“¢ ï¼");
    }

    function didCompleteLap(prevStep, newStep, pathLength) {
      return prevStep > newStep; // ä»£è¡¨ç¹éé ­å›åˆ°èµ·é»
    }




    function showEventCard(event, callback) {
      const card = document.getElementById("event-card-display");
      let skillBtnHtml = "";
      if (playerSkills[currentPlayer] > 0) {
        skillBtnHtml = `<button id="event-skill-btn">Used Escape Card</button>`;
      }
      card.innerHTML = `
    <h3>ğŸ´ Player${currentPlayer + 1} got Event Card</h3>
    <p>${event.desc}</p>
    <strong>â¡ ${event.effect}</strong>
    <button id="event-ok-btn">OK</button>
    ${skillBtnHtml}
  `;
      card.classList.add("show");

      // åŸæœ¬ç¢ºèª
      card.querySelector("#event-ok-btn").onclick = () => {
        hideEventCard();
        if (callback) callback();
      };
      // æœ‰æŠ€èƒ½æ‰æœ‰æŒ‰éˆ•
      if (playerSkills[currentPlayer] > 0) {
        card.querySelector("#event-skill-btn").onclick = () => {
          alert("ğŸ® Used Escape Card, this event had no effectï¼");
          if (passedStart) {
            playerScores[currentPlayer] += 1;

            //alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†(é€™é‚Šæ˜¯å¥—åœˆå¾Œ  èµ°åˆ°eventçš„åŠ åˆ† ç„¶å¾Œç”¨æŠ€èƒ½å¡çš„)ï¼");
            alert("ğŸ‰ Complete 1 lap , add 1 ptï¼");

            log.innerText += `\nğŸ¯ Player${currentPlayer + 1} Completed a lap! +1 pt`;
            passedStart = false;
            updateStatus();
            checkScoreWin();
          }
          playerSkills[currentPlayer]--;
          updateStatus();
          hideEventCard();
          // è·³éäº‹ä»¶ã€æ›äºº

          logEl.innerText += ` trigger eventï¼šã€Œ${event.desc} ${event.effect}ã€ï¼ŒUse Escape Card, no effect`;
          logEl.scrollTop = logEl.scrollHeight;
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;


          updateStatus();
        };
      }
    }

    function hideEventCard() {
      document.getElementById("event-card-display").classList.remove("show");
    }

    function getPropertyIndexesByKey(propKey, ownerFilter /* (ownerId)=>bool */ = null) {
      const arr = [];
      const total = 64; // 8x8 æ£‹ç›¤
      for (let i = 0; i < total; i++) {
        const key = propertyKeys[i] || getPropertyKey(mapData[i] || "");
        if (key === propKey) {
          const owner = (propertyOwners[i] ?? 0);
          if (!ownerFilter || ownerFilter(owner)) arr.push(i);
        }
      }
      return arr;
    }

    // æ¸…ç©ºæŒ‡å®š ownerId æ“æœ‰çš„ã€ŒæŸä¸€ç¨®åœ°ç”¢ã€(propKey) â†’ è®Šå› *_0.png
    function clearPropertiesByOwner(propKey, ownerId) {
      if (ownerId == null) return;
      const targets = getPropertyIndexesByKey(propKey, o => (o === ownerId));
      targets.forEach(i => {
        propertyOwners[i] = 0;
        setTileImage(i, imageForOwner(propKey, 0)); // e.g. water_bureau_0.png
      });
      updateStatus();
    }

    // å…±ç”¨ï¼šåœ¨æŒ‡å®šè§¸ç™¼åœ–(tileName) è¢«è¸©åˆ°æ™‚ï¼Œé€²è¡Œå›ºå®šå•ç­” & ä¾è¦å‰‡æ¸…ç©º
    // è¦å‰‡ï¼š
    //   è‹¥è‡ªå·±æ“æœ‰è©²é¡åœ°ï¼š  ç­”éŒ¯ â†’ æ¸…è‡ªå·±ï¼›ç­”å° â†’ ä¿ç•™
    //   è‹¥åˆ¥äººæ“æœ‰è©²é¡åœ°ï¼šç­”å° â†’ æ¸…åˆ¥äººï¼›ç­”éŒ¯ â†’ ä¿ç•™
    // ç„¡äººæ“æœ‰å‰‡åªæç¤ºã€‚
    function handleOwnershipQuiz(tileName, propKey, propDisplayName, toIndex, askFunc, afterResolve) {
      const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");
      if (!imgNow.includes(tileName)) { afterResolve && afterResolve(); return; }

      askFunc(correct => {
        const me = currentPlayer + 1;
        const mine = getPropertyIndexesByKey(propKey, o => (o === me));            // æˆ‘çš„åŒé¡åœ°
        const others = getPropertyIndexesByKey(propKey, o => (o > 0 && o !== me));    // åˆ¥äººçš„åŒé¡åœ°
        const otherOwnerIds = [...new Set(others.map(i => propertyOwners[i]))];       // å¯èƒ½å¤šä½

        if (mine.length === 0 && others.length === 0) {
          alert(correct ? `You rightï¼Œbut no one has ã€Œ${propDisplayName}ã€`
            : `You wrongï¼Œbut no one has ã€Œ${propDisplayName}ã€`);
          afterResolve && afterResolve();
          return;
        }

        if (correct) {
          // âœ… ç­”å°ï¼šä¿ç•™è‡ªå·±çš„ã€æ¸…æ‰æ‰€æœ‰å…¶ä»–äººçš„
          if (otherOwnerIds.length > 0) {
            otherOwnerIds.forEach(oid => clearPropertiesByOwner(propKey, oid));
            logEl.innerText += `\nâœ… You rightï¼Œclear others ã€Œ${propDisplayName}ã€`;
            logEl.scrollTop = logEl.scrollHeight;
          }
          alert(`You rightï¼šreserve your own ã€Œ${propDisplayName}ã€ï¼Œclear others ã€Œ${propDisplayName}ã€`);
        } else {
          // âŒ ç­”éŒ¯ï¼šæ¸…æ‰è‡ªå·±çš„ã€å…¶ä»–äººä¿ç•™
          if (mine.length > 0) {
            clearPropertiesByOwner(propKey, me);
            logEl.innerText += `\nâŒ You wrongï¼Œyour ã€Œ${propDisplayName}ã€ clear`;
            logEl.scrollTop = logEl.scrollHeight;
          }
          alert(`You wrongï¼šyour ã€Œ${propDisplayName}ã€ clearï¼Œothers reserved`);
        }

        afterResolve && afterResolve();
      });
    }


const WATER_QUIZ_POOL = [
  {
   question: "When the Central Weather Bureau issues a heavy rain advisory, what preparation should be done to prevent water from entering your home?",
    options: ["Open the windows for ventilation", "Install flood barriers or stack sandbags", "Move furniture to block the entrance"],
     answerIndex: 1   // æ­£ç¢ºï¼š1999
  },
  {
   question: "If flooding begins inside your home, what should you do first to avoid electric shock?",
    options: ["Use a hair dryer to dry the floor quickly", "Turn off the main power switch", "Stand in the water and unplug appliances"],
   answerIndex: 1   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  },
  {
   question: "When forced to walk through a flooded area during evacuation, what is the main purpose of holding a long stick or umbrella?",
    options: ["To scare away fish in the water", "To use as a cane for support", "To check for holes or missing manhole covers ahead"],
    answerIndex: 2   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  },
  {
   question: "When driving near an underpass or low-lying area and noticing standing water, what is the safest action?",
    options: ["Accelerate and rush through", "Never attempt to pass; take an alternate route", "Get out and push the vehicle forward"],
 
    answerIndex: 1   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  },
  {
   question: "After a flood, even if tap water looks clean, how should it be handled before drinking?",
    options: ["Drink it directly", "Add ice cubes to kill bacteria", "Boil it thoroughly before consuming"],
       answerIndex: 2   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  }
];


    function askWaterBureauQuestion(onDone) {
  // éš¨æ©ŸæŒ‘ä¸€é¡Œ
  const quiz = WATER_QUIZ_POOL[Math.floor(Math.random() * WATER_QUIZ_POOL.length)];

  const modal = document.createElement("div");
  Object.assign(modal.style, {
    position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
    display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
  });

  const box = document.createElement("div");
  Object.assign(box.style, {
    background: "#fff", padding: "20px", borderRadius: "10px",
    width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
  });

  const h3 = document.createElement("h3");
  h3.textContent = quiz.question;
  box.appendChild(h3);

  quiz.options.forEach((opt, idx) => {
    const btn = document.createElement("button");
    btn.textContent = opt;
    btn.classList.add('quiz-opt');
    Object.assign(btn.style, { 
      display: "block", margin: "8px auto", padding: "8px 16px", cursor: "pointer"
    });

    btn.onclick = () => {
      const correct = (idx === quiz.answerIndex);
      document.body.removeChild(modal);
      onDone && onDone(correct);
    };

    box.appendChild(btn);
  });

  modal.appendChild(box);
  document.body.appendChild(modal);
}


const MUSEUM_QUIZ_POOL = [
  {
   question: "In which year did the 921 Taiwan Earthquake occur?",
  options: ["1998", "1999", "2000"],
   answerIndex: 1   // æ­£ç¢ºï¼š1999
  },
  {
   question: "According to the national defense guidelines, which app is recommended for locating nearby air-raid shelters?",
  options: ["NHI Express App", "National Police Agency Service App", "Taiwan High-Speed Rail App"],
    answerIndex: 1   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  },
  {
    question: "When an earthquake occurs while you are driving, which of the following is the correct action according to disaster-prevention guidelines?",
  options: [
    "Brake immediately and stop in the middle of the road",
    "Slow down and pull over, staying inside the vehicle until the shaking stops",
    "Abandon the car and run for cover"  ],
    answerIndex: 1   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  },
  {
   question: "If an earthquake occurs during the night while you are sleeping, which action is the safest?",
  options: [
    "Stay in bed, turn face down, and use a pillow to protect your head and neck",
    "Jump out of bed immediately and hide under the bed",
    "Open the door and run outside immediately"
  ],
    answerIndex: 0   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  },
  {
   question: "During an earthquake, which of the following actions is *incorrect* and likely to cause injury?",
  options: [
    "Take cover under a sturdy table (Drop, Cover, and Hold On)",
    "Panic and run outdoors",
    "Stay away from windows and hanging objects"
  ],
    answerIndex: 1   // æ­£ç¢ºï¼šè­¦æ”¿æœå‹™ App
  }
];



function askMuseumQuestion(onDone) {
  // éš¨æ©ŸæŒ‘ä¸€é¡Œ
  const quiz = MUSEUM_QUIZ_POOL[Math.floor(Math.random() * MUSEUM_QUIZ_POOL.length)];

  const modal = document.createElement("div");
  Object.assign(modal.style, {
    position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
    display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
  });

  const box = document.createElement("div");
  Object.assign(box.style, {
    background: "#fff", padding: "20px", borderRadius: "10px",
    width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
  });

  const h3 = document.createElement("h3");
  h3.textContent = quiz.question;
  box.appendChild(h3);

  quiz.options.forEach((opt, idx) => {
    const btn = document.createElement("button");
    btn.textContent = opt;
    btn.classList.add('quiz-opt');
    Object.assign(btn.style, { 
      display: "block", margin: "8px auto", padding: "8px 16px", cursor: "pointer"
    });

    btn.onclick = () => {
      const correct = (idx === quiz.answerIndex);
      document.body.removeChild(modal);
      onDone && onDone(correct);
    };

    box.appendChild(btn);
  });

  modal.appendChild(box);
  document.body.appendChild(modal);
}


const FIRE_QUIZ_POOL = [
  {
   question: "If your clothes catch on fire, which three actions should you take to extinguish the flames?",
    options: [
      "Run, shout, and jump (run as fast as possible)",
      "Stop, drop, and roll (stop moving, lie down, and roll side to side)",
      "Rinse, remove, and soak (immediately find cold water)"
    ],
    answerIndex: 1   // æ­£è§£ï¼šåœã€èººã€æ»¾
  },
  {
   question: "During a fire, is it safe to take an elevator in order to escape quickly?",
    options: [
      "Absolutely not â€” the elevator may lose power or draw in smoke",
      "Yes, it is the fastest way to go down",
      "Only people on higher floors can take it"
    ],
    answerIndex: 0   // æ­£è§£ï¼šçµ•å°ä¸å¯ä»¥
  },
  {
   question: "When escaping from a burning room or house, which action can effectively slow down the spread of fire and smoke?",
    options: [
      "Screaming loudly",
      "Breaking all the windows",
      "Closing the door behind you"
    ],
    answerIndex: 2   // æ­£è§£ï¼šéš¨æ‰‹é—œé–€
  },
  {
    question: "What should you do when encountering heavy smoke?",
    options: [
      "Stay low and cover your mouth and nose while moving",
      "Raise your head, run quickly, and take the elevator",
      "Take the elevator to leave immediately"
    ],
    answerIndex: 0   // æ­£è§£ï¼šä½å§¿å‹¢æ©ä½å£é¼»å‰é€²
  }
];
   


    function askfireQuestion(onDone)  {
  // éš¨æ©ŸæŒ‘ä¸€é¡Œ
  const quiz = FIRE_QUIZ_POOL[Math.floor(Math.random() * FIRE_QUIZ_POOL.length)];

  const modal = document.createElement("div");
  Object.assign(modal.style, {
    position: "fixed", inset: "0", background: "rgba(0,0,0,0.6)",
    display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
  });

  const box = document.createElement("div");
  Object.assign(box.style, {
    background: "#fff", padding: "20px", borderRadius: "10px",
    width: "320px", textAlign: "center", boxShadow: "0 8px 24px rgba(0,0,0,0.3)"
  });

  const h3 = document.createElement("h3");
  h3.textContent = quiz.question;
  box.appendChild(h3);

  quiz.options.forEach((opt, idx) => {
    const btn = document.createElement("button");
    btn.textContent = opt;
    btn.classList.add('quiz-opt');
    Object.assign(btn.style, { 
      display: "block", margin: "8px auto", padding: "8px 16px", cursor: "pointer"
    });

    btn.onclick = () => {
      const correct = (idx === quiz.answerIndex);
      document.body.removeChild(modal);
      onDone && onDone(correct);
    };

    box.appendChild(btn);
  });

  modal.appendChild(box);
  document.body.appendChild(modal);
}
    

    function getCellImageSrc(index) {
      const cell = gameBoard.children[index];
      const imgEl = cell ? cell.querySelector('img') : null;
      return imgEl ? imgEl.src : (mapData[index] || "");
    }
    // === å…¨åŸŸï¼šåœ°ç”¢è™•ç†ï¼ˆè³¼è²·ï¼éè·¯è²»ï¼‰===
    async function handleProperty(index, afterDone) {
      const imgSrc = getCellImageSrc(index);            // ç”¨ DOM è®€åœ–
      const pKey = propertyKeys[index] || getPropertyKey(imgSrc);
      if (!pKey) {
        console.log('[PROP] not a property:', { index, imgSrc });
        afterDone && afterDone();
        return;
      }

      propertyKeys[index] = pKey;

      // owner æ­£è¦åŒ–ï¼šç„¡äºº â†’ 0
      if (propertyOwners[index] == null) {
        const parsed = getOwnerFromImg(imgSrc);         // 0..4 æˆ– null
        propertyOwners[index] = (parsed == null ? 0 : parsed);
      }

      const owner = propertyOwners[index];              // 0 | 1..4
      const me = currentPlayer + 1;
      const def = PROPERTY_DEFS[pKey];
      const price = def.buyPrice;
      const toll = def.toll;

      const name = def.display;

      console.log('[PROP] enter', { index, pKey, name, imgSrc, owner, me, price, myScore: playerScores[currentPlayer] });

      // ç„¡äººæŒæœ‰ â†’ è©¢å•æ˜¯å¦è³¼è²·
      if (owner === 0) {
        if (playerScores[currentPlayer] >= price) {
          console.log('[PROP] ask to buy', { name, price, me });
          const yes = await showConfirm(`ã€Œ${name}ã€ price ${price} ptsã€‚ Player${currentPlayer+1} want to buyï¼Ÿ`);
		  
          if (yes) {
            playerScores[currentPlayer] -= price;
            propertyOwners[index] = me;
            setTileImage(index, imageForOwner(pKey, me)); // åŒæ­¥ mapData + DOM
            updateStatus(); // å…ˆåˆ·æ–°è¨ˆåˆ†æ¿

            setTimeout(() => {
              logEl.innerText += ` cost ${price} pts buyã€Œ${name}ã€`;
              logEl.scrollTop = logEl.scrollHeight;
              afterDone && afterDone();
            }, 0);
            return;
          }
        } else {
          alert(`Player${me} pts not enough, can't buyã€Œ${name}ã€ï¼ˆneed ${price} ptsï¼‰`);
          logEl.innerText += `pts not enough, can't buyã€Œ${name}ã€ï¼ˆneed ${price} ptsï¼‰`;
          logEl.scrollTop = logEl.scrollHeight;
        }
        afterDone && afterDone();
        return;
      }

      // === å·²æœ‰äººæŒæœ‰ â†’ ä»˜éè·¯è²»æˆ–è‡ªå·±çš„åœ° ===
      if (owner !== me) {
        if (playerScores[currentPlayer] >= toll) {
          // å¤ éŒ¢ï¼Œæ­£å¸¸ä»˜è²»
          playerScores[currentPlayer] -= toll;
          playerScores[owner - 1] += toll;
          updateStatus(); // å…ˆåˆ·æ–°è¨ˆåˆ†æ¿

          setTimeout(() => {
            alert(`Player${me} payã€Œ${name}ã€ ${toll} pts to Player${owner}`);
            logEl.innerText += `\nğŸ’° Player${me} payã€Œ${name}ã€ ${toll} pts to Player${owner}`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            afterDone && afterDone();
          }, 0);
          return;
        } else {
          // ä¸å¤ ï¼šæŠŠå…¨éƒ¨çµ¦å°æ–¹ï¼ˆå¯ä¾è¦å‰‡æ”¹ï¼‰
          const all = playerScores[currentPlayer];
          playerScores[owner - 1] += all;
          playerScores[currentPlayer] = 0;
          updateStatus();

          setTimeout(() => {
            alert(`Player${me} pts not enoughï¼Œpay ${all} pts to player${owner}`);
            logEl.innerText += `\nâš ï¸ Player${me} pts not enoughï¼Œpay ${all} pts to player${owner}`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            afterDone && afterDone();
          }, 0);
          return;
        }
      }

      // è‡ªå·±çš„åœ° â†’ æ²’äº‹
      afterDone && afterDone();
    }



    async function handleEventEffect(event, fromStep) {
      console.log("handleEventEffect");
      showEventCard(event, async() => {
        const moveEffects = ["Advance 1 space", "Advance 2 spaces", "Move back 1 space", "Move back 2 spaces", "Return to start"];
        const log = document.getElementById("log");
        const lastRoll = lastDiceRoll[currentPlayer];
        log.innerText += `  Trigger Eventï¼šã€Œ${event.desc} ${event.effect}ã€`;
        log.scrollTop = log.scrollHeight;


        let newStep = playerSteps[currentPlayer];

        if (event.effect === "Advance 1 space") {
          newStep = (newStep + 1) % pathIndices.length;
        } else if (event.effect === "Advance 2 spaces") {
          newStep = (newStep + 2) % pathIndices.length;
        } else if (event.effect === "Move back 1 space") {
          newStep = (newStep - 1 + pathIndices.length) % pathIndices.length;
        } else if (event.effect === "Move back 2 spaces") {
          newStep = (newStep - 2 + pathIndices.length) % pathIndices.length;
        } else if (event.effect === "Return to start") {
          newStep = 0;
        }
        //logAction(currentPlayer, dice, newStep);
        if (event.effect === "Gain 2 points") {
          playerScores[currentPlayer] += 2;
          updateStatus();
          checkScoreWin();

        } else if (event.effect === "Gain 1 point") {
          playerScores[currentPlayer] += 1;
          updateStatus();
          checkScoreWin();
        } else if (event.effect === "Skip 1 turn") {
          skipTurn[currentPlayer] = true;
          // ç›´æ¥æ›ä¸‹ä¸€ä½ç©å®¶
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
          updateStatus();
          return; // é˜²æ­¢ç¹¼çºŒåŸ·è¡Œå¾ŒçºŒç¨‹å¼
        }
        // äº‹ä»¶ï¼šå›åˆ°èµ·é» â†’ ç›´æ¥ç¬ç§»ï¼ˆä¸æ’­æ”¾å‹•ç•«ï¼‰
        if (event.effect === "Return to start") {
          playerSteps[currentPlayer] = 0;
          renderPlayers();
          updateStatus();
          currentPlayer = (currentPlayer + 1) % nPlayers;
          document.getElementById("currentPlayer").textContent = currentPlayer + 1;
          return;
        }

        const fromIndex = pathIndices[fromStep];
        const toIndex = pathIndices[newStep];
        // æ±ºå®šå‹•ç•«æ–¹å‘ï¼šé€€å› â†’ å¾Œé€€ï¼›å…¶ä»– â†’ å‰é€²
        let animDir = (event.effect === "Move back 1 space" || event.effect === "Move back 2 spaces") ? -1 : 1;


        const imgNow = getCellImageSrc(toIndex);
        playerSteps[currentPlayer] = newStep;

        animateMove(currentPlayer, fromIndex, toIndex, async() => {
          console.log("handleEventEffect_animateMove");
          updateStatus();
          const img = mapData[toIndex] || "";

          if (passedStart) {
            playerScores[currentPlayer] += 1;

            //alert("ğŸ‰ å®Œæˆä¸€åœˆï¼ŒåŠ 1åˆ†(é€™é‚Šæ˜¯å¥—åœˆå¾Œ  èµ°åˆ°eventçš„åŠ åˆ†  ä½†å¦‚æœæ˜¯eventé€£é–å‰é€²æ˜¯ä¸åŠ åˆ†çš„)ï¼");

            log.innerText += `\nğŸ¯ Player${currentPlayer + 1} complete on lap ï¼Œadd 1 pt`;
            passedStart = false;
            updateStatus();
            alert("âš complete on lap ï¼Œadd 1 pt");
            checkScoreWin();
          }
          // === äº‹ä»¶å¾Œçš„ç›®çš„åœ°ç‰¹æ€§åˆ¤æ–· ===
          // 1) éª°å­æ ¼ï¼šå†æ“²ä¸€æ¬¡ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
          if (img.includes("dice.png")) {
            alert("ğŸ² Congratulations! You landed on a dice space and can roll again!");
            log.innerText += `\nğŸ¯ Player${currentPlayer + 1} landed on a dice space and can roll again`;
            setTimeout(() => {
              rollDice();
            }, 300);
            return;
          }
          //add
          // 2) æŠ€èƒ½å¡ï¼šæ‹¿å¡ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
          if (img.includes("card2.png")) {
            playerSkills[currentPlayer]++;
            updateStatus();
            // proceed();
            alert(`ğŸ´ Congratulationsï¼Player${currentPlayer + 1} get 1 escape cardï¼Œnow escape card number isï¼šï¼š${playerSkills[currentPlayer]} `);
            logEl.innerText += ` get 1 escape card`;
            logEl.scrollTop = logEl.scrollHeight;
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }
          if (img.includes("underdesk.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            // proceed();
            alert(`ğŸ´ Congratulationsï¼Correct protective actions, add 5 pts`);
            logEl.innerText += `Correct protective actions, add 5 pts`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }



          if (img.includes("bag1.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            // proceed();
            alert(`ğŸ´ Congratulationsï¼Having emergency supplies at home, add 5 pts`);
            logEl.innerText += ` Having emergency supplies at home, add 5 pts `;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }
		  if (img.includes("light.png")) {
            playerScores[currentPlayer] += 5;
            updateStatus();
            // proceed();
            alert(`ğŸ´ Congratulationsï¼Having flashflight at home, add 5 pts`);
            logEl.innerText += ` Having flashflight at home, add 5 pts`;
            logEl.scrollTop = logEl.scrollHeight;
            checkScoreWin();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }

          // 3) backï¼šé€€å›èµ·é»ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
          if (img.includes("back.png")) {
            alert("ğŸ“¢ Back to Start");
            log.innerText += ` Player${currentPlayer + 1}ï¼ŒBack to Start`;
            playerSteps[currentPlayer] = 0;
            renderPlayers();                  // ç«‹å³é‡ç¹ªæ£‹å­ä½ç½®
            updateStatus();
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            return;
          }
          //console.log(img, "quizåˆ¤æ–·");
          // 4) quizï¼šå•ç­”ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰

          const imgNow = (typeof getCellImageSrc === 'function') ? getCellImageSrc(toIndex) : (mapData[toIndex] || "");

          if (isQuizTileName(imgNow)) {
  if (isAskingQuiz) return; // é¿å…é‡è¤‡å‡ºé¡Œ
  isAskingQuiz = true;

  // ğŸ”¹è¾¨è­˜é¡Œç›®é¡å‹
  let category = null;
  if (imgNow.includes("quiz_earthquake.png")) category = "earthquake";
  else if (imgNow.includes("quiz_fire.png")) category = "fire";
  else if (imgNow.includes("quiz_water.png")) category = "water";


if (!USE_AI_QUIZ) {
    // ä¸ä½¿ç”¨ AIï¼šç›´æ¥å‡ºé¡Œåº«
    const q = getRandomQuiz(category);
    askQuiz(
      currentPlayer,
      () => {
        playerScores[currentPlayer] += 3;
        logEl.innerText += ` âœ… Player${currentPlayer + 1} correct answer ${catNameTC(category)} ï¼šã€Œ${q.question}ã€ +3 pts`;
        logEl.scrollTop = logEl.scrollHeight;
        updateStatus();
        checkScoreWin();
        isAskingQuiz = false;
        nextTurn();
      },
      () => {
        logEl.innerText += ` âŒ Player${currentPlayer + 1} wrong answer ${catNameTC(category)} ï¼šã€Œ${q.question}ã€`;
        logEl.scrollTop = logEl.scrollHeight;
        isAskingQuiz = false;
        nextTurn();
      },
      q
    );
    return;
  }
// ä½¿ç”¨ AIï¼šç›´æ¥å‡ºé¡Œåº«

  // ğŸ”¹ç›´æ¥å¯«åœ¨ç¨‹å¼è£¡çš„ API KEY
  const  GEMINI_KEY = localStorage.getItem("gemini_api_key");
if (! GEMINI_KEY) {
  alert("âš ï¸ ç„¡å¯ç”¨API Key æ”¹ç”¨é¡Œåº«ï¼");  
}	


  



  async function aiGenerateQuiz(category) {
    const topicMap = { fire: "fire", water: "water", earthquake: "earthquake" };
    const topic = topicMap[category] || "disaster preparedness";
   const prompt = `Please generate a single-choice question related to ${topic} for children aged 10 to 12.
Provide one question and four options (Aâ€“D), and clearly indicate the correct answer (Aâ€“D).
Follow the format strictly:
Question: AI-generated â€“ ......
A) ......
B) ......
C) ......
D) ......
Answer: A`;





    try {
      const res = await fetch("https://wispy-firefly-8762.yingli0923.workers.dev/api/gemini", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }]
          })
        }
      );
      const data = await res.json();
      const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
      const parsed = parseGeminiQuizText(text);
if (!parsed) throw new Error("AI format error");

// âœ… çµ±ä¸€æ ¼å¼ï¼šè½‰æˆ answerï¼ˆ0~3ï¼‰
return {
category: category,
  question: parsed.question,
  options: parsed.options,
  answer: typeof parsed.answerIndex === "number"
    ? parsed.answerIndex
    : parsed.answer
};
    } catch (e) {
      console.warn("AI å‡ºé¡Œå¤±æ•—:", e);
      return null;
    }
  }

  // ğŸ”¹é–‹å§‹ AI å‡ºé¡Œï¼ˆå¤±æ•—å†ç”¨é¡Œåº«ï¼‰
 (async () => {
  try {
  pauseTimer();  // â˜… é€²å…¥ AI å‡ºé¡Œ â†’ å…ˆæš«åœå€’æ•¸
    // ğŸ§  é¡¯ç¤ºé®ç½©
	
    showQuizOverlay(`â³ Generating ã€Œ${catNameTC(category)}ã€ related questionâ€¦`);

    // âš™ï¸ ç”Ÿæˆé¡Œç›®
    let q = await aiGenerateQuiz(category);

    // ğŸ” å¦‚æœAIå¤±æ•— â†’ fallback é¡Œåº«
    if (!q) {
      setQuizOverlayText(`ğŸ“˜ ä½¿ç”¨é¡Œåº«å‡ºé¡Œä¸­...`);
      q = getRandomQuiz(category);
    }

    // âœ… é—œé–‰é®ç½©ï¼ˆç”Ÿæˆå®Œæˆï¼‰
    hideQuizOverlay();
	resumeTimer();  // â˜… é¡Œç›®æº–å‚™å¥½ï¼ˆæˆ–å¤±æ•— fallbackï¼‰â†’ æ¢å¾©å€’æ•¸
    // ğŸ§© å‡ºé¡Œ
    askQuiz(
      currentPlayer,
      () => {
        playerScores[currentPlayer] += 3;
        logEl.innerText += ` âœ… Player${currentPlayer + 1} correct answer ${catNameTC(category)} ï¼šã€Œ${q.question}ã€ +3 pts`;
        logEl.scrollTop = logEl.scrollHeight;
        updateStatus();
        checkScoreWin();
        isAskingQuiz = false;
        nextTurn();
      },
      () => {
        logEl.innerText += ` âŒ Player${currentPlayer + 1} wrong answer ${catNameTC(category)} ï¼šã€Œ${q.question}ã€`;
        logEl.scrollTop = logEl.scrollHeight;
        isAskingQuiz = false;
        nextTurn();
      },
      q
    );
  } catch (err) {
    console.error("AI generated error ï¼Œuse question bankï¼š", err);
    hideQuizOverlay(); // âš ï¸ ç¢ºä¿å‡ºéŒ¯æ™‚ä¹Ÿé—œæ‰é®ç½©
	resumeTimer();
    const q = getRandomQuiz(category);
    askQuiz(currentPlayer, ()=>{}, ()=>{}, q);
  }
})();

  return; // å‡ºé¡Œå®Œå°±çµæŸ
}
		  
		  
		  
		  
		  
          // 5) æ‹†åœ°ï¼šå•ç­”ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
          // fire2ï¼šæ£®æ—åœ°ï¼ˆç”¨ askfireQuestionï¼‰
          if (imgNow.includes("fire2.png")) {
            handleOwnershipQuiz("fire2.png", "fire_station", "Forest", toIndex, askfireQuestion, () => {
              const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
              if (pKeyAfterEvent) {
                handleProperty(toIndex, () => {
                  currentPlayer = (currentPlayer + 1) % nPlayers;
                  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                  updateStatus();
                });
              } else {
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                updateStatus();
              }
            });
            return;
          }

          // rain1ï¼šä½çªªåœ°ï¼ˆç”¨ askWaterBureauQuestionï¼‰
          if (imgNow.includes("rain1.png")) {
            handleOwnershipQuiz("rain1.png", "water_bureau", "Low Lying Land", toIndex, askWaterBureauQuestion, () => {
              const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
              if (pKeyAfterEvent) {
                handleProperty(toIndex, () => {
                  currentPlayer = (currentPlayer + 1) % nPlayers;
                  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                  updateStatus();
                });
              } else {
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                updateStatus();
              }
            });
            return;
          }

          // earthquake3ï¼šé«˜æ¨“å¤§å»ˆï¼ˆç”¨ askMuseumQuestionï¼‰
          if (imgNow.includes("earthquake3.png")) {
            handleOwnershipQuiz("earthquake3.png", "museum921", "High Building", toIndex, askMuseumQuestion, () => {
              const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(getCellImageSrc(toIndex));
              if (pKeyAfterEvent) {
                handleProperty(toIndex, () => {
                  currentPlayer = (currentPlayer + 1) % nPlayers;
                  document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                  updateStatus();
                });
              } else {
                currentPlayer = (currentPlayer + 1) % nPlayers;
                document.getElementById("currentPlayer").textContent = currentPlayer + 1;
                updateStatus();
              }
            });
            return;
          }





          // 5) è‹¥ landing æ˜¯äº‹ä»¶æ ¼ï¼Œä¸”æœ¬æ¬¡äº‹ä»¶æ˜¯ã€Œä½ç§»å‹äº‹ä»¶ã€ï¼Œåšäº‹ä»¶é€£é–ï¼ˆä¸æª¢æŸ¥åœ°ç”¢ï¼‰
          if ((img.includes("event1.png") || img.includes("event2.png")) && moveEffects.includes(event.effect)) {
            //alert("é€£é–äº‹ä»¶å¡");
            const nextEvent = eventList[Math.floor(Math.random() * eventList.length)];
            setTimeout(() => {
              handleEventEffect(nextEvent, newStep);
            }, 200);
            return;
          }
          // 6) ä»¥ä¸Šçš†é â†’ åœ¨é€™è£¡æª¢æŸ¥åœ°ç”¢ï¼ˆè²·åœ°ï¼æ”¶è²»ï¼‰ï¼Œè™•ç†å®Œæ‰æ›äºº
          const imgSrcNow = getCellImageSrc(toIndex);
          console.log('LAND after event:', toIndex, imgSrcNow, 'cachedKey=', propertyKeys[toIndex]);

          const pKeyAfterEvent = propertyKeys[toIndex] || getPropertyKey(imgSrcNow);
          if (pKeyAfterEvent) {
            handleProperty(toIndex, () => {
              currentPlayer = (currentPlayer + 1) % nPlayers;
              document.getElementById("currentPlayer").textContent = currentPlayer + 1;
              updateStatus();
            });
          } else {
            currentPlayer = (currentPlayer + 1) % nPlayers;
            document.getElementById("currentPlayer").textContent = currentPlayer + 1;
            updateStatus();
          }
        }, animDir);
      });
    }
    document.addEventListener('keydown', function (e) {
      if ((e.code === "Space" || e.key === " ") && !gameEnded) {
        e.preventDefault();
        rollDice();
      }
    });

function showConfirm(msg, { okText = "Ok", cancelText = "Cancel" } = {}) {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.className = "dm-overlay";
    const box = document.createElement("div");
    box.className = "dm-box";
    const p = document.createElement("div");
    p.textContent = msg;
    const actions = document.createElement("div");
    actions.className = "dm-actions";
    const btnCancel = document.createElement("button");
    btnCancel.className = "dm-btn cancel";
    btnCancel.textContent = cancelText;
    const btnOk = document.createElement("button");
    btnOk.className = "dm-btn ok";
    btnOk.textContent = okText;

    btnCancel.onclick = () => { document.body.removeChild(overlay); resolve(false); };
    btnOk.onclick = () => { document.body.removeChild(overlay); resolve(true); };
    overlay.onclick = (e) => { if (e.target === overlay) btnCancel.onclick(); }; // é»é®ç½©å–æ¶ˆ
    actions.append(btnCancel, btnOk);
    box.append(p, actions);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
  });
}

// ----- è‡ªè¨‚ ALERTï¼ˆä½ç½®å¯æ§ã€å¤–è§€èˆ‡ confirm ä¸€è‡´ï¼‰-----
function showAlert(message, { okText = "Ok" } = {}) {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.className = "dm-overlay";          // â† ç”¨ä½ å·²å­˜åœ¨çš„æ¨£å¼
    const box = document.createElement("div");
    box.className = "dm-box";

    const content = document.createElement("div");
    content.textContent = String(message);

    const actions = document.createElement("div");
    actions.className = "dm-actions";
    const btnOk = document.createElement("button");
    btnOk.className = "dm-btn ok";
    btnOk.textContent = okText;

    btnOk.onclick = () => { document.body.removeChild(overlay); resolve(); };
    overlay.onclick = (e) => { if (e.target === overlay) btnOk.onclick(); }; // é»é®ç½©ï¼é—œé–‰

    actions.appendChild(btnOk);
    box.append(content, actions);
    overlay.appendChild(box);
    document.body.appendChild(overlay);
  });
}

// å…¨åŸŸè¦†å¯« alertï¼šä¹‹å¾Œå‘¼å« alert("è¨Šæ¯") æœƒé¡¯ç¤ºåœ¨ç›¸åŒä½ç½®
// å‚™è¨»ï¼šé€™æ˜¯éé˜»å¡çš„ã€‚è‹¥ä½ æƒ³ç­‰å¾…ä½¿ç”¨è€…æŒ‰ã€Œå¥½ã€å†ç¹¼çºŒï¼Œè«‹åœ¨å‘¼å«è™•ç”¨ `await alert("...")`ã€‚
window.alert = (msg) => showAlert(msg);

  </script>
  
  
  
  </div>
</body>

</html>